diff --git a/js/src/jit/arm/Assembler-arm.cpp b/js/src/jit/arm/Assembler-arm.cpp
--- a/js/src/jit/arm/Assembler-arm.cpp
+++ b/js/src/jit/arm/Assembler-arm.cpp
@@ -2126,8 +2126,8 @@
   }
   // vld1 (single element to single lane) with index=0, size=2
   MOZ_ASSERT(vd.isFloat());
-  uint32_t index = (vd.code() & 1);
-  return writeInst(0xF4A0080F | RN(rn) | VD(vd.asDouble()) | (index << 5));
+  MOZ_ASSERT((vd.code() & 1) == 0);
+  return writeInst(0xF4A0080F | RN(rn) | VD(vd.asDouble()));
 }
 
 BufferOffset Assembler::as_vstr_unaligned(VFPRegister vd, Register rn) {
@@ -2138,8 +2138,8 @@
   }
   // vst1 (single element from one lane) with index=0, size=2
   MOZ_ASSERT(vd.isFloat());
-  uint32_t index = (vd.code() & 1);
-  return writeInst(0xF480080F | RN(rn) | VD(vd.asDouble()) | (index << 5));
+  MOZ_ASSERT((vd.code() & 1) == 0);
+  return writeInst(0xF480080F | RN(rn) | VD(vd.asDouble()));
 }
 
 BufferOffset Assembler::as_vimm(VFPRegister vd, VFPImm imm, Condition c) {
diff --git a/js/src/jit/arm/MacroAssembler-arm.cpp b/js/src/jit/arm/MacroAssembler-arm.cpp
--- a/js/src/jit/arm/MacroAssembler-arm.cpp
+++ b/js/src/jit/arm/MacroAssembler-arm.cpp
@@ -6168,7 +6168,17 @@
         // NEON available: The VLD1 multiple-single-elements variant will only
         // trap if SCTRL.A==1, but we already assume (for integer accesses) that
         // the hardware/OS handles that transparently.
-        load = as_vldr_unaligned(dest, scratch);
+        //
+        // An additional complication is that if we're targeting the high single
+        // then an unaligned load is not possible, and we may need to go via the
+        // FPR scratch.
+        if (byteSize == 4 && dest.code() & 1) {
+          ScratchFloat32Scope fscratch(asMasm());
+          load = as_vldr_unaligned(fscratch, scratch);
+          as_vmov(dest, fscratch);
+        } else {
+          load = as_vldr_unaligned(dest, scratch);
+        }
       } else {
         // NEON not available: Load to GPR scratch, move to FPR destination.  We
         // don't have adjacent scratches for the f64, so use individual LDRs,
@@ -6253,7 +6263,13 @@
 
       // See comments above at wasmLoadImpl for more about this logic.
       if (HasNEON()) {
-        store = as_vstr_unaligned(val, scratch);
+        if (byteSize == 4 && (val.code() & 1)) {
+          ScratchFloat32Scope fscratch(asMasm());
+          as_vmov(fscratch, val);
+          store = as_vstr_unaligned(fscratch, scratch);
+        } else {
+          store = as_vstr_unaligned(val, scratch);
+        }
       } else {
         // NEON not available: Move FPR to GPR scratch, store GPR.  We have only
         // one scratch to hold the value, so for f64 we must do two separate
diff --git a/js/src/jit/arm/Simulator-arm.cpp b/js/src/jit/arm/Simulator-arm.cpp
--- a/js/src/jit/arm/Simulator-arm.cpp
+++ b/js/src/jit/arm/Simulator-arm.cpp
@@ -4881,6 +4881,10 @@
         if (size != 2 || align) {
           MOZ_CRASH("NYI");
         }
+        int a = instr->bits(5, 4);
+        if (a != 0 && a != 3) {
+          MOZ_CRASH("Unspecified");
+        }
         if (index > 1) {
           Vd++;
           index -= 2;


