# HG changeset patch
# User Alexandre Lissy <lissyx+mozillians@lissyx.dyndns.org>
# Date 1730190122 0
# Node ID 10accc07a69d7bff15cb18a73274093db131fbed
# Parent  294acbbb2573bfa083ebabe99c99b43a730c438e
Bug 1927320 - Use GET_REAL_SYMBOL() interposition for __register_atfork() / __cxa_finalize() r=glandium

In earlier version of working on those interposers, for some
undetermined reason the resolution would fail to find the glibc symbol
when using GET_REAL_SYMBOL() and we had to make use of dlvsym() instead.

After testing again this seems not to hold anymore so we can just make
use of GET_REAL_SYMBOL().

Differential Revision: https://phabricator.services.mozilla.com/D226984

diff --git a/mozglue/interposers/pthread_atfork_interposer.cpp b/mozglue/interposers/pthread_atfork_interposer.cpp
--- a/mozglue/interposers/pthread_atfork_interposer.cpp
+++ b/mozglue/interposers/pthread_atfork_interposer.cpp
@@ -71,23 +71,20 @@ struct moz_pthread_atfork_handler {
 struct moz_pthread_atfork_handler mozPthreadHandlers;
 
 #  if defined(LIBC_GLIBC)
 // On glibc the pthread_atfork may be available only from libc_nonshared.a
 // so prefer interposing the linker-resolved __register_atfork()
 
 extern const void* const __dso_handle;
 using register_atfork_t = int (*)(void (*)(), void (*)(), void (*)(),
-                                  const void* const) noexcept;
+                                  const void* const);
 static register_atfork_t real_register_atfork = nullptr;
-
-using cxa_finalize_t = void (*)(void*) noexcept;
-static cxa_finalize_t real_cxa_finalize = nullptr;
 #  else
-using pthread_atfork_t = int (*)(void (*)(), void (*)(), void (*)()) noexcept;
+using pthread_atfork_t = int (*)(void (*)(), void (*)(), void (*)());
 static pthread_atfork_t real_pthread_atfork = nullptr;
 #  endif
 
 static int notReadyCount = 0;
 
 extern "C" {
 
 #  if defined(LIBC_GLIBC)
@@ -145,81 +142,41 @@ MFBT_API int pthread_atfork(void (*aPref
     rv = ENOMEM;
   }
 
   return rv;
 }
 
 #  if defined(LIBC_GLIBC)
 MFBT_API void __cxa_finalize(void* handle) {
+  static const auto real_cxa_finalize = GET_REAL_SYMBOL(__cxa_finalize);
   real_cxa_finalize(handle);
   mozPthreadHandlers.remove(handle);
 }
 #  endif
 }
 
 #  if defined(LIBC_GLIBC)
 __attribute__((used)) __attribute__((constructor)) void register_atfork_setup(
     void) {
-  const char* glibc_version_register =
-#    if defined(__x86_64__) || defined(__i386__)
-      "GLIBC_2.3.2"
-#    elif defined(__aarch64__)
-      "GLIBC_2.17"
-#    else
-#      error \
-          "Missing GLIBC version for __register_atfork(). Please objdump -tTC libc.so.6 and add"
-#    endif
-      ;
-
-  // Use dlvsym() otherwise symbol resolution may find the interposed version
-  real_register_atfork = (register_atfork_t)dlvsym(nullptr, "__register_atfork",
-                                                   glibc_version_register);
-
-  MOZ_ASSERT(real_register_atfork != nullptr, "Found real_register_atfork");
-  MOZ_ASSERT(real_register_atfork != __register_atfork,
-             "Found register_atfork from libc");
-
-  const char* glibc_version_finalize =
-#    if defined(__i386__)
-      "GLIBC_2.1.3"
-#    elif defined(__x86_64__)
-      "GLIBC_2.2.5"
-#    elif defined(__aarch64__)
-      "GLIBC_2.17"
-#    else
-#      error \
-          "Missing GLIBC version for __cxa_finalize(). Please objdump -tTC libc.so.6 and add"
-#    endif
-      ;
-  // Use dlvsym() otherwise symbol resolution may find the interposed version
-  real_cxa_finalize =
-      (cxa_finalize_t)dlvsym(nullptr, "__cxa_finalize", glibc_version_finalize);
-
-  MOZ_ASSERT(real_cxa_finalize != nullptr, "Found real_cxa_finalize");
-  MOZ_ASSERT(real_cxa_finalize != __cxa_finalize,
-             "Found cxa_finalize from libc");
+  real_register_atfork = GET_REAL_SYMBOL(__register_atfork);
 
   if (notReadyCount > 0) {
     for (int i = 0; i < notReadyCount; ++i) {
       real_register_atfork(mozPthreadHandlers.handlers[i][idxPreFork],
                            mozPthreadHandlers.handlers[i][idxPostForkParent],
                            mozPthreadHandlers.handlers[i][idxPostForkChild],
                            __dso_handle);
     }
   }
 }
 #  else
 __attribute__((used)) __attribute__((constructor)) void pthread_atfork_setup(
     void) {
-  real_pthread_atfork = (pthread_atfork_t)dlsym(RTLD_NEXT, "pthread_atfork");
-
-  MOZ_ASSERT(real_pthread_atfork != nullptr, "Found real_pthread_atfork");
-  MOZ_ASSERT(real_pthread_atfork != pthread_atfork,
-             "Found pthread_atfork from libc");
+  real_pthread_atfork = GET_REAL_SYMBOL(pthread_atfork);
 
   if (notReadyCount > 0) {
     for (int i = 0; i < notReadyCount; ++i) {
       real_pthread_atfork(mozPthreadHandlers.handlers[i][idxPreFork],
                           mozPthreadHandlers.handlers[i][idxPostForkParent],
                           mozPthreadHandlers.handlers[i][idxPostForkChild]);
     }
   }


