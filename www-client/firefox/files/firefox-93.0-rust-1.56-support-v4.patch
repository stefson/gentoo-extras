# HG changeset patch
# User Mike Hommey <mh+mozilla@glandium.org>
# Date 1631692401 0
# Node ID 0a7c0bdb2c19fbf6ee6d4f99e037340068531850
# Parent  1f96f89c6fc825dd31ab9a43f2cff03cd4144626
Bug 1730397 - Fix unstable-name-collisions in mio. r=emilio

Our copy of mio is already self-vendored, so we don't need a Cargo.toml
change to be able to apply in-tree changes.

Differential Revision: https://phabricator.services.mozilla.com/D125508

diff --git a/third_party/rust/mio/src/sys/unix/tcp.rs b/third_party/rust/mio/src/sys/unix/tcp.rs
--- a/third_party/rust/mio/src/sys/unix/tcp.rs
+++ b/third_party/rust/mio/src/sys/unix/tcp.rs
@@ -108,21 +108,21 @@ impl TcpStream {
         self.inner.set_only_v6(only_v6)
     }
 
     pub fn only_v6(&self) -> io::Result<bool> {
         self.inner.only_v6()
     }
 
     pub fn set_linger(&self, dur: Option<Duration>) -> io::Result<()> {
-        self.inner.set_linger(dur)
+        TcpStreamExt::set_linger(&self.inner, dur)
     }
 
     pub fn linger(&self) -> io::Result<Option<Duration>> {
-        self.inner.linger()
+        TcpStreamExt::linger(&self.inner)
     }
 
     pub fn take_error(&self) -> io::Result<Option<io::Error>> {
         self.inner.take_error()
     }
 
     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {
         self.inner.peek(buf)
diff --git a/third_party/rust/mio/src/sys/windows/tcp.rs b/third_party/rust/mio/src/sys/windows/tcp.rs
--- a/third_party/rust/mio/src/sys/windows/tcp.rs
+++ b/third_party/rust/mio/src/sys/windows/tcp.rs
@@ -183,21 +183,21 @@ impl TcpStream {
         self.imp.inner.socket.set_only_v6(only_v6)
     }
 
     pub fn only_v6(&self) -> io::Result<bool> {
         self.imp.inner.socket.only_v6()
     }
 
     pub fn set_linger(&self, dur: Option<Duration>) -> io::Result<()> {
-        self.imp.inner.socket.set_linger(dur)
+        Net2TcpExt::set_linger(&self.imp.inner.socket, dur)
     }
 
     pub fn linger(&self) -> io::Result<Option<Duration>> {
-        self.imp.inner.socket.linger()
+        Net2TcpExt::linger(&self.imp.inner.socket)
     }
 
     pub fn take_error(&self) -> io::Result<Option<io::Error>> {
         if let Some(e) = self.imp.inner.socket.take_error()? {
             return Ok(Some(e))
         }
 
         // If the syscall didn't return anything then also check to see if we've


