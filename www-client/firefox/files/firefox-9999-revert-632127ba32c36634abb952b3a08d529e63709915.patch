diff --git a/build/moz.configure/rust.configure b/build/moz.configure/rust.configure
index c3736eb..5c97f32 100644
--- a/build/moz.configure/rust.configure
+++ b/build/moz.configure/rust.configure
@@ -169,10 +169,7 @@ def rust_supported_targets(rustc):
     per_raw_os = {}
     for t in out:
         t = split_triplet(t, allow_unknown=True)
-        endianness = t.endianness
-        if t.cpu.startswith('thumb') and endianness not in ('big', 'little'):
-            endianness = 'little'
-        key = (t.cpu, endianness, t.os)
+        key = (t.cpu, t.endianness, t.os)
         if key in per_os:
             previous = per_os[key]
             per_raw_os[(previous.cpu, previous.endianness,
@@ -187,7 +184,7 @@ def rust_supported_targets(rustc):
             # normalize.
             if raw_os == 'androideabi':
                 raw_os = 'linux-androideabi'
-            per_raw_os[(t.cpu, endianness, raw_os)] = t
+            per_raw_os[(t.cpu, t.endianness, raw_os)] = t
         else:
             per_os[key] = t
     return namespace(per_os=per_os, per_raw_os=per_raw_os)
@@ -204,7 +201,7 @@ def rust_triple_alias(host_or_target):
     host_or_target_str = {host: 'host', target: 'target'}[host_or_target]
 
     @depends(rustc, host_or_target, c_compiler, rust_supported_targets,
-             arm_target, when=rust_compiler)
+             when=rust_compiler)
     @checking('for rust %s triplet' % host_or_target_str)
     @imports('os')
     @imports('subprocess')
@@ -213,7 +210,7 @@ def rust_triple_alias(host_or_target):
     @imports(_from='tempfile', _import='mkstemp')
     @imports(_from='textwrap', _import='dedent')
     def rust_target(rustc, host_or_target, compiler_info,
-                    rust_supported_targets, arm_target):
+                    rust_supported_targets):
         # Rust's --target options are similar to, but not exactly the same
         # as, the autoconf-derived targets we use.  An example would be that
         # Rust uses distinct target triples for targetting the GNU C++ ABI
@@ -233,23 +230,13 @@ def rust_triple_alias(host_or_target):
             host_or_target_os = host_or_target.os
             host_or_target_raw_os = host_or_target.raw_os
 
-        if host_or_target.cpu == 'arm' and arm_target.arm_arch == 7 and \
-                arm_target.fpu == 'neon' and arm_target.thumb2:
-            host_or_target_cpus = ('thumbv7neon', host_or_target.cpu)
-        else:
-            host_or_target_cpus = (host_or_target.cpu,)
-
-        for host_or_target_cpu in host_or_target_cpus:
-            rustc_target = rust_supported_targets.per_os.get(
-                (host_or_target_cpu, host_or_target.endianness, host_or_target_os))
-            if rustc_target:
-                break
+        rustc_target = rust_supported_targets.per_os.get(
+            (host_or_target.cpu, host_or_target.endianness, host_or_target_os))
 
+        if rustc_target is None:
             rustc_target = rust_supported_targets.per_raw_os.get(
-                (host_or_target_cpu, host_or_target.endianness,
+                (host_or_target.cpu, host_or_target.endianness,
                  host_or_target_raw_os))
-            if rustc_target:
-                break
 
         if rustc_target is None:
             die("Don't know how to translate {} for rustc".format(
diff --git a/build/moz.configure/rust.configure.orig b/build/moz.configure/rust.configure.orig
new file mode 100644
index 0000000..c3736eb
--- /dev/null
+++ b/build/moz.configure/rust.configure.orig
@@ -0,0 +1,359 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+
+# Rust is required by `rust_compiler` below. We allow_missing here
+# to propagate failures to the better error message there.
+js_option(env='RUSTC', nargs=1, help='Path to the rust compiler')
+js_option(env='CARGO', nargs=1, help='Path to the Cargo package manager')
+
+rustc = check_prog('RUSTC', ['rustc'], paths=toolchain_search_path,
+                   input='RUSTC', allow_missing=True)
+cargo = check_prog('_CARGO', ['cargo'], what='cargo',
+                   paths=toolchain_search_path, input='CARGO',
+                   allow_missing=True)
+
+
+@depends(cargo, host)
+@imports('subprocess')
+@imports(_from='__builtin__', _import='open')
+@imports('os')
+def cargo(cargo, host):
+    # The cargo executable can be either a rustup wrapper, or a real,
+    # plain, cargo. In the former case, on OSX, rustup sets
+    # DYLD_LIBRARY_PATH (at least until
+    # https://github.com/rust-lang/rustup.rs/pull/1752 is merged and shipped)
+    # and that can wreck havoc (see bug 1536486).
+    #
+    # So if we're in that situation, find the corresponding real plain
+    # cargo.
+    #
+    # To achieve that, try to run `cargo +stable`. When it's the rustup
+    # wrapper, it either prints cargo's help and exits with status 0, or print
+    # an error message (error: toolchain 'stable' is not installed) and exits
+    # with status 1. When it's plain cargo, it exits with a different error
+    # message (error: no such subcommand: `+stable`), and exits with status
+    # 101.
+    if host.os == 'OSX':
+        with open(os.devnull, 'wb') as devnull:
+            retcode = subprocess.call(
+                [cargo, '+stable'], stdout=devnull, stderr=devnull)
+        if retcode != 101:
+            # We now proceed to find the real cargo. We're not sure `rustup`
+            # is in $PATH, but we know the cargo executable location, and that
+            # it /is/ rustup, so we can pass it `rustup` as argv[0], which
+            # will make it act as rustup.
+            # Note we could avoid the `cargo +stable` call above, but there's
+            # the possibility that there's a `cargo-which` command that would
+            # not fail with running `cargo which cargo` with a real cargo.
+            out = check_cmd_output('rustup', 'which', 'cargo',
+                                   executable=cargo).rstrip()
+            # If for some reason the above failed to return something, keep the
+            # cargo we found originally.
+            if out:
+                cargo = out
+                log.info('Actually using %s', cargo)
+    return cargo
+
+
+set_config('CARGO', cargo)
+
+
+@depends_if(rustc)
+@checking('rustc version', lambda info: info.version)
+def rustc_info(rustc):
+    out = check_cmd_output(rustc, '--version', '--verbose').splitlines()
+    info = dict((s.strip() for s in line.split(':', 1)) for line in out[1:])
+    return namespace(
+        version=Version(info.get('release', '0')),
+        commit=info.get('commit-hash', 'unknown'),
+        host=info['host'],
+    )
+
+set_config('RUSTC_VERSION', depends(rustc_info)(lambda info: str(info.version)))
+
+@depends_if(cargo)
+@checking('cargo version', lambda info: info.version)
+@imports('re')
+def cargo_info(cargo):
+    out = check_cmd_output(cargo, '--version', '--verbose').splitlines()
+    info = dict((s.strip() for s in line.split(':', 1)) for line in out[1:])
+    version = info.get('release')
+    # Older versions of cargo didn't support --verbose, in which case, they
+    # only output a not-really-pleasant-to-parse output. Fortunately, they
+    # don't error out, so we can just try some regexp matching on the output
+    # we already got.
+    if version is None:
+        VERSION_FORMAT = r'^cargo (\d\.\d+\.\d+).*'
+
+        m = re.search(VERSION_FORMAT, out[0])
+        # Fail fast if cargo changes its output on us.
+        if not m:
+            die('Could not determine cargo version from output: %s', out)
+        version = m.group(1)
+
+    return namespace(
+        version=Version(version),
+    )
+
+
+@depends(rustc_info, cargo_info, build_project)
+@imports(_from='textwrap', _import='dedent')
+def rust_compiler(rustc_info, cargo_info, build_project):
+    if not rustc_info:
+        die(dedent('''\
+        Rust compiler not found.
+        To compile rust language sources, you must have 'rustc' in your path.
+        See https://www.rust-lang.org/ for more information.
+
+        You can install rust by running './mach bootstrap'
+        or by directly running the installer from https://rustup.rs/
+        '''))
+    if build_project == 'tools/crashreporter':
+        rustc_min_version = Version('1.22.0')
+        cargo_min_version = Version('0.23.0')
+    else:
+        rustc_min_version = Version('1.32.0')
+        cargo_min_version = rustc_min_version
+
+    version = rustc_info.version
+    if version < rustc_min_version:
+        die(dedent('''\
+        Rust compiler {} is too old.
+
+        To compile Rust language sources please install at least
+        version {} of the 'rustc' toolchain and make sure it is
+        first in your path.
+
+        You can verify this by typing 'rustc --version'.
+
+        If you have the 'rustup' tool installed you can upgrade
+        to the latest release by typing 'rustup update'. The
+        installer is available from https://rustup.rs/
+        '''.format(version, rustc_min_version)))
+
+    if not cargo_info:
+        die(dedent('''\
+        Cargo package manager not found.
+        To compile Rust language sources, you must have 'cargo' in your path.
+        See https://www.rust-lang.org/ for more information.
+
+        You can install cargo by running './mach bootstrap'
+        or by directly running the installer from https://rustup.rs/
+        '''))
+
+    version = cargo_info.version
+    if version < cargo_min_version:
+        die(dedent('''\
+        Cargo package manager {} is too old.
+
+        To compile Rust language sources please install at least
+        version {} of 'cargo' and make sure it is first in your path.
+
+        You can verify this by typing 'cargo --version'.
+        ''').format(version, cargo_min_version))
+
+    return True
+
+
+@depends(rustc, when=rust_compiler)
+def rust_supported_targets(rustc):
+    out = check_cmd_output(rustc, '--print', 'target-list').splitlines()
+    # The os in the triplets used by rust may match the same OSes, in which
+    # case we need to check the raw_os instead.
+    per_os = {}
+    ambiguous = set()
+    per_raw_os = {}
+    for t in out:
+        t = split_triplet(t, allow_unknown=True)
+        endianness = t.endianness
+        if t.cpu.startswith('thumb') and endianness not in ('big', 'little'):
+            endianness = 'little'
+        key = (t.cpu, endianness, t.os)
+        if key in per_os:
+            previous = per_os[key]
+            per_raw_os[(previous.cpu, previous.endianness,
+                        previous.raw_os)] = previous
+            del per_os[key]
+            ambiguous.add(key)
+        if key in ambiguous:
+            raw_os = t.raw_os
+            # split_triplet will return a raw_os of 'androideabi' for
+            # rust targets in the form cpu-linux-androideabi, but what
+            # we get from the build system is linux-androideabi, so
+            # normalize.
+            if raw_os == 'androideabi':
+                raw_os = 'linux-androideabi'
+            per_raw_os[(t.cpu, endianness, raw_os)] = t
+        else:
+            per_os[key] = t
+    return namespace(per_os=per_os, per_raw_os=per_raw_os)
+
+
+@template
+def rust_triple_alias(host_or_target):
+    """Template defining the alias used for rustc's --target flag.
+    `host_or_target` is either `host` or `target` (the @depends functions
+    from init.configure).
+    """
+    assert host_or_target in {host, target}
+
+    host_or_target_str = {host: 'host', target: 'target'}[host_or_target]
+
+    @depends(rustc, host_or_target, c_compiler, rust_supported_targets,
+             arm_target, when=rust_compiler)
+    @checking('for rust %s triplet' % host_or_target_str)
+    @imports('os')
+    @imports('subprocess')
+    @imports(_from='mozbuild.configure.util', _import='LineIO')
+    @imports(_from='mozbuild.shellutil', _import='quote')
+    @imports(_from='tempfile', _import='mkstemp')
+    @imports(_from='textwrap', _import='dedent')
+    def rust_target(rustc, host_or_target, compiler_info,
+                    rust_supported_targets, arm_target):
+        # Rust's --target options are similar to, but not exactly the same
+        # as, the autoconf-derived targets we use.  An example would be that
+        # Rust uses distinct target triples for targetting the GNU C++ ABI
+        # and the MSVC C++ ABI on Win32, whereas autoconf has a single
+        # triple and relies on the user to ensure that everything is
+        # compiled for the appropriate ABI.  We need to perform appropriate
+        # munging to get the correct option to rustc.
+        # We correlate the autoconf-derived targets with the list of targets
+        # rustc gives us with --print target-list.
+        if host_or_target.kernel == 'WINNT':
+            if compiler_info.type in ('gcc', 'clang'):
+                host_or_target_os = 'windows-gnu'
+            else:
+                host_or_target_os = 'windows-msvc'
+            host_or_target_raw_os = host_or_target_os
+        else:
+            host_or_target_os = host_or_target.os
+            host_or_target_raw_os = host_or_target.raw_os
+
+        if host_or_target.cpu == 'arm' and arm_target.arm_arch == 7 and \
+                arm_target.fpu == 'neon' and arm_target.thumb2:
+            host_or_target_cpus = ('thumbv7neon', host_or_target.cpu)
+        else:
+            host_or_target_cpus = (host_or_target.cpu,)
+
+        for host_or_target_cpu in host_or_target_cpus:
+            rustc_target = rust_supported_targets.per_os.get(
+                (host_or_target_cpu, host_or_target.endianness, host_or_target_os))
+            if rustc_target:
+                break
+
+            rustc_target = rust_supported_targets.per_raw_os.get(
+                (host_or_target_cpu, host_or_target.endianness,
+                 host_or_target_raw_os))
+            if rustc_target:
+                break
+
+        if rustc_target is None:
+            die("Don't know how to translate {} for rustc".format(
+                host_or_target.alias))
+
+        # Check to see whether our rustc has a reasonably functional stdlib
+        # for our chosen target.
+        target_arg = '--target=' + rustc_target.alias
+        in_fd, in_path = mkstemp(prefix='conftest', suffix='.rs')
+        out_fd, out_path = mkstemp(prefix='conftest', suffix='.rlib')
+        os.close(out_fd)
+        try:
+            source = 'pub extern fn hello() { println!("Hello world"); }'
+            log.debug('Creating `%s` with content:', in_path)
+            with LineIO(lambda l: log.debug('| %s', l)) as out:
+                out.write(source)
+
+            os.write(in_fd, source)
+            os.close(in_fd)
+
+            cmd = [
+                rustc,
+                '--crate-type', 'staticlib',
+                target_arg,
+                '-o', out_path,
+                in_path,
+            ]
+
+            def failed():
+                die(dedent('''\
+                Cannot compile for {} with {}
+                The target may be unsupported, or you may not have
+                a rust std library for that target installed. Try:
+
+                  rustup target add {}
+                '''.format(host_or_target.alias, rustc, rustc_target.alias)))
+            check_cmd_output(*cmd, onerror=failed)
+            if not os.path.exists(out_path) or os.path.getsize(out_path) == 0:
+                failed()
+        finally:
+            os.remove(in_path)
+            os.remove(out_path)
+
+        # This target is usable.
+        return rustc_target.alias
+
+    return rust_target
+
+
+rust_target_triple = rust_triple_alias(target)
+rust_host_triple = rust_triple_alias(host)
+
+
+@depends(host, rust_host_triple, rustc_info.host)
+def validate_rust_host_triple(host, rust_host, rustc_host):
+    if rust_host != rustc_host:
+        if host.alias == rust_host:
+            configure_host = host.alias
+        else:
+            configure_host = '{}/{}'.format(host.alias, rust_host)
+        die("The rust compiler host ({}) is not suitable for the configure host ({})."
+            .format(rustc_host, configure_host))
+
+
+set_config('RUST_TARGET', rust_target_triple)
+set_config('RUST_HOST_TARGET', rust_host_triple)
+
+
+# This is used for putting source info into symbol files.
+set_config('RUSTC_COMMIT', depends(rustc_info)(lambda i: i.commit))
+
+# Rustdoc is required by Rust tests below.
+js_option(env='RUSTDOC', nargs=1, help='Path to the rustdoc program')
+
+rustdoc = check_prog('RUSTDOC', ['rustdoc'], paths=toolchain_search_path,
+                     input='RUSTDOC', allow_missing=True)
+
+# This option is separate from --enable-tests because Rust tests are particularly
+# expensive in terms of compile time (especially for code in libxul).
+option('--enable-rust-tests',
+       help='Enable building and running of Rust tests during `make check`')
+
+
+@depends('--enable-rust-tests', rustdoc)
+def rust_tests(enable_rust_tests, rustdoc):
+    if enable_rust_tests and not rustdoc:
+        die('--enable-rust-tests requires rustdoc')
+    return bool(enable_rust_tests)
+
+
+set_config('MOZ_RUST_TESTS', rust_tests)
+
+
+@depends(target, c_compiler, rustc)
+@imports('os')
+def rustc_natvis_ldflags(target, compiler_info, rustc):
+    if target.kernel == 'WINNT' and compiler_info.type == 'clang-cl':
+        sysroot = check_cmd_output(rustc, '--print', 'sysroot').strip()
+        etc = os.path.join(sysroot, 'lib/rustlib/etc')
+        ldflags = []
+        for f in os.listdir(etc):
+            if f.endswith('.natvis'):
+                ldflags.append('-NATVIS:' + normsep(os.path.join(etc, f)))
+        return ldflags
+
+
+set_config('RUSTC_NATVIS_LDFLAGS', rustc_natvis_ldflags)
diff --git a/python/mozbuild/mozbuild/test/configure/test_toolchain_configure.py b/python/mozbuild/mozbuild/test/configure/test_toolchain_configure.py
index 80e1ab0..307e5a9 100755
--- a/python/mozbuild/mozbuild/test/configure/test_toolchain_configure.py
+++ b/python/mozbuild/mozbuild/test/configure/test_toolchain_configure.py
@@ -13,10 +13,7 @@ from mozunit import main
 
 from common import BaseConfigureTest
 from mozbuild.configure.util import Version
-from mozbuild.util import (
-    memoize,
-    ReadOnlyNamespace,
-)
+from mozbuild.util import memoize
 from mozpack import path as mozpath
 from test_toolchain_helpers import (
     FakeCompiler,
@@ -1369,23 +1366,17 @@ class OpenBSDToolchainTest(BaseToolchainTest):
         })
 
 
-@memoize
-def gen_invoke_cargo(version):
-    def invoke_cargo(stdin, args):
+class RustTest(BaseConfigureTest):
+    def invoke_cargo(self, stdin, args):
         if args == ('--version', '--verbose'):
-            return 0, 'cargo %s\nrelease: %s' % (version, version), ''
+            return 0, 'cargo 2.0\nrelease: 2.0', ''
         raise NotImplementedError('unsupported arguments')
-    return invoke_cargo
 
-
-@memoize
-def gen_invoke_rustc(version):
-    def invoke_rustc(stdin, args):
+    def invoke_rustc(self, stdin, args):
         if args == ('--version', '--verbose'):
-            return (0, 'rustc %s\nrelease: %s\nhost: x86_64-unknown-linux-gnu'
-                       % (version, version), '')
+            return 0, 'rustc 2.0\nrelease: 2.0\nhost: x86_64-unknown-linux-gnu', ''
         if args == ('--print', 'target-list'):
-            # Raw list returned by rustc version 1.32, + ios, which somehow
+            # Raw list returned by rustc version 1.33, + ios, which somehow
             # don't appear in the default list.
             # https://github.com/rust-lang/rust/issues/36156
             rust_targets = [
@@ -1466,7 +1457,11 @@ def gen_invoke_rustc(version):
                 'thumbv7em-none-eabi',
                 'thumbv7em-none-eabihf',
                 'thumbv7m-none-eabi',
+                'thumbv7neon-linux-androideabi',
+                'thumbv7neon-unknown-linux-gnueabihf',
                 'thumbv8m.base-none-eabi',
+                'thumbv8m.main-none-eabi',
+                'thumbv8m.main-none-eabihf',
                 'wasm32-experimental-emscripten',
                 'wasm32-unknown-emscripten',
                 'wasm32-unknown-unknown',
@@ -1492,37 +1487,25 @@ def gen_invoke_rustc(version):
                 'x86_64-unknown-netbsd',
                 'x86_64-unknown-openbsd',
                 'x86_64-unknown-redox',
+                'x86_64-unknown-uefi',
             ]
-            # Additional targets from 1.33
-            if Version(version) >= '1.33.0':
-                rust_targets += [
-                    'thumbv7neon-linux-androideabi',
-                    'thumbv7neon-unknown-linux-gnueabihf',
-                    'x86_64-unknown-uefi',
-                    'thumbv8m.main-none-eabi',
-                    'thumbv8m.main-none-eabihf',
-                ]
-            return 0, '\n'.join(sorted(rust_targets)), ''
+            return 0, '\n'.join(rust_targets), ''
         if (len(args) == 6 and args[:2] == ('--crate-type', 'staticlib') and
             args[2].startswith('--target=') and args[3] == '-o'):
             with open(args[4], 'w') as fh:
                 fh.write('foo')
             return 0, '', ''
         raise NotImplementedError('unsupported arguments')
-    return invoke_rustc
 
-
-class RustTest(BaseConfigureTest):
-    def get_rust_target(self, target, compiler_type='gcc', version='1.33.0',
-                        arm_target=None):
+    def get_rust_target(self, target, compiler_type='gcc'):
         environ = {
             'PATH': os.pathsep.join(
                 mozpath.abspath(p) for p in ('/bin', '/usr/bin')),
         }
 
         paths = {
-            mozpath.abspath('/usr/bin/cargo'): gen_invoke_cargo(version),
-            mozpath.abspath('/usr/bin/rustc'): gen_invoke_rustc(version),
+            mozpath.abspath('/usr/bin/cargo'): self.invoke_cargo,
+            mozpath.abspath('/usr/bin/rustc'): self.invoke_rustc,
         }
 
         self.TARGET = target
@@ -1532,10 +1515,6 @@ class RustTest(BaseConfigureTest):
         dep = sandbox._depends[sandbox['c_compiler']]
         getattr(sandbox, '__value_for_depends')[(dep,)] = \
             CompilerResult(type=compiler_type)
-        # Same for the arm_target checks.
-        dep = sandbox._depends[sandbox['arm_target']]
-        getattr(sandbox, '__value_for_depends')[(dep,)] = \
-            arm_target or ReadOnlyNamespace(arm_arch=7, thumb2=False, fpu='vfpv2')
         return sandbox._value_for(sandbox['rust_target_triple'])
 
     def test_rust_target(self):
@@ -1594,57 +1573,6 @@ class RustTest(BaseConfigureTest):
         ):
             self.assertEqual(self.get_rust_target(autoconf, building_with_gcc), rust)
 
-        # Arm special cases
-        self.assertEqual(
-            self.get_rust_target('arm-unknown-linux-androideabi',
-                                 arm_target=ReadOnlyNamespace(
-                                     arm_arch=7, fpu='neon', thumb2=True)),
-            'thumbv7neon-linux-androideabi')
-
-        self.assertEqual(
-            self.get_rust_target('arm-unknown-linux-androideabi',
-                                 version='1.32.0',
-                                 arm_target=ReadOnlyNamespace(
-                                     arm_arch=7, fpu='neon', thumb2=True)),
-            'armv7-linux-androideabi')
-
-        self.assertEqual(
-            self.get_rust_target('arm-unknown-linux-androideabi',
-                                 arm_target=ReadOnlyNamespace(
-                                     arm_arch=7, fpu='neon', thumb2=False)),
-            'armv7-linux-androideabi')
-
-        self.assertEqual(
-            self.get_rust_target('arm-unknown-linux-androideabi',
-                                 arm_target=ReadOnlyNamespace(
-                                     arm_arch=7, fpu='vfpv2', thumb2=True)),
-            'armv7-linux-androideabi')
-
-        self.assertEqual(
-            self.get_rust_target('armv7-unknown-linux-gnueabihf',
-                                 arm_target=ReadOnlyNamespace(
-                                     arm_arch=7, fpu='neon', thumb2=True)),
-            'thumbv7neon-unknown-linux-gnueabihf')
-
-        self.assertEqual(
-            self.get_rust_target('armv7-unknown-linux-gnueabihf',
-                                 version='1.32.0',
-                                 arm_target=ReadOnlyNamespace(
-                                     arm_arch=7, fpu='neon', thumb2=True)),
-            'armv7-unknown-linux-gnueabihf')
-
-        self.assertEqual(
-            self.get_rust_target('armv7-unknown-linux-gnueabihf',
-                                 arm_target=ReadOnlyNamespace(
-                                     arm_arch=7, fpu='neon', thumb2=False)),
-            'armv7-unknown-linux-gnueabihf')
-
-        self.assertEqual(
-            self.get_rust_target('armv7-unknown-linux-gnueabihf',
-                                 arm_target=ReadOnlyNamespace(
-                                     arm_arch=7, fpu='vfpv2', thumb2=True)),
-            'armv7-unknown-linux-gnueabihf')
-
 
 if __name__ == '__main__':
     main()
