diff --git a/browser/components/shell/nsGNOMEShellDBusHelper.cpp b/browser/components/shell/nsGNOMEShellDBusHelper.cpp
index 4d709fc..f63b371 100644
--- a/browser/components/shell/nsGNOMEShellDBusHelper.cpp
+++ b/browser/components/shell/nsGNOMEShellDBusHelper.cpp
@@ -255,14 +255,14 @@ static void ActivateResultID(
     RefPtr<nsGNOMEShellHistorySearchResult> aSearchResult,
     const char* aResultID, uint32_t aTimeStamp) {
   char* commandLine = nullptr;
-  int len;
+  int tmp;
 
   if (strncmp(aResultID, KEYWORD_SEARCH_STRING, KEYWORD_SEARCH_STRING_LEN) ==
       0) {
     const char* urlList[3] = {"unused", "--search",
                               aSearchResult->GetSearchTerm().get()};
     commandLine =
-        ConstructCommandLine(std::size(urlList), urlList, nullptr, &len);
+        ConstructCommandLine(std::size(urlList), urlList, nullptr, &tmp);
   } else {
     int keyIndex = atoi(aResultID);
     nsCOMPtr<nsINavHistoryResultNode> child;
@@ -280,12 +280,11 @@ static void ActivateResultID(
 
     const char* urlList[2] = {"unused", uri.get()};
     commandLine =
-        ConstructCommandLine(std::size(urlList), urlList, nullptr, &len);
+        ConstructCommandLine(std::size(urlList), urlList, nullptr, &tmp);
   }
 
   if (commandLine) {
-    aSearchResult->HandleCommandLine(mozilla::Span(commandLine, len),
-                                     aTimeStamp);
+    aSearchResult->HandleCommandLine(commandLine, aTimeStamp);
     free(commandLine);
   }
 }
@@ -335,12 +334,11 @@ static void DBusLaunchWithAllResults(
     urlList[urlListElements++] = strdup(aSearchResult->GetSearchTerm().get());
   }
 
-  int len;
+  int tmp;
   char* commandLine =
-      ConstructCommandLine(urlListElements, urlList, nullptr, &len);
+      ConstructCommandLine(urlListElements, urlList, nullptr, &tmp);
   if (commandLine) {
-    aSearchResult->HandleCommandLine(mozilla::Span(commandLine, len),
-                                     aTimeStamp);
+    aSearchResult->HandleCommandLine(commandLine, aTimeStamp);
     free(commandLine);
   }
 
diff --git a/browser/components/shell/nsGNOMEShellSearchProvider.h b/browser/components/shell/nsGNOMEShellSearchProvider.h
index 2a93ebc..9362028 100644
--- a/browser/components/shell/nsGNOMEShellSearchProvider.h
+++ b/browser/components/shell/nsGNOMEShellSearchProvider.h
@@ -12,7 +12,6 @@
 
 #include "mozilla/RefPtr.h"
 #include "mozilla/GRefPtr.h"
-#include "mozilla/Span.h"
 #include "nsINavHistoryService.h"
 #include "nsUnixRemoteServer.h"
 #include "nsString.h"
@@ -81,8 +80,7 @@ class nsGNOMEShellHistorySearchResult : public nsUnixRemoteServer {
   nsCOMPtr<nsINavHistoryContainerResultNode> GetSearchResultContainer() {
     return mHistResultContainer;
   }
-  void HandleCommandLine(mozilla::Span<const char> aBuffer,
-                         uint32_t aTimestamp) {
+  void HandleCommandLine(const char* aBuffer, uint32_t aTimestamp) {
     nsUnixRemoteServer::HandleCommandLine(aBuffer, aTimestamp);
   }
 
diff --git a/toolkit/components/remote/nsDBusRemoteServer.cpp b/toolkit/components/remote/nsDBusRemoteServer.cpp
index 4afb838..55e4506 100644
--- a/toolkit/components/remote/nsDBusRemoteServer.cpp
+++ b/toolkit/components/remote/nsDBusRemoteServer.cpp
@@ -38,7 +38,7 @@ static const char* introspect_template =
 
 bool nsDBusRemoteServer::HandleOpenURL(const gchar* aInterfaceName,
                                        const gchar* aMethodName,
-                                       Span<const gchar> aParam) {
+                                       const gchar* aParam) {
   nsPrintfCString ourInterfaceName("org.mozilla.%s", mAppName.get());
 
   if ((strcmp("OpenURL", aMethodName) != 0) ||
@@ -91,7 +91,7 @@ static void HandleMethodCall(GDBusConnection* aConnection, const gchar* aSender,
   }
 
   int ret = static_cast<nsDBusRemoteServer*>(aUserData)->HandleOpenURL(
-      aInterfaceName, aMethodName, mozilla::Span(commandLine, len));
+      aInterfaceName, aMethodName, commandLine);
   if (!ret) {
     g_dbus_method_invocation_return_error(
         aInvocation, G_DBUS_ERROR, G_DBUS_ERROR_NOT_SUPPORTED,
diff --git a/toolkit/components/remote/nsDBusRemoteServer.h b/toolkit/components/remote/nsDBusRemoteServer.h
index 91c30ee..7f248e3 100644
--- a/toolkit/components/remote/nsDBusRemoteServer.h
+++ b/toolkit/components/remote/nsDBusRemoteServer.h
@@ -11,7 +11,6 @@
 #include "nsRemoteServer.h"
 #include "nsUnixRemoteServer.h"
 #include "mozilla/DBusHelpers.h"
-#include "mozilla/Span.h"
 
 #include <gio/gio.h>
 #include "mozilla/RefPtr.h"
@@ -30,7 +29,7 @@ class nsDBusRemoteServer final : public nsRemoteServer,
   void OnNameLost(GDBusConnection* aConnection);
 
   bool HandleOpenURL(const gchar* aInterfaceName, const gchar* aMethodName,
-                     mozilla::Span<const gchar> aParam);
+                     const gchar* aParam);
 
  private:
   uint mDBusID = 0;
diff --git a/toolkit/components/remote/nsUnixRemoteServer.cpp b/toolkit/components/remote/nsUnixRemoteServer.cpp
index bf4a018..f26c90a 100644
--- a/toolkit/components/remote/nsUnixRemoteServer.cpp
+++ b/toolkit/components/remote/nsUnixRemoteServer.cpp
@@ -59,8 +59,8 @@ static bool FindExtensionParameterInCommand(const char* aParameterName,
   return true;
 }
 
-const char* nsUnixRemoteServer::HandleCommandLine(
-    mozilla::Span<const char> aBuffer, uint32_t aTimestamp) {
+const char* nsUnixRemoteServer::HandleCommandLine(const char* aBuffer,
+                                                  uint32_t aTimestamp) {
   nsCOMPtr<nsICommandLineRunner> cmdline(new nsCommandLine());
 
   // the commandline property is constructed as an array of int32_t
@@ -68,41 +68,24 @@ const char* nsUnixRemoteServer::HandleCommandLine(
   //
   // [argc][offsetargv0][offsetargv1...]<workingdir>\0<argv[0]>\0argv[1]...\0
   // (offset is from the beginning of the buffer)
-  if (aBuffer.size() < sizeof(uint32_t)) {
-    return "500 command not parseable";
-  }
 
-  uint32_t argc =
-      TO_LITTLE_ENDIAN32(*reinterpret_cast<const uint32_t*>(aBuffer.data()));
-  uint32_t offsetFilelist = ((argc + 1) * sizeof(uint32_t));
-  if (offsetFilelist >= aBuffer.size()) {
-    return "500 command not parseable";
-  }
-  const char* workingDir = aBuffer.data() + offsetFilelist;
+  int32_t argc = TO_LITTLE_ENDIAN32(*reinterpret_cast<const int32_t*>(aBuffer));
+  const char* wd = aBuffer + ((argc + 1) * sizeof(int32_t));
 
   nsCOMPtr<nsIFile> lf;
-  nsresult rv = NS_NewNativeLocalFile(nsDependentCString(workingDir), true,
-                                      getter_AddRefs(lf));
-  if (NS_FAILED(rv)) {
-    return "509 internal error";
-  }
-
-  const char** argv = (const char**)malloc(sizeof(char*) * argc);
-  if (!argv) {
-    return "509 internal error";
-  }
+  nsresult rv =
+      NS_NewNativeLocalFile(nsDependentCString(wd), true, getter_AddRefs(lf));
+  if (NS_FAILED(rv)) return "509 internal error";
 
-  const uint32_t* offset =
-      reinterpret_cast<const uint32_t*>(aBuffer.data()) + 1;
   nsAutoCString desktopStartupID;
 
-  for (unsigned int i = 0; i < argc; ++i) {
-    uint32_t argvOffset = TO_LITTLE_ENDIAN32(offset[i]);
-    if (argvOffset >= aBuffer.size()) {
-      return "500 command not parseable";
-    }
+  const char** argv = (const char**)malloc(sizeof(char*) * argc);
+  if (!argv) return "509 internal error";
+
+  const int32_t* offset = reinterpret_cast<const int32_t*>(aBuffer) + 1;
 
-    argv[i] = aBuffer.data() + argvOffset;
+  for (int i = 0; i < argc; ++i) {
+    argv[i] = aBuffer + TO_LITTLE_ENDIAN32(offset[i]);
 
     if (i == 0) {
       nsDependentCString cmd(argv[0]);
@@ -122,13 +105,9 @@ const char* nsUnixRemoteServer::HandleCommandLine(
 
   rv = cmdline->Run();
 
-  if (NS_ERROR_ABORT == rv) {
-    return "500 command not parseable";
-  }
+  if (NS_ERROR_ABORT == rv) return "500 command not parseable";
 
-  if (NS_FAILED(rv)) {
-    return "509 internal error";
-  }
+  if (NS_FAILED(rv)) return "509 internal error";
 
   return "200 executed command";
 }
diff --git a/toolkit/components/remote/nsUnixRemoteServer.h b/toolkit/components/remote/nsUnixRemoteServer.h
index b55c01e..a220f10 100644
--- a/toolkit/components/remote/nsUnixRemoteServer.h
+++ b/toolkit/components/remote/nsUnixRemoteServer.h
@@ -9,7 +9,6 @@
 #define __nsUnixRemoteServer_h__
 
 #include "nsStringFwd.h"
-#include "mozilla/Span.h"
 
 #ifdef IS_BIG_ENDIAN
 #  define TO_LITTLE_ENDIAN32(x)                               \
@@ -23,8 +22,7 @@ class nsUnixRemoteServer {
  protected:
   void SetStartupTokenOrTimestamp(const nsACString& aStartupToken,
                                   uint32_t aTimestamp);
-  const char* HandleCommandLine(mozilla::Span<const char> aBuffer,
-                                uint32_t aTimestamp);
+  const char* HandleCommandLine(const char* aBuffer, uint32_t aTimestamp);
 };
 
 #endif  // __nsGTKRemoteService_h__
