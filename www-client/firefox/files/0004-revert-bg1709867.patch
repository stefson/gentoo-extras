diff --git a/browser/components/resistfingerprinting/moz.build b/browser/components/resistfingerprinting/moz.build
index cdc8d2e..6d2266f 100644
--- a/browser/components/resistfingerprinting/moz.build
+++ b/browser/components/resistfingerprinting/moz.build
@@ -14,3 +14,7 @@ BROWSER_CHROME_MANIFESTS += [
 MOCHITEST_MANIFESTS += [
     "test/mochitest/mochitest.ini",
 ]
+
+MOCHITEST_CHROME_MANIFESTS += [
+    "test/chrome/chrome.ini",
+]
diff --git a/browser/components/resistfingerprinting/test/browser/browser.ini b/browser/components/resistfingerprinting/test/browser/browser.ini
index 29fa768..e879420 100644
--- a/browser/components/resistfingerprinting/test/browser/browser.ini
+++ b/browser/components/resistfingerprinting/test/browser/browser.ini
@@ -2,7 +2,6 @@
 prefs =
   # bug 1803611
   dom.window_position_size_properties_replaceable.enabled=false
-  privacy.resistFingerprinting.testing.setTZtoUTC=false
 tags = resistfingerprinting
 support-files =
   coop_header.sjs
diff --git a/browser/components/resistfingerprinting/test/browser/browser_timezone.js b/browser/components/resistfingerprinting/test/browser/browser_timezone.js
index 6d24618..5baa131 100644
--- a/browser/components/resistfingerprinting/test/browser/browser_timezone.js
+++ b/browser/components/resistfingerprinting/test/browser/browser_timezone.js
@@ -3,154 +3,58 @@
  *               UTC timezone after fingerprinting resistance is enabled.
  */
 
-async function verifySpoofed() {
-  ok(true, "Running on " + content.location.origin);
+add_setup(async function() {
+  await SpecialPowers.pushPrefEnv({
+    set: [["privacy.resistFingerprinting", true]],
+  });
+});
 
-  SpecialPowers.Cu.getJSTestingFunctions().setTimeZone("PST8PDT");
-  is(
-    Intl.DateTimeFormat("en-US").resolvedOptions().timeZone,
-    "PST8PDT",
-    "Default time zone should have changed"
+add_task(async function test_timezone() {
+  // Load a page and verify the timezone.
+  let tab = await BrowserTestUtils.openNewForegroundTab(
+    gBrowser,
+    TEST_PATH + "file_dummy.html"
   );
 
-  // Running in content:
-  function test() {
-    let date = new Date();
-    ok(
-      date.toString().endsWith("(Coordinated Universal Time)"),
-      "The date toString() is in UTC timezone."
-    );
+  await SpecialPowers.spawn(tab.linkedBrowser, [], async function() {
+    let dateObj = new Date();
+    let dateString = dateObj.toString();
+
     ok(
-      date.toTimeString().endsWith("(Coordinated Universal Time)"),
-      "The date toTimeString() is in UTC timezone."
+      dateString.endsWith("(Coordinated Universal Time)"),
+      "The date string is in UTC timezone."
     );
-    let dateTimeFormat = Intl.DateTimeFormat("en-US", {
-      dateStyle: "full",
-      timeStyle: "full",
-    });
     is(
-      dateTimeFormat.resolvedOptions().timeZone,
-      "UTC",
-      "The Intl.DateTimeFormat is in UTC timezone."
-    );
-    ok(
-      dateTimeFormat.format(date).endsWith("Coordinated Universal Time"),
-      "The Intl.DateTimeFormat is formatting with the UTC timezone."
+      dateObj.getFullYear(),
+      dateObj.getUTCFullYear(),
+      "The full year reports in UTC timezone."
     );
     is(
-      date.getFullYear(),
-      date.getUTCFullYear(),
-      "The full year reports in UTC timezone."
+      dateObj.getMonth(),
+      dateObj.getUTCMonth(),
+      "The month reports in UTC timezone."
     );
     is(
-      date.getMonth(),
-      date.getUTCMonth(),
+      dateObj.getDate(),
+      dateObj.getUTCDate(),
       "The month reports in UTC timezone."
     );
-    is(date.getDate(), date.getUTCDate(), "The month reports in UTC timezone.");
-    is(date.getDay(), date.getUTCDay(), "The day reports in UTC timezone.");
     is(
-      date.getHours(),
-      date.getUTCHours(),
+      dateObj.getDay(),
+      dateObj.getUTCDay(),
+      "The day reports in UTC timezone."
+    );
+    is(
+      dateObj.getHours(),
+      dateObj.getUTCHours(),
       "The hours reports in UTC timezone."
     );
-    is(date.getTimezoneOffset(), 0, "The difference with UTC timezone is 0.");
-  }
-
-  // Run test in the context of the page.
-  Cu.exportFunction(is, content, { defineAs: "is" });
-  Cu.exportFunction(ok, content, { defineAs: "ok" });
-  content.eval(`(${test})()`);
-}
-
-add_task(async function test_timezone() {
-  await SpecialPowers.pushPrefEnv({
-    set: [["privacy.resistFingerprinting", true]],
-  });
-
-  // Load a page and verify the timezone.
-  let tab = await BrowserTestUtils.openNewForegroundTab({
-    gBrowser,
-    opening: TEST_PATH + "file_dummy.html",
-    forceNewProcess: true,
-  });
-
-  await SpecialPowers.spawn(tab.linkedBrowser, [], verifySpoofed);
-
-  BrowserTestUtils.removeTab(tab);
-
-  await SpecialPowers.popPrefEnv();
-});
-
-// Verify that exempted domain is not spoofed.
-add_task(async function test_timezone_exempt() {
-  await SpecialPowers.pushPrefEnv({
-    set: [
-      ["privacy.resistFingerprinting.testGranularityMask", 0x4],
-      ["privacy.resistFingerprinting.exemptedDomains", "example.net"],
-      ["privacy.resistFingerprinting", true],
-    ],
-  });
-
-  let tab = await BrowserTestUtils.openNewForegroundTab({
-    gBrowser,
-    opening: TEST_PATH + "file_dummy.html",
-    forceNewProcess: true,
-  });
-
-  await SpecialPowers.spawn(tab.linkedBrowser, [], async function() {
-    SpecialPowers.Cu.getJSTestingFunctions().setTimeZone("PST8PDT");
     is(
-      Intl.DateTimeFormat("en-US").resolvedOptions().timeZone,
-      "PST8PDT",
-      "Default time zone should have changed"
+      dateObj.getTimezoneOffset(),
+      0,
+      "The difference with UTC timezone is 0."
     );
-
-    function test() {
-      let date = new Date(0);
-      ok(
-        date.toString().endsWith("(Pacific Standard Time)"),
-        "The date toString() is in PT timezone"
-      );
-
-      is(
-        Intl.DateTimeFormat("en-US").resolvedOptions().timeZone,
-        "PST8PDT",
-        "Content should use default time zone"
-      );
-    }
-
-    // Run test in the context of the page.
-    Cu.exportFunction(is, content, { defineAs: "is" });
-    Cu.exportFunction(ok, content, { defineAs: "ok" });
-    content.eval(`(${test})()`);
-  });
-
-  BrowserTestUtils.removeTab(tab);
-
-  await SpecialPowers.popPrefEnv();
-});
-
-// Verify that we are still spoofing for domains not `exemptedDomains` list.
-add_task(async function test_timezone_exempt_wrong_domain() {
-  await SpecialPowers.pushPrefEnv({
-    set: [
-      ["privacy.resistFingerprinting.testGranularityMask", 0x4],
-      ["privacy.resistFingerprinting.exemptedDomains", "example.net"],
-      ["privacy.resistFingerprinting", true],
-    ],
   });
 
-  let tab = await BrowserTestUtils.openNewForegroundTab({
-    gBrowser,
-    opening:
-      TEST_PATH.replace("example.net", "example.org") + "file_dummy.html",
-    forceNewProcess: true,
-  });
-
-  await SpecialPowers.spawn(tab.linkedBrowser, [], verifySpoofed);
-
   BrowserTestUtils.removeTab(tab);
-
-  await SpecialPowers.popPrefEnv();
 });
diff --git a/browser/components/resistfingerprinting/test/browser/file_dummy.html b/browser/components/resistfingerprinting/test/browser/file_dummy.html
index 000a9a9..1a87e28 100644
--- a/browser/components/resistfingerprinting/test/browser/file_dummy.html
+++ b/browser/components/resistfingerprinting/test/browser/file_dummy.html
@@ -1,4 +1,3 @@
-<!DOCTYPE html>
 <html>
 <head>
 <title>Dummy test page</title>
diff --git a/browser/components/resistfingerprinting/test/chrome/chrome.ini b/browser/components/resistfingerprinting/test/chrome/chrome.ini
new file mode 100644
index 0000000..e177136
--- /dev/null
+++ b/browser/components/resistfingerprinting/test/chrome/chrome.ini
@@ -0,0 +1 @@
+[test_bug1409973_date_time_format.html]
diff --git a/browser/components/resistfingerprinting/test/chrome/test_bug1409973_date_time_format.html b/browser/components/resistfingerprinting/test/chrome/test_bug1409973_date_time_format.html
new file mode 100644
index 0000000..a507b65
--- /dev/null
+++ b/browser/components/resistfingerprinting/test/chrome/test_bug1409973_date_time_format.html
@@ -0,0 +1,62 @@
+<!DOCTYPE html>
+<meta charset="utf-8">
+<script src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+<script>
+  /* globals SpecialPowers, SimpleTest */
+  SimpleTest.waitForExplicitFinish();
+
+  const originalAvailable = Services.locale.availableLocales;
+  const originalRequested = Services.locale.requestedLocales;
+  Services.locale.availableLocales = ["ko-KR"];
+  Services.locale.requestedLocales = ["ko-KR"];
+
+  // First be sure we have a non-UTC timezone and a non en-US locale.
+  var setTimeZone = SpecialPowers.Cu.getJSTestingFunctions().setTimeZone;
+  setTimeZone("EST5EDT");
+  // Now sanity check the defaults
+  let date = new Date(2003, 4, 6, 2, 30, 15);
+  // These tests should pass, but we don't enable them because every time CLDR data changed,
+  // the test would start failing. We leave them here for future debugging.
+  // SimpleTest.is(date.toLocaleString(), "2003. 5. 6. 오전 2:30:15", "Sanity Check of toLocaleString");
+  // SimpleTest.is(date.toString(), "Tue May 06 2003 02:30:15 GMT-0400 (EDT)", "Sanity check of control timezone failed.");
+
+  let defaultOptions = new Intl.DateTimeFormat(undefined, {
+    month: "numeric", day: "numeric", year: "numeric", hour: "numeric", minute: "numeric", second: "numeric",
+    timeZoneName: "long",
+  }).resolvedOptions();
+  SimpleTest.is(defaultOptions.locale, "ko-KR", "defaultOptions Intl.DateTimeFormat.format.locale");
+  SimpleTest.is(defaultOptions.timeZone, "EST5EDT", "defaultOptions Intl.DateTimeFormat.format.timeZone");
+  SimpleTest.is(defaultOptions.timeZoneName, "long", "defaultOptions Intl.DateTimeFormat.format.timeZoneName");
+
+  // Then create output it as UTC en-US date string; which should be constant
+  const referenceLocaleString = date.toLocaleString("en-US", {timeZone: "UTC", timeZoneName: "long"});
+  let sanityCheck = new Intl.DateTimeFormat("en-us", {timeZone: "UTC", timeZoneName: "long"}).resolvedOptions();
+  SimpleTest.is(sanityCheck.locale, "en-US", "Sanity Check of Intl.DateTimeFormat.format.locale");
+  SimpleTest.is(sanityCheck.timeZone, "UTC", "Sanity Check of Intl.DateTimeFormat.format.timeZone");
+  SimpleTest.is(sanityCheck.timeZoneName, "long", "Sanity Check of Intl.DateTimeFormat.format.timeZoneName");
+
+  // Set preferences.
+  SpecialPowers.pushPrefEnv({
+    set: [
+      ["privacy.resistFingerprinting", true],
+      // In real world, this will be set if the user decides to spoof preferred languages by en-US.
+      ["javascript.use_us_english_locale", true],
+    ],
+  }, function() {
+    // Now confirm that calling toLocaleString with no arguements gives us UTC
+    SimpleTest.is(date.toLocaleString(undefined, {timeZoneName: "long"}), referenceLocaleString, "Date.toLocaleString");
+    // And that a no-options Intl.DateTimeFormat formatter looks correct too
+    let options = new Intl.DateTimeFormat(undefined, {
+      month: "numeric", day: "numeric", year: "numeric", hour: "numeric", minute: "numeric", second: "numeric",
+      timeZoneName: "long",
+    }).resolvedOptions();
+    SimpleTest.is(options.locale, "en-US", "Resist Fingerprinting Intl.DateTimeFormat.format.locale");
+    SimpleTest.is(options.timeZone, "UTC", "Resist Fingerprinting Intl.DateTimeFormat.format.timeZone");
+    SimpleTest.is(options.timeZoneName, "long", "Resist Fingerprinting Intl.DateTimeFormat.format.timeZoneName");
+
+    // Cleanup
+    Services.locale.requestedLocales = originalRequested;
+    Services.locale.availableLocales = originalAvailable;
+    SimpleTest.finish();
+  });
+</script>
diff --git a/intl/components/src/TimeZone.h b/intl/components/src/TimeZone.h
index 2439e44..180092b 100644
--- a/intl/components/src/TimeZone.h
+++ b/intl/components/src/TimeZone.h
@@ -106,7 +106,23 @@ class TimeZone final {
     mTimeZone->getDisplayName(static_cast<bool>(aDaylightSavings),
                               icu::TimeZone::LONG, icu::Locale(aLocale),
                               displayName);
-    return FillBuffer(displayName, aBuffer);
+
+    int32_t length = displayName.length();
+    if (!aBuffer.reserve(AssertedCast<size_t>(length))) {
+      return Err(ICUError::OutOfMemory);
+    }
+
+    // Copy the display name.
+    UErrorCode status = U_ZERO_ERROR;
+    int32_t written = displayName.extract(aBuffer.data(), length, status);
+    if (!ICUSuccessForStringSpan(status)) {
+      return Err(ToICUError(status));
+    }
+    MOZ_ASSERT(written == length);
+
+    aBuffer.written(written);
+
+    return Ok{};
 #else
     return FillBufferWithICUCall(
         aBuffer, [&](UChar* target, int32_t length, UErrorCode* status) {
@@ -118,23 +134,6 @@ class TimeZone final {
 #endif
   }
 
-  /**
-   * Return the identifier for this time zone.
-   */
-  template <typename B>
-  ICUResult GetId(B& aBuffer) {
-#if MOZ_INTL_USE_ICU_CPP_TIMEZONE
-    icu::UnicodeString id;
-    mTimeZone->getID(id);
-    return FillBuffer(id, aBuffer);
-#else
-    return FillBufferWithICUCall(
-        aBuffer, [&](UChar* target, int32_t length, UErrorCode* status) {
-          return ucal_getTimeZoneID(mCalendar, target, length, status);
-        });
-#endif
-  }
-
   /**
    * Fill the buffer with the system's default IANA time zone identifier, e.g.
    * "America/Chicago".
@@ -226,25 +225,6 @@ class TimeZone final {
   static Result<SpanEnumeration<char>, ICUError> GetAvailableTimeZones();
 
  private:
-  template <typename B>
-  static ICUResult FillBuffer(const icu::UnicodeString& aString, B& aBuffer) {
-    int32_t length = aString.length();
-    if (!aBuffer.reserve(AssertedCast<size_t>(length))) {
-      return Err(ICUError::OutOfMemory);
-    }
-
-    UErrorCode status = U_ZERO_ERROR;
-    int32_t written = aString.extract(aBuffer.data(), length, status);
-    if (!ICUSuccessForStringSpan(status)) {
-      return Err(ToICUError(status));
-    }
-    MOZ_ASSERT(written == length);
-
-    aBuffer.written(written);
-
-    return Ok{};
-  }
-
 #if MOZ_INTL_USE_ICU_CPP_TIMEZONE
   UniquePtr<icu::TimeZone> mTimeZone = nullptr;
 #else
diff --git a/js/src/builtin/TestingFunctions.cpp b/js/src/builtin/TestingFunctions.cpp
index 1bb1c6b..5a7774f 100644
--- a/js/src/builtin/TestingFunctions.cpp
+++ b/js/src/builtin/TestingFunctions.cpp
@@ -107,7 +107,6 @@
 #include "util/Text.h"
 #include "vm/BooleanObject.h"
 #include "vm/DateObject.h"
-#include "vm/DateTime.h"
 #include "vm/ErrorObject.h"
 #include "vm/GlobalObject.h"
 #include "vm/HelperThreads.h"
@@ -7960,8 +7959,7 @@ static bool GetICUOptions(JSContext* cx, unsigned argc, Value* vp) {
 
   intl::FormatBuffer<char16_t, intl::INITIAL_CHAR_BUFFER_SIZE> buf(cx);
 
-  if (auto ok = DateTimeInfo::timeZoneId(DateTimeInfo::ShouldRFP::No, buf);
-      ok.isErr()) {
+  if (auto ok = mozilla::intl::TimeZone::GetDefaultTimeZone(buf); ok.isErr()) {
     intl::ReportInternalError(cx, ok.unwrapErr());
     return false;
   }
diff --git a/js/src/builtin/intl/DateTimeFormat.cpp b/js/src/builtin/intl/DateTimeFormat.cpp
index 8327a47..bb5f259 100644
--- a/js/src/builtin/intl/DateTimeFormat.cpp
+++ b/js/src/builtin/intl/DateTimeFormat.cpp
@@ -402,9 +402,13 @@ bool js::intl_defaultTimeZone(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
   MOZ_ASSERT(args.length() == 0);
 
+  // The current default might be stale, because JS::ResetTimeZone() doesn't
+  // immediately update ICU's default time zone. So perform an update if
+  // needed.
+  js::ResyncICUDefaultTimeZone();
+
   FormatBuffer<char16_t, intl::INITIAL_CHAR_BUFFER_SIZE> timeZone(cx);
-  auto result =
-      DateTimeInfo::timeZoneId(DateTimeInfo::shouldRFP(cx->realm()), timeZone);
+  auto result = mozilla::intl::TimeZone::GetDefaultTimeZone(timeZone);
   if (result.isErr()) {
     intl::ReportInternalError(cx, result.unwrapErr());
     return false;
@@ -423,8 +427,13 @@ bool js::intl_defaultTimeZoneOffset(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
   MOZ_ASSERT(args.length() == 0);
 
-  auto offset =
-      DateTimeInfo::getRawOffsetMs(DateTimeInfo::shouldRFP(cx->realm()));
+  auto timeZone = mozilla::intl::TimeZone::TryCreate();
+  if (timeZone.isErr()) {
+    intl::ReportInternalError(cx, timeZone.unwrapErr());
+    return false;
+  }
+
+  auto offset = timeZone.unwrap()->GetRawOffsetMs();
   if (offset.isErr()) {
     intl::ReportInternalError(cx, offset.unwrapErr());
     return false;
@@ -446,9 +455,13 @@ bool js::intl_isDefaultTimeZone(JSContext* cx, unsigned argc, Value* vp) {
     return true;
   }
 
+  // The current default might be stale, because JS::ResetTimeZone() doesn't
+  // immediately update ICU's default time zone. So perform an update if
+  // needed.
+  js::ResyncICUDefaultTimeZone();
+
   FormatBuffer<char16_t, intl::INITIAL_CHAR_BUFFER_SIZE> chars(cx);
-  auto result =
-      DateTimeInfo::timeZoneId(DateTimeInfo::shouldRFP(cx->realm()), chars);
+  auto result = mozilla::intl::TimeZone::GetDefaultTimeZone(chars);
   if (result.isErr()) {
     intl::ReportInternalError(cx, result.unwrapErr());
     return false;
diff --git a/js/src/jit-test/tests/resist-fingerprinting/timezone.js b/js/src/jit-test/tests/resist-fingerprinting/timezone.js
deleted file mode 100644
index 64e6f86..0000000
--- a/js/src/jit-test/tests/resist-fingerprinting/timezone.js
+++ /dev/null
@@ -1,33 +0,0 @@
-// |jit-test| tz-pacific; skip-if: typeof Intl === 'undefined'
-
-let tzRE = /\(([^\)]+)\)/;
-
-// Make sure we aren't already running with UTC
-let original = new Date(0);
-assertEq(tzRE.exec(original.toString())[1], "Pacific Standard Time");
-
-let originalDT = Intl.DateTimeFormat("en-US", {
-  dateStyle: "full",
-  timeStyle: "full",
-});
-assertEq(originalDT.format(original).endsWith("Pacific Standard Time"), true);
-assertEq(originalDT.resolvedOptions().timeZone, "PST8PDT");
-
-let global = newGlobal({shouldResistFingerprinting: true});
-
-let date = new global.Date();
-assertEq(tzRE.exec(date.toString())[1], "Coordinated Universal Time");
-assertEq(tzRE.exec(date.toTimeString())[1], "Coordinated Universal Time");
-assertEq(date.getFullYear(), date.getUTCFullYear());
-assertEq(date.getMonth(), date.getUTCMonth());
-assertEq(date.getDate(), date.getUTCDate());
-assertEq(date.getDay(), date.getUTCDay());
-assertEq(date.getHours(),date.getUTCHours());
-assertEq(date.getTimezoneOffset(), 0);
-
-let dt = global.Intl.DateTimeFormat("en-US", {
-  dateStyle: "full",
-  timeStyle: "full",
-});
-assertEq(dt.format(date).endsWith("Coordinated Universal Time"), true);
-assertEq(dt.resolvedOptions().timeZone, "UTC");
diff --git a/js/src/jsdate.cpp b/js/src/jsdate.cpp
index fd4542e..2183cbb 100644
--- a/js/src/jsdate.cpp
+++ b/js/src/jsdate.cpp
@@ -140,38 +140,28 @@ namespace {
 class DateTimeHelper {
  private:
 #if JS_HAS_INTL_API
-  static double localTZA(DateTimeInfo::ShouldRFP shouldRFP, double t,
-                         DateTimeInfo::TimeZoneOffset offset);
+  static double localTZA(double t, DateTimeInfo::TimeZoneOffset offset);
 #else
   static int equivalentYearForDST(int year);
   static bool isRepresentableAsTime32(double t);
-  static double daylightSavingTA(DateTimeInfo::ShouldRFP shouldRFP, double t);
-  static double adjustTime(DateTimeInfo::ShouldRFP shouldRFP, double date);
-  static PRMJTime toPRMJTime(DateTimeInfo::ShouldRFP shouldRFP,
-                             double localTime, double utcTime);
+  static double daylightSavingTA(double t);
+  static double adjustTime(double date);
+  static PRMJTime toPRMJTime(double localTime, double utcTime);
 #endif
 
  public:
-  static double localTime(DateTimeInfo::ShouldRFP shouldRFP, double t);
-  static double UTC(DateTimeInfo::ShouldRFP shouldRFP, double t);
-  static JSString* timeZoneComment(JSContext* cx,
-                                   DateTimeInfo::ShouldRFP shouldRFP,
-                                   double utcTime, double localTime);
+  static double localTime(double t);
+  static double UTC(double t);
+  static JSString* timeZoneComment(JSContext* cx, double utcTime,
+                                   double localTime);
 #if !JS_HAS_INTL_API
-  static size_t formatTime(DateTimeInfo::ShouldRFP shouldRFP, char* buf,
-                           size_t buflen, const char* fmt, double utcTime,
-                           double localTime);
+  static size_t formatTime(char* buf, size_t buflen, const char* fmt,
+                           double utcTime, double localTime);
 #endif
 };
 
 }  // namespace
 
-static DateTimeInfo::ShouldRFP ShouldRFP(const Realm* realm) {
-  return realm->behaviors().shouldResistFingerprinting()
-             ? DateTimeInfo::ShouldRFP::Yes
-             : DateTimeInfo::ShouldRFP::No;
-}
-
 // ES2019 draft rev 0ceb728a1adbffe42b26972a6541fd7f398b1557
 // 5.2.5 Mathematical Operations
 static inline double PositiveModulo(double dividend, double divisor) {
@@ -462,30 +452,29 @@ JS_PUBLIC_API void JS::SetTimeResolutionUsec(uint32_t resolution, bool jitter) {
 #if JS_HAS_INTL_API
 // ES2019 draft rev 0ceb728a1adbffe42b26972a6541fd7f398b1557
 // 20.3.1.7 LocalTZA ( t, isUTC )
-double DateTimeHelper::localTZA(DateTimeInfo::ShouldRFP shouldRFP, double t,
-                                DateTimeInfo::TimeZoneOffset offset) {
+double DateTimeHelper::localTZA(double t, DateTimeInfo::TimeZoneOffset offset) {
   MOZ_ASSERT(IsFinite(t));
 
   int64_t milliseconds = static_cast<int64_t>(t);
   int32_t offsetMilliseconds =
-      DateTimeInfo::getOffsetMilliseconds(shouldRFP, milliseconds, offset);
+      DateTimeInfo::getOffsetMilliseconds(milliseconds, offset);
   return static_cast<double>(offsetMilliseconds);
 }
 
 // ES2019 draft rev 0ceb728a1adbffe42b26972a6541fd7f398b1557
 // 20.3.1.8 LocalTime ( t )
-double DateTimeHelper::localTime(DateTimeInfo::ShouldRFP shouldRFP, double t) {
+double DateTimeHelper::localTime(double t) {
   if (!IsFinite(t)) {
     return GenericNaN();
   }
 
   MOZ_ASSERT(StartOfTime <= t && t <= EndOfTime);
-  return t + localTZA(shouldRFP, t, DateTimeInfo::TimeZoneOffset::UTC);
+  return t + localTZA(t, DateTimeInfo::TimeZoneOffset::UTC);
 }
 
 // ES2019 draft rev 0ceb728a1adbffe42b26972a6541fd7f398b1557
 // 20.3.1.9 UTC ( t )
-double DateTimeHelper::UTC(DateTimeInfo::ShouldRFP shouldRFP, double t) {
+double DateTimeHelper::UTC(double t) {
   if (!IsFinite(t)) {
     return GenericNaN();
   }
@@ -494,7 +483,7 @@ double DateTimeHelper::UTC(DateTimeInfo::ShouldRFP shouldRFP, double t) {
     return GenericNaN();
   }
 
-  return t - localTZA(shouldRFP, t, DateTimeInfo::TimeZoneOffset::Local);
+  return t - localTZA(t, DateTimeInfo::TimeZoneOffset::Local);
 }
 #else
 /*
@@ -541,8 +530,7 @@ bool DateTimeHelper::isRepresentableAsTime32(double t) {
 }
 
 /* ES5 15.9.1.8. */
-double DateTimeHelper::daylightSavingTA(DateTimeInfo::ShouldRFP shouldRFP,
-                                        double t) {
+double DateTimeHelper::daylightSavingTA(double t) {
   if (!IsFinite(t)) {
     return GenericNaN();
   }
@@ -559,24 +547,21 @@ double DateTimeHelper::daylightSavingTA(DateTimeInfo::ShouldRFP shouldRFP,
 
   int64_t utcMilliseconds = static_cast<int64_t>(t);
   int32_t offsetMilliseconds =
-      DateTimeInfo::getDSTOffsetMilliseconds(shouldRFP, utcMilliseconds);
+      DateTimeInfo::getDSTOffsetMilliseconds(utcMilliseconds);
   return static_cast<double>(offsetMilliseconds);
 }
 
-double DateTimeHelper::adjustTime(DateTimeInfo::ShouldRFP shouldRFP,
-                                  double date) {
-  double localTZA = DateTimeInfo::localTZA(shouldRFP);
-  double t = daylightSavingTA(shouldRFP, date) + localTZA;
+double DateTimeHelper::adjustTime(double date) {
+  double localTZA = DateTimeInfo::localTZA();
+  double t = daylightSavingTA(date) + localTZA;
   t = (localTZA >= 0) ? fmod(t, msPerDay) : -fmod(msPerDay - t, msPerDay);
   return t;
 }
 
 /* ES5 15.9.1.9. */
-double DateTimeHelper::localTime(DateTimeInfo::ShouldRFP shouldRFP, double t) {
-  return t + adjustTime(shouldRFP, t);
-}
+double DateTimeHelper::localTime(double t) { return t + adjustTime(t); }
 
-double DateTimeHelper::UTC(DateTimeInfo::ShouldRFP shouldRFP, double t) {
+double DateTimeHelper::UTC(double t) {
   // Following the ES2017 specification creates undesirable results at DST
   // transitions. For example when transitioning from PST to PDT,
   // |new Date(2016,2,13,2,0,0).toTimeString()| returns the string value
@@ -584,18 +569,13 @@ double DateTimeHelper::UTC(DateTimeInfo::ShouldRFP shouldRFP, double t) {
   // V8 and subtract one hour before computing the offset.
   // Spec bug: https://bugs.ecmascript.org/show_bug.cgi?id=4007
 
-  return t - adjustTime(shouldRFP,
-                        t - DateTimeInfo::localTZA(shouldRFP) - msPerHour);
+  return t - adjustTime(t - DateTimeInfo::localTZA() - msPerHour);
 }
 #endif /* JS_HAS_INTL_API */
 
-static double LocalTime(DateTimeInfo::ShouldRFP shouldRFP, double t) {
-  return DateTimeHelper::localTime(shouldRFP, t);
-}
+static double LocalTime(double t) { return DateTimeHelper::localTime(t); }
 
-static double UTC(DateTimeInfo::ShouldRFP shouldRFP, double t) {
-  return DateTimeHelper::UTC(shouldRFP, t);
-}
+static double UTC(double t) { return DateTimeHelper::UTC(t); }
 
 /* ES5 15.9.1.10. */
 static double HourFromTime(double t) {
@@ -884,8 +864,8 @@ static int DaysInMonth(int year, int month) {
  *   TZD  = time zone designator (Z or +hh:mm or -hh:mm or missing for local)
  */
 template <typename CharT>
-static bool ParseISOStyleDate(DateTimeInfo::ShouldRFP shouldRFP, const CharT* s,
-                              size_t length, ClippedTime* result) {
+static bool ParseISOStyleDate(const CharT* s, size_t length,
+                              ClippedTime* result) {
   size_t i = 0;
   size_t pre = 0;
   int tzMul = 1;
@@ -1034,7 +1014,7 @@ done:
                          MakeTime(hour, min, sec, frac * 1000.0));
 
   if (isLocalTime) {
-    msec = UTC(shouldRFP, msec);
+    msec = UTC(msec);
   } else {
     msec -= tzMul * (tzHour * msPerHour + tzMin * msPerMinute);
   }
@@ -1105,9 +1085,8 @@ constexpr size_t MinKeywordLength(const CharsAndAction (&keywords)[N]) {
 }
 
 template <typename CharT>
-static bool ParseDate(DateTimeInfo::ShouldRFP shouldRFP, const CharT* s,
-                      size_t length, ClippedTime* result) {
-  if (ParseISOStyleDate(shouldRFP, s, length, result)) {
+static bool ParseDate(const CharT* s, size_t length, ClippedTime* result) {
+  if (ParseISOStyleDate(s, length, result)) {
     return true;
   }
 
@@ -1506,7 +1485,7 @@ static bool ParseDate(DateTimeInfo::ShouldRFP shouldRFP, const CharT* s,
   double msec = MakeDate(MakeDay(year, mon, mday), MakeTime(hour, min, sec, 0));
 
   if (tzOffset == -1) { /* no time zone specified, have to use local */
-    msec = UTC(shouldRFP, msec);
+    msec = UTC(msec);
   } else {
     msec += tzOffset * msPerMinute;
   }
@@ -1515,12 +1494,11 @@ static bool ParseDate(DateTimeInfo::ShouldRFP shouldRFP, const CharT* s,
   return true;
 }
 
-static bool ParseDate(DateTimeInfo::ShouldRFP shouldRFP, JSLinearString* s,
-                      ClippedTime* result) {
+static bool ParseDate(JSLinearString* s, ClippedTime* result) {
   AutoCheckCannotGC nogc;
   return s->hasLatin1Chars()
-             ? ParseDate(shouldRFP, s->latin1Chars(nogc), s->length(), result)
-             : ParseDate(shouldRFP, s->twoByteChars(nogc), s->length(), result);
+             ? ParseDate(s->latin1Chars(nogc), s->length(), result)
+             : ParseDate(s->twoByteChars(nogc), s->length(), result);
 }
 
 static bool date_parse(JSContext* cx, unsigned argc, Value* vp) {
@@ -1542,7 +1520,7 @@ static bool date_parse(JSContext* cx, unsigned argc, Value* vp) {
   }
 
   ClippedTime result;
-  if (!ParseDate(ShouldRFP(cx->realm()), linearStr, &result)) {
+  if (!ParseDate(linearStr, &result)) {
     args.rval().setNaN();
     return true;
   }
@@ -1606,10 +1584,6 @@ bool js::date_now(JSContext* cx, unsigned argc, Value* vp) {
   return true;
 }
 
-DateTimeInfo::ShouldRFP DateObject::shouldRFP() const {
-  return ShouldRFP(realm());
-}
-
 void DateObject::setUTCTime(ClippedTime t) {
   for (size_t ind = COMPONENTS_START_SLOT; ind < RESERVED_SLOTS; ind++) {
     setReservedSlot(ind, UndefinedValue());
@@ -1624,8 +1598,7 @@ void DateObject::setUTCTime(ClippedTime t, MutableHandleValue vp) {
 }
 
 void DateObject::fillLocalTimeSlots() {
-  const int32_t utcTZOffset =
-      DateTimeInfo::utcToLocalStandardOffsetSeconds(shouldRFP());
+  const int32_t utcTZOffset = DateTimeInfo::utcToLocalStandardOffsetSeconds();
 
   /* Check if the cache is already populated. */
   if (!getReservedSlot(LOCAL_TIME_SLOT).isUndefined() &&
@@ -1645,7 +1618,7 @@ void DateObject::fillLocalTimeSlots() {
     return;
   }
 
-  double localTime = LocalTime(shouldRFP(), utcTime);
+  double localTime = LocalTime(utcTime);
 
   setReservedSlot(LOCAL_TIME_SLOT, DoubleValue(localTime));
 
@@ -1747,6 +1720,11 @@ void DateObject::fillLocalTimeSlots() {
   setReservedSlot(LOCAL_SECONDS_INTO_YEAR_SLOT, Int32Value(yearSeconds));
 }
 
+inline double DateObject::cachedLocalTime() {
+  fillLocalTimeSlots();
+  return getReservedSlot(LOCAL_TIME_SLOT).toDouble();
+}
+
 MOZ_ALWAYS_INLINE bool IsDate(HandleValue v) {
   return v.isObject() && v.toObject().is<DateObject>();
 }
@@ -2073,10 +2051,8 @@ static bool date_getTimezoneOffset(JSContext* cx, unsigned argc, Value* vp) {
     return false;
   }
 
-  unwrapped->fillLocalTimeSlots();
-
   double utctime = unwrapped->UTCTime().toNumber();
-  double localtime = unwrapped->localTime().toDouble();
+  double localtime = unwrapped->cachedLocalTime();
 
   /*
    * Return the time zone offset in minutes for the current locale that is
@@ -2148,7 +2124,7 @@ static bool date_setMilliseconds(JSContext* cx, unsigned argc, Value* vp) {
   if (!unwrapped) {
     return false;
   }
-  double t = LocalTime(unwrapped->shouldRFP(), unwrapped->UTCTime().toNumber());
+  double t = LocalTime(unwrapped->UTCTime().toNumber());
 
   // Step 2.
   double ms;
@@ -2160,7 +2136,7 @@ static bool date_setMilliseconds(JSContext* cx, unsigned argc, Value* vp) {
   double time = MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ms);
 
   // Step 4.
-  ClippedTime u = TimeClip(UTC(unwrapped->shouldRFP(), MakeDate(Day(t), time)));
+  ClippedTime u = TimeClip(UTC(MakeDate(Day(t), time)));
 
   // Steps 5-6.
   unwrapped->setUTCTime(u, args.rval());
@@ -2207,7 +2183,7 @@ static bool date_setSeconds(JSContext* cx, unsigned argc, Value* vp) {
   }
 
   // Steps 1-2.
-  double t = LocalTime(unwrapped->shouldRFP(), unwrapped->UTCTime().toNumber());
+  double t = LocalTime(unwrapped->UTCTime().toNumber());
 
   // Steps 3-4.
   double s;
@@ -2226,7 +2202,7 @@ static bool date_setSeconds(JSContext* cx, unsigned argc, Value* vp) {
       MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli));
 
   // Step 8.
-  ClippedTime u = TimeClip(UTC(unwrapped->shouldRFP(), date));
+  ClippedTime u = TimeClip(UTC(date));
 
   // Step 9.
   unwrapped->setUTCTime(u, args.rval());
@@ -2281,7 +2257,7 @@ static bool date_setMinutes(JSContext* cx, unsigned argc, Value* vp) {
   }
 
   // Steps 1-2.
-  double t = LocalTime(unwrapped->shouldRFP(), unwrapped->UTCTime().toNumber());
+  double t = LocalTime(unwrapped->UTCTime().toNumber());
 
   // Steps 3-4.
   double m;
@@ -2305,7 +2281,7 @@ static bool date_setMinutes(JSContext* cx, unsigned argc, Value* vp) {
   double date = MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli));
 
   // Step 10.
-  ClippedTime u = TimeClip(UTC(unwrapped->shouldRFP(), date));
+  ClippedTime u = TimeClip(UTC(date));
 
   // Steps 11-12.
   unwrapped->setUTCTime(u, args.rval());
@@ -2365,7 +2341,7 @@ static bool date_setHours(JSContext* cx, unsigned argc, Value* vp) {
   }
 
   // Steps 1-2.
-  double t = LocalTime(unwrapped->shouldRFP(), unwrapped->UTCTime().toNumber());
+  double t = LocalTime(unwrapped->UTCTime().toNumber());
 
   // Steps 3-4.
   double h;
@@ -2395,7 +2371,7 @@ static bool date_setHours(JSContext* cx, unsigned argc, Value* vp) {
   double date = MakeDate(Day(t), MakeTime(h, m, s, milli));
 
   // Step 12.
-  ClippedTime u = TimeClip(UTC(unwrapped->shouldRFP(), date));
+  ClippedTime u = TimeClip(UTC(date));
 
   // Steps 13-14.
   unwrapped->setUTCTime(u, args.rval());
@@ -2461,7 +2437,7 @@ static bool date_setDate(JSContext* cx, unsigned argc, Value* vp) {
   }
 
   /* Step 1. */
-  double t = LocalTime(unwrapped->shouldRFP(), unwrapped->UTCTime().toNumber());
+  double t = LocalTime(unwrapped->UTCTime().toNumber());
 
   /* Step 2. */
   double date;
@@ -2474,7 +2450,7 @@ static bool date_setDate(JSContext* cx, unsigned argc, Value* vp) {
                             TimeWithinDay(t));
 
   /* Step 4. */
-  ClippedTime u = TimeClip(UTC(unwrapped->shouldRFP(), newDate));
+  ClippedTime u = TimeClip(UTC(newDate));
 
   /* Steps 5-6. */
   unwrapped->setUTCTime(u, args.rval());
@@ -2540,7 +2516,7 @@ static bool date_setMonth(JSContext* cx, unsigned argc, Value* vp) {
   }
 
   /* Step 1. */
-  double t = LocalTime(unwrapped->shouldRFP(), unwrapped->UTCTime().toNumber());
+  double t = LocalTime(unwrapped->UTCTime().toNumber());
 
   /* Step 2. */
   double m;
@@ -2559,7 +2535,7 @@ static bool date_setMonth(JSContext* cx, unsigned argc, Value* vp) {
       MakeDate(MakeDay(YearFromTime(t), m, date), TimeWithinDay(t));
 
   /* Step 5. */
-  ClippedTime u = TimeClip(UTC(unwrapped->shouldRFP(), newDate));
+  ClippedTime u = TimeClip(UTC(newDate));
 
   /* Steps 6-7. */
   unwrapped->setUTCTime(u, args.rval());
@@ -2603,13 +2579,12 @@ static bool date_setUTCMonth(JSContext* cx, unsigned argc, Value* vp) {
   return true;
 }
 
-static double ThisLocalTimeOrZero(DateTimeInfo::ShouldRFP shouldRFP,
-                                  Handle<DateObject*> dateObj) {
+static double ThisLocalTimeOrZero(Handle<DateObject*> dateObj) {
   double t = dateObj->UTCTime().toNumber();
   if (IsNaN(t)) {
     return +0;
   }
-  return LocalTime(shouldRFP, t);
+  return LocalTime(t);
 }
 
 static double ThisUTCTimeOrZero(Handle<DateObject*> dateObj) {
@@ -2628,7 +2603,7 @@ static bool date_setFullYear(JSContext* cx, unsigned argc, Value* vp) {
   }
 
   /* Step 1. */
-  double t = ThisLocalTimeOrZero(unwrapped->shouldRFP(), unwrapped);
+  double t = ThisLocalTimeOrZero(unwrapped);
 
   /* Step 2. */
   double y;
@@ -2652,7 +2627,7 @@ static bool date_setFullYear(JSContext* cx, unsigned argc, Value* vp) {
   double newDate = MakeDate(MakeDay(y, m, date), TimeWithinDay(t));
 
   /* Step 6. */
-  ClippedTime u = TimeClip(UTC(unwrapped->shouldRFP(), newDate));
+  ClippedTime u = TimeClip(UTC(newDate));
 
   /* Steps 7-8. */
   unwrapped->setUTCTime(u, args.rval());
@@ -2712,7 +2687,7 @@ static bool date_setYear(JSContext* cx, unsigned argc, Value* vp) {
   }
 
   /* Step 1. */
-  double t = ThisLocalTimeOrZero(unwrapped->shouldRFP(), unwrapped);
+  double t = ThisLocalTimeOrZero(unwrapped);
 
   /* Step 2. */
   double y;
@@ -2736,7 +2711,7 @@ static bool date_setYear(JSContext* cx, unsigned argc, Value* vp) {
   double day = MakeDay(yint, MonthFromTime(t), DateFromTime(t));
 
   /* Step 6. */
-  double u = UTC(unwrapped->shouldRFP(), MakeDate(day, TimeWithinDay(t)));
+  double u = UTC(MakeDate(day, TimeWithinDay(t)));
 
   /* Steps 7-8. */
   unwrapped->setUTCTime(TimeClip(u), args.rval());
@@ -2863,9 +2838,8 @@ static bool date_toJSON(JSContext* cx, unsigned argc, Value* vp) {
 }
 
 #if JS_HAS_INTL_API
-JSString* DateTimeHelper::timeZoneComment(JSContext* cx,
-                                          DateTimeInfo::ShouldRFP shouldRFP,
-                                          double utcTime, double localTime) {
+JSString* DateTimeHelper::timeZoneComment(JSContext* cx, double utcTime,
+                                          double localTime) {
   const char* locale = cx->runtime()->getDefaultLocale();
   if (!locale) {
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
@@ -2882,9 +2856,9 @@ JSString* DateTimeHelper::timeZoneComment(JSContext* cx,
       std::size(tzbuf) - 2 - 1;  // for the trailing ')'
 
   int64_t utcMilliseconds = static_cast<int64_t>(utcTime);
-  if (!DateTimeInfo::timeZoneDisplayName(
-          shouldRFP, timeZoneStart, remainingSpace, utcMilliseconds, locale)) {
-    JS_ReportOutOfMemory(cx);
+  if (!DateTimeInfo::timeZoneDisplayName(timeZoneStart, remainingSpace,
+                                         utcMilliseconds, locale)) {
+    { JS_ReportOutOfMemory(cx); }
     return nullptr;
   }
 
@@ -2901,8 +2875,7 @@ JSString* DateTimeHelper::timeZoneComment(JSContext* cx,
 }
 #else
 /* Interface to PRMJTime date struct. */
-PRMJTime DateTimeHelper::toPRMJTime(DateTimeInfo::ShouldRFP shouldRFP,
-                                    double localTime, double utcTime) {
+PRMJTime DateTimeHelper::toPRMJTime(double localTime, double utcTime) {
   double year = YearFromTime(localTime);
 
   PRMJTime prtm;
@@ -2915,15 +2888,14 @@ PRMJTime DateTimeHelper::toPRMJTime(DateTimeInfo::ShouldRFP shouldRFP,
   prtm.tm_wday = int8_t(WeekDay(localTime));
   prtm.tm_year = year;
   prtm.tm_yday = int16_t(DayWithinYear(localTime, year));
-  prtm.tm_isdst = (daylightSavingTA(shouldRFP, utcTime) != 0);
+  prtm.tm_isdst = (daylightSavingTA(utcTime) != 0);
 
   return prtm;
 }
 
-size_t DateTimeHelper::formatTime(DateTimeInfo::ShouldRFP shouldRFP, char* buf,
-                                  size_t buflen, const char* fmt,
+size_t DateTimeHelper::formatTime(char* buf, size_t buflen, const char* fmt,
                                   double utcTime, double localTime) {
-  PRMJTime prtm = toPRMJTime(shouldRFP, localTime, utcTime);
+  PRMJTime prtm = toPRMJTime(localTime, utcTime);
 
   // If an equivalent year was used to compute the date/time components, use
   // the same equivalent year to determine the time zone name and offset in
@@ -2937,13 +2909,11 @@ size_t DateTimeHelper::formatTime(DateTimeInfo::ShouldRFP shouldRFP, char* buf,
                          offsetInSeconds);
 }
 
-JSString* DateTimeHelper::timeZoneComment(JSContext* cx,
-                                          DateTimeInfo::ShouldRFP shouldRFP,
-                                          double utcTime, double localTime) {
+JSString* DateTimeHelper::timeZoneComment(JSContext* cx, double utcTime,
+                                          double localTime) {
   char tzbuf[100];
 
-  size_t tzlen =
-      formatTime(shouldRFP, tzbuf, sizeof tzbuf, " (%Z)", utcTime, localTime);
+  size_t tzlen = formatTime(tzbuf, sizeof tzbuf, " (%Z)", utcTime, localTime);
   if (tzlen != 0) {
     // Decide whether to use the resulting time zone string.
     //
@@ -2973,10 +2943,14 @@ JSString* DateTimeHelper::timeZoneComment(JSContext* cx,
 }
 #endif /* JS_HAS_INTL_API */
 
+static JSString* TimeZoneComment(JSContext* cx, double utcTime,
+                                 double localTime) {
+  return DateTimeHelper::timeZoneComment(cx, utcTime, localTime);
+}
+
 enum class FormatSpec { DateTime, Date, Time };
 
-static bool FormatDate(JSContext* cx, DateTimeInfo::ShouldRFP shouldRFP,
-                       double utcTime, FormatSpec format,
+static bool FormatDate(JSContext* cx, double utcTime, FormatSpec format,
                        MutableHandleValue rval) {
   if (!IsFinite(utcTime)) {
     rval.setString(cx->names().InvalidDate);
@@ -2985,7 +2959,7 @@ static bool FormatDate(JSContext* cx, DateTimeInfo::ShouldRFP shouldRFP,
 
   MOZ_ASSERT(NumbersAreIdentical(TimeClip(utcTime).toDouble(), utcTime));
 
-  double localTime = LocalTime(shouldRFP, utcTime);
+  double localTime = LocalTime(utcTime);
 
   int offset = 0;
   RootedString timeZoneComment(cx);
@@ -3012,8 +2986,7 @@ static bool FormatDate(JSContext* cx, DateTimeInfo::ShouldRFP shouldRFP,
     // also means the time zone string may not fit into Latin-1.
 
     // Get a time zone string from the OS or ICU to include as a comment.
-    timeZoneComment =
-        DateTimeHelper::timeZoneComment(cx, shouldRFP, utcTime, localTime);
+    timeZoneComment = TimeZoneComment(cx, utcTime, localTime);
     if (!timeZoneComment) {
       return false;
     }
@@ -3063,23 +3036,21 @@ static bool FormatDate(JSContext* cx, DateTimeInfo::ShouldRFP shouldRFP,
 }
 
 #if !JS_HAS_INTL_API
-static bool ToLocaleFormatHelper(JSContext* cx,
-                                 DateTimeInfo::ShouldRFP shouldRFP,
-                                 double utcTime, const char* format,
-                                 MutableHandleValue rval) {
+static bool ToLocaleFormatHelper(JSContext* cx, double utcTime,
+                                 const char* format, MutableHandleValue rval) {
   char buf[100];
   if (!IsFinite(utcTime)) {
     strcpy(buf, js_InvalidDate_str);
   } else {
-    double localTime = LocalTime(shouldRFP, utcTime);
+    double localTime = LocalTime(utcTime);
 
     /* Let PRMJTime format it. */
-    size_t result_len = DateTimeHelper::formatTime(shouldRFP, buf, sizeof buf,
-                                                   format, utcTime, localTime);
+    size_t result_len =
+        DateTimeHelper::formatTime(buf, sizeof buf, format, utcTime, localTime);
 
     /* If it failed, default to toString. */
     if (result_len == 0) {
-      return FormatDate(cx, shouldRFP, utcTime, FormatSpec::DateTime, rval);
+      return FormatDate(cx, utcTime, FormatSpec::DateTime, rval);
     }
 
     /* Hacked check against undesired 2-digit year 00/00/00 form. */
@@ -3134,8 +3105,7 @@ static bool date_toLocaleString(JSContext* cx, unsigned argc, Value* vp) {
 #  endif
       ;
 
-  return ToLocaleFormatHelper(cx, unwrapped->shouldRFP(),
-                              unwrapped->UTCTime().toNumber(), format,
+  return ToLocaleFormatHelper(cx, unwrapped->UTCTime().toNumber(), format,
                               args.rval());
 }
 
@@ -3162,8 +3132,7 @@ static bool date_toLocaleDateString(JSContext* cx, unsigned argc, Value* vp) {
 #  endif
       ;
 
-  return ToLocaleFormatHelper(cx, unwrapped->shouldRFP(),
-                              unwrapped->UTCTime().toNumber(), format,
+  return ToLocaleFormatHelper(cx, unwrapped->UTCTime().toNumber(), format,
                               args.rval());
 }
 
@@ -3178,8 +3147,7 @@ static bool date_toLocaleTimeString(JSContext* cx, unsigned argc, Value* vp) {
     return false;
   }
 
-  return ToLocaleFormatHelper(cx, unwrapped->shouldRFP(),
-                              unwrapped->UTCTime().toNumber(), "%X",
+  return ToLocaleFormatHelper(cx, unwrapped->UTCTime().toNumber(), "%X",
                               args.rval());
 }
 #endif /* !JS_HAS_INTL_API */
@@ -3194,8 +3162,8 @@ static bool date_toTimeString(JSContext* cx, unsigned argc, Value* vp) {
     return false;
   }
 
-  return FormatDate(cx, unwrapped->shouldRFP(), unwrapped->UTCTime().toNumber(),
-                    FormatSpec::Time, args.rval());
+  return FormatDate(cx, unwrapped->UTCTime().toNumber(), FormatSpec::Time,
+                    args.rval());
 }
 
 static bool date_toDateString(JSContext* cx, unsigned argc, Value* vp) {
@@ -3208,8 +3176,8 @@ static bool date_toDateString(JSContext* cx, unsigned argc, Value* vp) {
     return false;
   }
 
-  return FormatDate(cx, unwrapped->shouldRFP(), unwrapped->UTCTime().toNumber(),
-                    FormatSpec::Date, args.rval());
+  return FormatDate(cx, unwrapped->UTCTime().toNumber(), FormatSpec::Date,
+                    args.rval());
 }
 
 static bool date_toSource(JSContext* cx, unsigned argc, Value* vp) {
@@ -3245,8 +3213,8 @@ bool date_toString(JSContext* cx, unsigned argc, Value* vp) {
     return false;
   }
 
-  return FormatDate(cx, unwrapped->shouldRFP(), unwrapped->UTCTime().toNumber(),
-                    FormatSpec::DateTime, args.rval());
+  return FormatDate(cx, unwrapped->UTCTime().toNumber(), FormatSpec::DateTime,
+                    args.rval());
 }
 
 bool js::date_valueOf(JSContext* cx, unsigned argc, Value* vp) {
@@ -3363,8 +3331,7 @@ static bool NewDateObject(JSContext* cx, const CallArgs& args, ClippedTime t) {
 }
 
 static bool ToDateString(JSContext* cx, const CallArgs& args, ClippedTime t) {
-  return FormatDate(cx, ShouldRFP(cx->realm()), t.toDouble(),
-                    FormatSpec::DateTime, args.rval());
+  return FormatDate(cx, t.toDouble(), FormatSpec::DateTime, args.rval());
 }
 
 static bool DateNoArguments(JSContext* cx, const CallArgs& args) {
@@ -3412,7 +3379,7 @@ static bool DateOneArgument(JSContext* cx, const CallArgs& args) {
         return false;
       }
 
-      if (!ParseDate(ShouldRFP(cx->realm()), linearStr, &t)) {
+      if (!ParseDate(linearStr, &t)) {
         t = ClippedTime::invalid();
       }
     } else {
@@ -3509,8 +3476,7 @@ static bool DateMultipleArguments(JSContext* cx, const CallArgs& args) {
     double finalDate = MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli));
 
     // Steps 3q-t.
-    return NewDateObject(cx, args,
-                         TimeClip(UTC(ShouldRFP(cx->realm()), finalDate)));
+    return NewDateObject(cx, args, TimeClip(UTC(finalDate)));
   }
 
   return ToDateString(cx, args, NowAsMillis(cx));
@@ -3586,8 +3552,7 @@ JS_PUBLIC_API JSObject* js::NewDateObject(JSContext* cx, int year, int mon,
   MOZ_ASSERT(mon < 12);
   double msec_time =
       MakeDate(MakeDay(year, mon, mday), MakeTime(hour, min, sec, 0.0));
-  return NewDateObjectMsec(cx,
-                           TimeClip(UTC(ShouldRFP(cx->realm()), msec_time)));
+  return NewDateObjectMsec(cx, TimeClip(UTC(msec_time)));
 }
 
 JS_PUBLIC_API bool js::DateIsValid(JSContext* cx, HandleObject obj,
diff --git a/js/src/shell/js.cpp b/js/src/shell/js.cpp
index f14695a..57cce97 100644
--- a/js/src/shell/js.cpp
+++ b/js/src/shell/js.cpp
@@ -6707,13 +6707,6 @@ static bool NewGlobal(JSContext* cx, unsigned argc, Value* vp) {
     if (v.isBoolean()) {
       creationOptions.setDefineSharedArrayBufferConstructor(v.toBoolean());
     }
-
-    if (!JS_GetProperty(cx, opts, "shouldResistFingerprinting", &v)) {
-      return false;
-    }
-    if (v.isBoolean()) {
-      behaviors.setShouldResistFingerprinting(v.toBoolean());
-    }
   }
 
   if (!CheckRealmOptions(cx, options, principals.get())) {
diff --git a/js/src/vm/DateObject.h b/js/src/vm/DateObject.h
index 48ee893..560acaa 100644
--- a/js/src/vm/DateObject.h
+++ b/js/src/vm/DateObject.h
@@ -9,7 +9,6 @@
 
 #include "js/Date.h"
 #include "js/Value.h"
-#include "vm/DateTime.h"
 #include "vm/NativeObject.h"
 
 namespace js {
@@ -57,8 +56,6 @@ class DateObject : public NativeObject {
   static const JSClass class_;
   static const JSClass protoClass_;
 
-  js::DateTimeInfo::ShouldRFP shouldRFP() const;
-
   JS::ClippedTime clippedTime() const {
     double t = getFixedSlot(UTC_TIME_SLOT).toDouble();
     JS::ClippedTime clipped = JS::TimeClip(t);
@@ -67,14 +64,13 @@ class DateObject : public NativeObject {
   }
 
   const js::Value& UTCTime() const { return getFixedSlot(UTC_TIME_SLOT); }
-  const js::Value& localTime() const {
-    return getReservedSlot(LOCAL_TIME_SLOT);
-  }
 
   // Set UTC time to a given time and invalidate cached local time.
   void setUTCTime(JS::ClippedTime t);
   void setUTCTime(JS::ClippedTime t, MutableHandleValue vp);
 
+  inline double cachedLocalTime();
+
   // Cache the local time, year, month, and so forth of the object.
   // If UTC time is not finite (e.g., NaN), the local time
   // slots will be set to the UTC time without conversion.
diff --git a/js/src/vm/DateTime.cpp b/js/src/vm/DateTime.cpp
index 0dd93e0..cb3d128 100644
--- a/js/src/vm/DateTime.cpp
+++ b/js/src/vm/DateTime.cpp
@@ -35,14 +35,6 @@
 
 #include "util/Text.h"
 #include "vm/MutexIDs.h"
-#include "vm/Realm.h"
-
-/* static */
-js::DateTimeInfo::ShouldRFP js::DateTimeInfo::shouldRFP(JS::Realm* realm) {
-  return realm->behaviors().shouldResistFingerprinting()
-             ? DateTimeInfo::ShouldRFP::Yes
-             : DateTimeInfo::ShouldRFP::No;
-}
 
 static bool ComputeLocalTime(time_t local, struct tm* ptm) {
   // Neither localtime_s nor localtime_r are required to act as if tzset has
@@ -233,8 +225,7 @@ void js::DateTimeInfo::updateTimeZone() {
   }
 }
 
-js::DateTimeInfo::DateTimeInfo(bool shouldResistFingerprinting)
-    : shouldResistFingerprinting_(shouldResistFingerprinting) {
+js::DateTimeInfo::DateTimeInfo() {
   // Set the time zone status into the invalid state, so we compute the actual
   // defaults on first access. We don't yet want to initialize neither <ctime>
   // nor ICU's time zone classes, because that may cause I/O operations slowing
@@ -484,17 +475,11 @@ bool js::DateTimeInfo::internalTimeZoneDisplayName(char16_t* buf, size_t buflen,
 
 mozilla::intl::TimeZone* js::DateTimeInfo::timeZone() {
   if (!timeZone_) {
-    // For resist finger printing mode we always use the UTC time zone.
-    mozilla::Maybe<mozilla::Span<const char16_t>> timeZoneOverride;
-    if (shouldResistFingerprinting_) {
-      timeZoneOverride = mozilla::Some(mozilla::MakeStringSpan(u"UTC"));
-    }
-
-    auto timeZone = mozilla::intl::TimeZone::TryCreate(timeZoneOverride);
+    auto timeZone = mozilla::intl::TimeZone::TryCreate();
 
-    // Creating the default or UTC time zone should never fail. If it should
-    // fail nonetheless for some reason, just crash because we don't have a way
-    // to propagate any errors.
+    // Creating the default time zone should never fail. If it should fail
+    // nonetheless for some reason, just crash because we don't have a way to
+    // propagate any errors.
     MOZ_RELEASE_ASSERT(timeZone.isOk());
 
     timeZone_ = timeZone.unwrap();
@@ -506,17 +491,13 @@ mozilla::intl::TimeZone* js::DateTimeInfo::timeZone() {
 #endif /* JS_HAS_INTL_API */
 
 /* static */ js::ExclusiveData<js::DateTimeInfo>* js::DateTimeInfo::instance;
-/* static */ js::ExclusiveData<js::DateTimeInfo>* js::DateTimeInfo::instanceRFP;
 
 bool js::InitDateTimeState() {
-  MOZ_ASSERT(!DateTimeInfo::instance && !DateTimeInfo::instanceRFP,
-             "we should be initializing only once");
+  MOZ_ASSERT(!DateTimeInfo::instance, "we should be initializing only once");
 
   DateTimeInfo::instance =
-      js_new<ExclusiveData<DateTimeInfo>>(mutexid::DateTimeInfoMutex, false);
-  DateTimeInfo::instanceRFP =
-      js_new<ExclusiveData<DateTimeInfo>>(mutexid::DateTimeInfoMutex, true);
-  return DateTimeInfo::instance && DateTimeInfo::instanceRFP;
+      js_new<ExclusiveData<DateTimeInfo>>(mutexid::DateTimeInfoMutex);
+  return !!DateTimeInfo::instance;
 }
 
 /* static */
@@ -748,17 +729,12 @@ static bool ReadTimeZoneLink(std::string_view tz,
 #  endif /* defined(XP_WIN) */
 #endif   /* JS_HAS_INTL_API */
 
+void js::ResyncICUDefaultTimeZone() {
+  js::DateTimeInfo::resyncICUDefaultTimeZone();
+}
+
 void js::DateTimeInfo::internalResyncICUDefaultTimeZone() {
 #if JS_HAS_INTL_API
-  // In the future we should not be setting a default ICU time zone at all,
-  // instead all accesses should go through the appropriate DateTimeInfo
-  // instance depending on the resist fingerprinting status. For now we return
-  // early to prevent overwriting the default time zone with the UTC time zone
-  // used by RFP.
-  if (shouldResistFingerprinting_) {
-    return;
-  }
-
   if (const char* tzenv = std::getenv("TZ")) {
     std::string_view tz(tzenv);
 
diff --git a/js/src/vm/DateTime.h b/js/src/vm/DateTime.h
index 20feae3..b70e4e0 100644
--- a/js/src/vm/DateTime.h
+++ b/js/src/vm/DateTime.h
@@ -15,13 +15,10 @@
 #include "threading/ExclusiveData.h"
 
 #if JS_HAS_INTL_API
-#  include "mozilla/intl/ICU4CGlue.h"
-#  include "mozilla/intl/TimeZone.h"
-#endif
-
-namespace JS {
-class Realm;
+namespace mozilla::intl {
+class TimeZone;
 }
+#endif
 
 namespace js {
 
@@ -65,6 +62,15 @@ enum class ResetTimeZoneMode : bool {
  */
 extern void ResetTimeZoneInternal(ResetTimeZoneMode mode);
 
+/**
+ * ICU's default time zone, used for various date/time formatting operations
+ * that include the local time in the representation, is allowed to go stale
+ * for unfortunate performance reasons.  Call this function when an up-to-date
+ * default time zone is required, to resync ICU's default time zone with
+ * reality.
+ */
+extern void ResyncICUDefaultTimeZone();
+
 /**
  * Stores date/time information, particularly concerning the current local
  * time zone, and implements a small cache for daylight saving time offset
@@ -112,26 +118,17 @@ extern void ResetTimeZoneInternal(ResetTimeZoneMode mode);
  * potential win from better caching offsets the loss from extra complexity.)
  */
 class DateTimeInfo {
- public:
-  // Whether we should resist fingerprinting. For realms in RFP mode a separate
-  // DateTimeInfo instance is used that is always in the UTC time zone.
-  enum class ShouldRFP { No, Yes };
-
- private:
   static ExclusiveData<DateTimeInfo>* instance;
-  static ExclusiveData<DateTimeInfo>* instanceRFP;
-
   friend class ExclusiveData<DateTimeInfo>;
 
   friend bool InitDateTimeState();
   friend void FinishDateTimeState();
 
-  explicit DateTimeInfo(bool shouldResistFingerprinting);
+  DateTimeInfo();
   ~DateTimeInfo();
 
-  static auto acquireLockWithValidTimeZone(ShouldRFP shouldRFP) {
-    auto guard =
-        shouldRFP == ShouldRFP::Yes ? instanceRFP->lock() : instance->lock();
+  static auto acquireLockWithValidTimeZone() {
+    auto guard = instance->lock();
     if (guard->timeZoneStatus_ != TimeZoneStatus::Valid) {
       guard->updateTimeZone();
     }
@@ -139,8 +136,6 @@ class DateTimeInfo {
   }
 
  public:
-  static ShouldRFP shouldRFP(JS::Realm* realm);
-
   // The spec implicitly assumes DST and time zone adjustment information
   // never change in the course of a function -- sometimes even across
   // reentrancy.  So make critical sections as narrow as possible.
@@ -151,9 +146,8 @@ class DateTimeInfo {
    * zone (Lord Howe Island, Australia) has a fractional-hour offset, just to
    * keep things interesting.
    */
-  static int32_t getDSTOffsetMilliseconds(ShouldRFP shouldRFP,
-                                          int64_t utcMilliseconds) {
-    auto guard = acquireLockWithValidTimeZone(shouldRFP);
+  static int32_t getDSTOffsetMilliseconds(int64_t utcMilliseconds) {
+    auto guard = acquireLockWithValidTimeZone();
     return guard->internalGetDSTOffsetMilliseconds(utcMilliseconds);
   }
 
@@ -162,8 +156,8 @@ class DateTimeInfo {
    * standard time (i.e. not including any offset due to DST) as computed by the
    * operating system.
    */
-  static int32_t utcToLocalStandardOffsetSeconds(ShouldRFP shouldRFP) {
-    auto guard = acquireLockWithValidTimeZone(shouldRFP);
+  static int32_t utcToLocalStandardOffsetSeconds() {
+    auto guard = acquireLockWithValidTimeZone();
     return guard->utcToLocalStandardOffsetSeconds_;
   }
 
@@ -174,10 +168,9 @@ class DateTimeInfo {
    * Return the time zone offset, including DST, in milliseconds at the
    * given time. The input time can be either at UTC or at local time.
    */
-  static int32_t getOffsetMilliseconds(ShouldRFP shouldRFP,
-                                       int64_t milliseconds,
+  static int32_t getOffsetMilliseconds(int64_t milliseconds,
                                        TimeZoneOffset offset) {
-    auto guard = acquireLockWithValidTimeZone(shouldRFP);
+    auto guard = acquireLockWithValidTimeZone();
     return guard->internalGetOffsetMilliseconds(milliseconds, offset);
   }
 
@@ -187,57 +180,36 @@ class DateTimeInfo {
    * buffer is too small, an empty string is stored. The stored display name
    * is null-terminated in any case.
    */
-  static bool timeZoneDisplayName(ShouldRFP shouldRFP, char16_t* buf,
-                                  size_t buflen, int64_t utcMilliseconds,
-                                  const char* locale) {
-    auto guard = acquireLockWithValidTimeZone(shouldRFP);
+  static bool timeZoneDisplayName(char16_t* buf, size_t buflen,
+                                  int64_t utcMilliseconds, const char* locale) {
+    auto guard = acquireLockWithValidTimeZone();
     return guard->internalTimeZoneDisplayName(buf, buflen, utcMilliseconds,
                                               locale);
   }
-
-  /**
-   * Copy the identifier for the current time zone to the provided resizable
-   * buffer.
-   */
-  template <typename B>
-  static mozilla::intl::ICUResult timeZoneId(ShouldRFP shouldRFP, B& buffer) {
-    auto guard = acquireLockWithValidTimeZone(shouldRFP);
-    return guard->timeZone()->GetId(buffer);
-  }
-
-  /**
-   * A number indicating the raw offset from GMT in milliseconds.
-   */
-  static mozilla::Result<int32_t, mozilla::intl::ICUError> getRawOffsetMs(
-      ShouldRFP shouldRFP) {
-    auto guard = acquireLockWithValidTimeZone(shouldRFP);
-    return guard->timeZone()->GetRawOffsetMs();
-  }
 #else
   /**
    * Return the local time zone adjustment (ES2019 20.3.1.7) as computed by
    * the operating system.
    */
-  static int32_t localTZA(ShouldRFP shouldRFP) {
-    return utcToLocalStandardOffsetSeconds(shouldRFP) * msPerSecond;
+  static int32_t localTZA() {
+    return utcToLocalStandardOffsetSeconds() * msPerSecond;
   }
 #endif /* JS_HAS_INTL_API */
 
  private:
-  // The method below should only be called via js::ResetTimeZoneInternal().
+  // The two methods below should only be called via js::ResetTimeZoneInternal()
+  // and js::ResyncICUDefaultTimeZone().
   friend void js::ResetTimeZoneInternal(ResetTimeZoneMode);
+  friend void js::ResyncICUDefaultTimeZone();
 
   static void resetTimeZone(ResetTimeZoneMode mode) {
-    {
-      auto guard = instance->lock();
-      guard->internalResetTimeZone(mode);
-    }
-    {
-      // Only needed to initialize the default state and any later call will
-      // perform an unnecessary reset.
-      auto guard = instanceRFP->lock();
-      guard->internalResetTimeZone(mode);
-    }
+    auto guard = instance->lock();
+    guard->internalResetTimeZone(mode);
+  }
+
+  static void resyncICUDefaultTimeZone() {
+    auto guard = acquireLockWithValidTimeZone();
+    (void)guard;
   }
 
   struct RangeCache {
@@ -255,8 +227,6 @@ class DateTimeInfo {
     void sanityCheck();
   };
 
-  bool shouldResistFingerprinting_;
-
   enum class TimeZoneStatus : uint8_t { Valid, NeedsUpdate, UpdateIfChanged };
 
   TimeZoneStatus timeZoneStatus_;
diff --git a/modules/libpref/init/StaticPrefList.yaml b/modules/libpref/init/StaticPrefList.yaml
index 3b713a8..ad2ff51 100644
--- a/modules/libpref/init/StaticPrefList.yaml
+++ b/modules/libpref/init/StaticPrefList.yaml
@@ -12969,13 +12969,6 @@
   value: 480
   mirror: always
 
-# Setting TZ=UTC ensures that even libc functions use the spoofed time zone.
-# We want to remove that override as soon as possible however.
-- name: privacy.resistFingerprinting.testing.setTZtoUTC
-  type: bool
-  value: false
-  mirror: always
-
 # Bitfield for selectively disabling RFP
 #   0 for no new behavior
 #   1 for disabling RFP if it's a WebExtension
diff --git a/toolkit/components/resistfingerprinting/nsRFPService.cpp b/toolkit/components/resistfingerprinting/nsRFPService.cpp
index 939c8d1..8fdf3b8 100644
--- a/toolkit/components/resistfingerprinting/nsRFPService.cpp
+++ b/toolkit/components/resistfingerprinting/nsRFPService.cpp
@@ -691,13 +691,6 @@ void nsRFPService::UpdateRFPPref() {
       StaticPrefs::javascript_options_use_fdlibm_for_sin_cos_tan() ||
       resistFingerprinting);
 
-  // The JavaScript engine can already set the timezone per realm/global,
-  // but we think there are still other users of libc that rely
-  // on the TZ environment variable.
-  if (!StaticPrefs::privacy_resistFingerprinting_testing_setTZtoUTC()) {
-    return;
-  }
-
   if (resistFingerprinting) {
     PR_SetEnv("TZ=UTC");
   } else if (sInitialized) {
