# HG changeset patch
# User Paul Adenot <paul@paul.cx>
# Date 1563883411 0
# Node ID d4c682935239b7514c5cf9029aeea9aad808f118
# Parent  5002be0f931095921c8942832bba4cdb60337e56
Bug 1567457 - Vendor rust depencies: add ringbuf. r=kinetik

Differential Revision: https://phabricator.services.mozilla.com/D38662

diff --git a/Cargo.lock b/Cargo.lock
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -833,16 +833,17 @@ dependencies = [
 
 [[package]]
 name = "cubeb-pulse"
 version = "0.2.0"
 dependencies = [
  "cubeb-backend 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)",
  "pulse 0.2.0",
  "pulse-ffi 0.1.0",
+ "ringbuf 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
  "semver 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "cubeb-sys"
 version = "0.5.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
@@ -2575,16 +2576,24 @@ dependencies = [
 name = "remove_dir_all"
 version = "0.5.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "winapi 0.3.6 (git+https://github.com/froydnj/winapi-rs?branch=aarch64)",
 ]
 
 [[package]]
+name = "ringbuf"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
 name = "rkv"
 version = "0.9.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "arrayref 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)",
  "bincode 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
  "byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -4099,16 +4108,17 @@ dependencies = [
 "checksum redox_syscall 0.1.32 (registry+https://github.com/rust-lang/crates.io-index)" = "ab105df655884ede59d45b7070c8a65002d921461ee813a024558ca16030eea0"
 "checksum redox_termios 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "7e891cfe48e9100a70a3b6eb652fef28920c117d366339687bd5576160db0f76"
 "checksum redox_users 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "214a97e49be64fd2c86f568dd0cb2c757d2cc53de95b273b6ad0a1c908482f26"
 "checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b"
 "checksum regex 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "3d8c9f33201f46669484bacc312b00e7541bed6aaf296dffe2bb4e0ac6b8ce2a"
 "checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)" = "ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db"
 "checksum regex-syntax 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)" = "8f1ac0f60d675cc6cf13a20ec076568254472551051ad5dd050364d70671bf6b"
 "checksum remove_dir_all 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)" = "4a83fa3702a688b9359eccba92d153ac33fd2e8462f9e0e3fdf155239ea7792e"
+"checksum ringbuf 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)" = "588456c74d5ff0a5806bc084818e043e767533f743c11ee6f3ccf298599c6847"
 "checksum rkv 0.9.6 (registry+https://github.com/rust-lang/crates.io-index)" = "9ebeb7e046283b72b4bcd3b8ee4720cf69cd09f5b140b5ab46495df4af0e5113"
 "checksum ron 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "da06feaa07f69125ab9ddc769b11de29090122170b402547f64b86fe16ebc399"
 "checksum runloop 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "5d79b4b604167921892e84afbbaad9d5ad74e091bf6c511d9dbfb0593f09fabd"
 "checksum rust-ini 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)" = "8a654c5bda722c699be6b0fe4c0d90de218928da5b724c3e467fc48865c37263"
 "checksum rust_cascade 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)" = "f3fe4900d38dab1ad21a515e44687dd0711e6b0ec5b214a3b1aa8857343bcf3a"
 "checksum rustc-demangle 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)" = "76d7ba1feafada44f2d38eed812bd2489a03c0f5abb975799251518b68848649"
 "checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)" = "138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a"
 "checksum ryu 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)" = "fd0568787116e13c652377b6846f5931454a363a8fdf8ae50463ee40935b278b"
diff --git a/third_party/rust/ringbuf/.cargo-checksum.json b/third_party/rust/ringbuf/.cargo-checksum.json
new file mode 100644
--- /dev/null
+++ b/third_party/rust/ringbuf/.cargo-checksum.json
@@ -0,0 +1,1 @@
+{"files":{"Cargo.toml":"fe82627aa6b268b526c45ad1a2e2320d57167cbee204cfbe7487b4ebab770872","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"6683f8a2ba538c11948da65a5c0d03ba4a7c6bbbd430c77f950b477a67586729","README.md":"51611a7fae812f702c3a8c20008c1f88bb01c432471a4613cb4392243015ac61","appveyor.yml":"85506d783b88552efa9f919f222823dca7ccad6116f2423e75b9cc78300ade3a","build.rs":"76bee227ba6ee01931dda9304b835c0702bb016e6c2992a1fb17569983bbfee6","examples/message.rs":"fbefd281b4aac87a87ffd3cc24a6881db83fd73293c0ac23fdadda4c906a2509","examples/simple.rs":"1233ee173f2fea6a21156ed9ccf4bc2a2bc46fd63f8eeaa24ec3150c4b13f68b","src/benchmarks.rs":"134daa5852344f0514be86425147fbdf4d7468fef3c6297430fae69f20f405cf","src/lib.rs":"83e41f778e109d1d707484bd4d3919d3ac2da042034e6ec1aacc433bf0778c8b","src/tests.rs":"a3a738bae6c7c609b818db1534adf1b3fb9d52aaf1a65efa7880a5aa9870baf2"},"package":"588456c74d5ff0a5806bc084818e043e767533f743c11ee6f3ccf298599c6847"}
\ No newline at end of file
diff --git a/third_party/rust/ringbuf/Cargo.toml b/third_party/rust/ringbuf/Cargo.toml
new file mode 100644
--- /dev/null
+++ b/third_party/rust/ringbuf/Cargo.toml
@@ -0,0 +1,33 @@
+# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
+#
+# When uploading crates to the registry Cargo will automatically
+# "normalize" Cargo.toml files for maximal compatibility
+# with all versions of Cargo and also rewrite `path` dependencies
+# to registry (e.g. crates.io) dependencies
+#
+# If you believe there's an error in this file please file an
+# issue against the rust-lang/cargo repository. If you're
+# editing this file be aware that the upstream Cargo.toml
+# will likely look very different (and much more reasonable)
+
+[package]
+edition = "2018"
+name = "ringbuf"
+version = "0.1.4"
+authors = ["Alexey Gerasev <alexey.gerasev@gmail.com>"]
+build = "build.rs"
+description = "Lock-free SPSC FIFO ring buffer with direct access to inner data"
+homepage = "https://github.com/nthend/ringbuf"
+documentation = "https://docs.rs/ringbuf"
+readme = "README.md"
+keywords = ["lock-free", "spsc", "ring-buffer", "rb", "fifo"]
+categories = ["concurrency", "data-structures"]
+license = "MIT/Apache-2.0"
+repository = "https://github.com/nthend/ringbuf.git"
+
+[dependencies]
+[build-dependencies.rustc_version]
+version = "0.2"
+
+[features]
+default = []
diff --git a/third_party/rust/ringbuf/LICENSE-APACHE b/third_party/rust/ringbuf/LICENSE-APACHE
new file mode 100644
--- /dev/null
+++ b/third_party/rust/ringbuf/LICENSE-APACHE
@@ -0,0 +1,201 @@
+                              Apache License
+                        Version 2.0, January 2004
+                     http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+   "License" shall mean the terms and conditions for use, reproduction,
+   and distribution as defined by Sections 1 through 9 of this document.
+
+   "Licensor" shall mean the copyright owner or entity authorized by
+   the copyright owner that is granting the License.
+
+   "Legal Entity" shall mean the union of the acting entity and all
+   other entities that control, are controlled by, or are under common
+   control with that entity. For the purposes of this definition,
+   "control" means (i) the power, direct or indirect, to cause the
+   direction or management of such entity, whether by contract or
+   otherwise, or (ii) ownership of fifty percent (50%) or more of the
+   outstanding shares, or (iii) beneficial ownership of such entity.
+
+   "You" (or "Your") shall mean an individual or Legal Entity
+   exercising permissions granted by this License.
+
+   "Source" form shall mean the preferred form for making modifications,
+   including but not limited to software source code, documentation
+   source, and configuration files.
+
+   "Object" form shall mean any form resulting from mechanical
+   transformation or translation of a Source form, including but
+   not limited to compiled object code, generated documentation,
+   and conversions to other media types.
+
+   "Work" shall mean the work of authorship, whether in Source or
+   Object form, made available under the License, as indicated by a
+   copyright notice that is included in or attached to the work
+   (an example is provided in the Appendix below).
+
+   "Derivative Works" shall mean any work, whether in Source or Object
+   form, that is based on (or derived from) the Work and for which the
+   editorial revisions, annotations, elaborations, or other modifications
+   represent, as a whole, an original work of authorship. For the purposes
+   of this License, Derivative Works shall not include works that remain
+   separable from, or merely link (or bind by name) to the interfaces of,
+   the Work and Derivative Works thereof.
+
+   "Contribution" shall mean any work of authorship, including
+   the original version of the Work and any modifications or additions
+   to that Work or Derivative Works thereof, that is intentionally
+   submitted to Licensor for inclusion in the Work by the copyright owner
+   or by an individual or Legal Entity authorized to submit on behalf of
+   the copyright owner. For the purposes of this definition, "submitted"
+   means any form of electronic, verbal, or written communication sent
+   to the Licensor or its representatives, including but not limited to
+   communication on electronic mailing lists, source code control systems,
+   and issue tracking systems that are managed by, or on behalf of, the
+   Licensor for the purpose of discussing and improving the Work, but
+   excluding communication that is conspicuously marked or otherwise
+   designated in writing by the copyright owner as "Not a Contribution."
+
+   "Contributor" shall mean Licensor and any individual or Legal Entity
+   on behalf of whom a Contribution has been received by Licensor and
+   subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   copyright license to reproduce, prepare Derivative Works of,
+   publicly display, publicly perform, sublicense, and distribute the
+   Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   (except as stated in this section) patent license to make, have made,
+   use, offer to sell, sell, import, and otherwise transfer the Work,
+   where such license applies only to those patent claims licensable
+   by such Contributor that are necessarily infringed by their
+   Contribution(s) alone or by combination of their Contribution(s)
+   with the Work to which such Contribution(s) was submitted. If You
+   institute patent litigation against any entity (including a
+   cross-claim or counterclaim in a lawsuit) alleging that the Work
+   or a Contribution incorporated within the Work constitutes direct
+   or contributory patent infringement, then any patent licenses
+   granted to You under this License for that Work shall terminate
+   as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the
+   Work or Derivative Works thereof in any medium, with or without
+   modifications, and in Source or Object form, provided that You
+   meet the following conditions:
+
+   (a) You must give any other recipients of the Work or
+       Derivative Works a copy of this License; and
+
+   (b) You must cause any modified files to carry prominent notices
+       stating that You changed the files; and
+
+   (c) You must retain, in the Source form of any Derivative Works
+       that You distribute, all copyright, patent, trademark, and
+       attribution notices from the Source form of the Work,
+       excluding those notices that do not pertain to any part of
+       the Derivative Works; and
+
+   (d) If the Work includes a "NOTICE" text file as part of its
+       distribution, then any Derivative Works that You distribute must
+       include a readable copy of the attribution notices contained
+       within such NOTICE file, excluding those notices that do not
+       pertain to any part of the Derivative Works, in at least one
+       of the following places: within a NOTICE text file distributed
+       as part of the Derivative Works; within the Source form or
+       documentation, if provided along with the Derivative Works; or,
+       within a display generated by the Derivative Works, if and
+       wherever such third-party notices normally appear. The contents
+       of the NOTICE file are for informational purposes only and
+       do not modify the License. You may add Your own attribution
+       notices within Derivative Works that You distribute, alongside
+       or as an addendum to the NOTICE text from the Work, provided
+       that such additional attribution notices cannot be construed
+       as modifying the License.
+
+   You may add Your own copyright statement to Your modifications and
+   may provide additional or different license terms and conditions
+   for use, reproduction, or distribution of Your modifications, or
+   for any such Derivative Works as a whole, provided Your use,
+   reproduction, and distribution of the Work otherwise complies with
+   the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise,
+   any Contribution intentionally submitted for inclusion in the Work
+   by You to the Licensor shall be under the terms and conditions of
+   this License, without any additional terms or conditions.
+   Notwithstanding the above, nothing herein shall supersede or modify
+   the terms of any separate license agreement you may have executed
+   with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or
+   agreed to in writing, Licensor provides the Work (and each
+   Contributor provides its Contributions) on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+   implied, including, without limitation, any warranties or conditions
+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+   PARTICULAR PURPOSE. You are solely responsible for determining the
+   appropriateness of using or redistributing the Work and assume any
+   risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory,
+   whether in tort (including negligence), contract, or otherwise,
+   unless required by applicable law (such as deliberate and grossly
+   negligent acts) or agreed to in writing, shall any Contributor be
+   liable to You for damages, including any direct, indirect, special,
+   incidental, or consequential damages of any character arising as a
+   result of this License or out of the use or inability to use the
+   Work (including but not limited to damages for loss of goodwill,
+   work stoppage, computer failure or malfunction, or any and all
+   other commercial damages or losses), even if such Contributor
+   has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing
+   the Work or Derivative Works thereof, You may choose to offer,
+   and charge a fee for, acceptance of support, warranty, indemnity,
+   or other liability obligations and/or rights consistent with this
+   License. However, in accepting such obligations, You may act only
+   on Your own behalf and on Your sole responsibility, not on behalf
+   of any other Contributor, and only if You agree to indemnify,
+   defend, and hold each Contributor harmless for any liability
+   incurred by, or claims asserted against, such Contributor by reason
+   of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work.
+
+   To apply the Apache License to your work, attach the following
+   boilerplate notice, with the fields enclosed by brackets "[]"
+   replaced with your own identifying information. (Don't include
+   the brackets!)  The text should be enclosed in the appropriate
+   comment syntax for the file format. We also recommend that a
+   file or class name and description of purpose be included on the
+   same "printed page" as the copyright notice for easier
+   identification within third-party archives.
+
+Copyright [yyyy] [name of copyright owner]
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+	http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/third_party/rust/ringbuf/LICENSE-MIT b/third_party/rust/ringbuf/LICENSE-MIT
new file mode 100644
--- /dev/null
+++ b/third_party/rust/ringbuf/LICENSE-MIT
@@ -0,0 +1,25 @@
+Copyright (c) 2019 Alexey Gerasev
+
+Permission is hereby granted, free of charge, to any
+person obtaining a copy of this software and associated
+documentation files (the "Software"), to deal in the
+Software without restriction, including without
+limitation the rights to use, copy, modify, merge,
+publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software
+is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice
+shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
diff --git a/third_party/rust/ringbuf/README.md b/third_party/rust/ringbuf/README.md
new file mode 100644
--- /dev/null
+++ b/third_party/rust/ringbuf/README.md
@@ -0,0 +1,151 @@
+# ringbuf
+
+[![Crates.io][crates_badge]][crates]
+[![Docs.rs][docs_badge]][docs]
+[![Travis CI][travis_badge]][travis]
+[![Appveyor][appveyor_badge]][appveyor]
+[![Codecov.io][codecov_badge]][codecov]
+[![License][license_badge]][license]
+
+[crates_badge]: https://img.shields.io/crates/v/ringbuf.svg
+[docs_badge]: https://docs.rs/ringbuf/badge.svg
+[travis_badge]: https://api.travis-ci.org/nthend/ringbuf.svg
+[appveyor_badge]: https://ci.appveyor.com/api/projects/status/github/nthend/ringbuf?branch=master&svg=true
+[codecov_badge]: https://codecov.io/gh/nthend/ringbuf/graphs/badge.svg
+[license_badge]: https://img.shields.io/crates/l/ringbuf.svg
+
+[crates]: https://crates.io/crates/ringbuf
+[docs]: https://docs.rs/ringbuf
+[travis]: https://travis-ci.org/nthend/ringbuf
+[appveyor]: https://ci.appveyor.com/project/nthend/ringbuf
+[codecov]: https://codecov.io/gh/nthend/ringbuf
+[license]: #license
+
+Lock-free single-producer single-consumer (SPSC) FIFO ring buffer with direct access to inner data.
+
+## Overview
+
+`RingBuffer` is the initial structure representing ring buffer itself.
+Ring buffer can be splitted into pair of `Producer` and `Consumer`.
+
+`Producer` and `Consumer` are used to append/remove elements to/from the ring buffer accordingly. They can be safely transfered between threads.
+Operations with `Producer` and `Consumer` are lock-free - they're succeded or failed immediately without blocking or waiting.
+
+Elements can be effectively appended/removed one by one or many at once.
+Also data could be loaded/stored directly into/from [`Read`]/[`Write`] instances.
+And finally, there are `unsafe` methods allowing thread-safe direct access in place to the inner memory being appended/removed.
+
+[`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html
+[`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html
+
+## Documentation
++ [`crates.io` version documentation](https://docs.rs/ringbuf)
++ [`master` branch documentation](https://nthend.github.io/ringbuf/target/doc/ringbuf/index.html)
+
+## Examples
+
+### Simple example
+
+```rust
+use ringbuf::{RingBuffer, PushError, PopError};
+
+let rb = RingBuffer::<i32>::new(2);
+let (mut prod, mut cons) = rb.split();
+
+prod.push(0).unwrap();
+prod.push(1).unwrap();
+assert_eq!(prod.push(2), Err(PushError::Full(2)));
+
+assert_eq!(cons.pop().unwrap(), 0);
+
+prod.push(2).unwrap();
+
+assert_eq!(cons.pop().unwrap(), 1);
+assert_eq!(cons.pop().unwrap(), 2);
+assert_eq!(cons.pop(), Err(PopError::Empty));
+```
+
+### Message transfer
+
+This is more complicated example of transfering text message between threads.
+
+```rust
+use std::io::{Read};
+use std::thread;
+use std::time::{Duration};
+
+use ringbuf::{RingBuffer};
+
+let rb = RingBuffer::<u8>::new(10);
+let (mut prod, mut cons) = rb.split();
+
+let smsg = "The quick brown fox jumps over the lazy dog";
+
+let pjh = thread::spawn(move || {
+    println!("-> sending message: '{}'", smsg);
+
+    let zero = [0 as u8];
+    let mut bytes = smsg.as_bytes().chain(&zero[..]);
+    loop {
+        match prod.read_from(&mut bytes, None) {
+            Ok(n) => {
+                if n == 0 {
+                    break;
+                }
+                println!("-> {} bytes sent", n);
+            },
+            Err(_) => {
+                println!("-> buffer is full, waiting");
+                thread::sleep(Duration::from_millis(1));
+            },
+        }
+    }
+
+    println!("-> message sent");
+});
+
+let cjh = thread::spawn(move || {
+    println!("<- receiving message");
+
+    let mut bytes = Vec::<u8>::new();
+    loop {
+        match cons.write_into(&mut bytes, None) {
+            Ok(n) => println!("<- {} bytes received", n),
+            Err(_) => {
+                if bytes.ends_with(&[0]) {
+                    break;
+                } else {
+                    println!("<- buffer is empty, waiting");
+                    thread::sleep(Duration::from_millis(1));
+                }
+            },
+        }
+    }
+
+    assert_eq!(bytes.pop().unwrap(), 0);
+    let msg = String::from_utf8(bytes).unwrap();
+    println!("<- message received: '{}'", msg);
+
+    msg
+});
+
+pjh.join().unwrap();
+let rmsg = cjh.join().unwrap();
+
+assert_eq!(smsg, rmsg);
+```
+
+## License
+
+Licensed under either of
+
+ * Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)
+ * MIT license ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)
+
+at your option.
+
+### Contribution
+
+Unless you explicitly state otherwise, any contribution intentionally submitted
+for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any
+additional terms or conditions.
diff --git a/third_party/rust/ringbuf/appveyor.yml b/third_party/rust/ringbuf/appveyor.yml
new file mode 100644
--- /dev/null
+++ b/third_party/rust/ringbuf/appveyor.yml
@@ -0,0 +1,49 @@
+os: Visual Studio 2015
+
+environment:
+  matrix:
+    - channel: stable
+      target: x86_64-pc-windows-msvc
+    - channel: stable
+      target: i686-pc-windows-msvc
+    - channel: beta
+      target: x86_64-pc-windows-msvc
+    - channel: beta
+      target: i686-pc-windows-msvc
+    - channel: nightly
+      target: x86_64-pc-windows-msvc
+      #cargoflags: --features "unstable"
+    - channel: nightly
+      target: i686-pc-windows-msvc
+      #cargoflags: --features "unstable"
+
+    - channel: stable
+      target: x86_64-pc-windows-gnu
+    - channel: stable
+      target: i686-pc-windows-gnu
+    - channel: beta
+      target: x86_64-pc-windows-gnu
+    - channel: beta
+      target: i686-pc-windows-gnu
+    - channel: nightly
+      target: x86_64-pc-windows-gnu
+      #cargoflags: --features "unstable"
+    - channel: nightly
+      target: i686-pc-windows-gnu
+      #cargoflags: --features "unstable"
+
+matrix:
+  allow_failures:
+    - channel: nightly
+
+install:
+  - appveyor DownloadFile https://win.rustup.rs/ -FileName rustup-init.exe
+  - rustup-init -yv --default-toolchain %channel% --default-host %target%
+  - set PATH=%PATH%;%USERPROFILE%\.cargo\bin
+  - rustc -vV
+  - cargo -vV
+
+build: false
+
+test_script:
+- cargo test --verbose %cargoflags%
diff --git a/third_party/rust/ringbuf/build.rs b/third_party/rust/ringbuf/build.rs
new file mode 100644
--- /dev/null
+++ b/third_party/rust/ringbuf/build.rs
@@ -0,0 +1,24 @@
+extern crate rustc_version;
+use rustc_version::{version, version_meta, Channel};
+
+
+fn main() {
+    // Assert we haven't travelled back in time
+    assert!(version().unwrap().major >= 1);
+
+    // Set cfg flags depending on release channel
+    match version_meta().unwrap().channel {
+        Channel::Stable => {
+            println!("cargo:rustc-cfg=rustc_stable");
+        }
+        Channel::Beta => {
+            println!("cargo:rustc-cfg=rustc_beta");
+        }
+        Channel::Nightly => {
+            println!("cargo:rustc-cfg=rustc_nightly");
+        }
+        Channel::Dev => {
+            println!("cargo:rustc-cfg=rustc_dev");
+        }
+    }
+}
diff --git a/third_party/rust/ringbuf/examples/message.rs b/third_party/rust/ringbuf/examples/message.rs
new file mode 100644
--- /dev/null
+++ b/third_party/rust/ringbuf/examples/message.rs
@@ -0,0 +1,68 @@
+extern crate ringbuf;
+
+use std::io::{Read};
+use std::thread;
+use std::time::{Duration};
+
+use ringbuf::{RingBuffer};
+
+
+fn main() {
+    let rb = RingBuffer::<u8>::new(10);
+    let (mut prod, mut cons) = rb.split();
+
+    let smsg = "The quick brown fox jumps over the lazy dog";
+    
+    let pjh = thread::spawn(move || {
+        println!("-> sending message: '{}'", smsg);
+
+        let zero = [0 as u8];
+        let mut bytes = smsg.as_bytes().chain(&zero[..]);
+        loop {
+            match prod.read_from(&mut bytes, None) {
+                Ok(n) => {
+                    if n == 0 {
+                        break;
+                    }
+                    println!("-> {} bytes sent", n);
+                },
+                Err(_) => {
+                    println!("-> buffer is full, waiting");
+                    thread::sleep(Duration::from_millis(1));
+                },
+            }
+        }
+
+        println!("-> message sent");
+    });
+
+    let cjh = thread::spawn(move || {
+        println!("<- receiving message");
+
+        let mut bytes = Vec::<u8>::new();
+        loop {
+            match cons.write_into(&mut bytes, None) {
+                Ok(n) => println!("<- {} bytes received", n),
+                Err(_) => {
+                    if bytes.ends_with(&[0]) {
+                        break;
+                    } else {
+                        println!("<- buffer is empty, waiting");
+                        thread::sleep(Duration::from_millis(1));
+                    }
+                },
+            }
+        }
+
+        assert_eq!(bytes.pop().unwrap(), 0);
+        let msg = String::from_utf8(bytes).unwrap();
+        println!("<- message received: '{}'", msg);
+
+        msg
+    });
+
+    pjh.join().unwrap();
+    let rmsg = cjh.join().unwrap();
+
+    assert_eq!(smsg, rmsg);
+}
diff --git a/third_party/rust/ringbuf/examples/simple.rs b/third_party/rust/ringbuf/examples/simple.rs
new file mode 100644
--- /dev/null
+++ b/third_party/rust/ringbuf/examples/simple.rs
@@ -0,0 +1,20 @@
+extern crate ringbuf;
+
+use ringbuf::{RingBuffer, PushError, PopError};
+
+fn main() {
+    let rb = RingBuffer::<i32>::new(2);
+    let (mut prod, mut cons) = rb.split();
+
+    prod.push(0).unwrap();
+    prod.push(1).unwrap();
+    assert_eq!(prod.push(2), Err(PushError::Full(2)));
+
+    assert_eq!(cons.pop().unwrap(), 0);
+
+    prod.push(2).unwrap();
+
+    assert_eq!(cons.pop().unwrap(), 1);
+    assert_eq!(cons.pop().unwrap(), 2);
+    assert_eq!(cons.pop(), Err(PopError::Empty));
+}
diff --git a/third_party/rust/ringbuf/src/benchmarks.rs b/third_party/rust/ringbuf/src/benchmarks.rs
new file mode 100644
--- /dev/null
+++ b/third_party/rust/ringbuf/src/benchmarks.rs
@@ -0,0 +1,13 @@
+use super::*;
+
+use test::Bencher;
+
+#[bench]
+fn push_pop(b: &mut Bencher) {
+    let buf = RingBuffer::<u8>::new(0x100);
+    let (mut prod, mut cons) = buf.split();
+    b.iter(|| {
+        while let Ok(()) = prod.push(0) {}
+        while let Ok(0) = cons.pop() {}
+    });
+}
diff --git a/third_party/rust/ringbuf/src/lib.rs b/third_party/rust/ringbuf/src/lib.rs
new file mode 100644
--- /dev/null
+++ b/third_party/rust/ringbuf/src/lib.rs
@@ -0,0 +1,757 @@
+//! Lock-free single-producer single-consumer (SPSC) FIFO ring buffer with direct access to inner data.
+//!
+//! # Overview
+//!
+//! `RingBuffer` is the initial structure representing ring buffer itself.
+//! Ring buffer can be splitted into pair of `Producer` and `Consumer`.
+//! 
+//! `Producer` and `Consumer` are used to append/remove elements to/from the ring buffer accordingly. They can be safely transfered between threads.
+//! Operations with `Producer` and `Consumer` are lock-free - they're succeded or failed immediately without blocking or waiting.
+//! 
+//! Elements can be effectively appended/removed one by one or many at once.
+//! Also data could be loaded/stored directly into/from [`Read`]/[`Write`] instances.
+//! And finally, there are `unsafe` methods allowing thread-safe direct access in place to the inner memory being appended/removed.
+//! 
+//! [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html
+//! [`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html
+//!
+//! # Examples
+//!
+//! ## Simple example
+//!
+//! ```rust
+//! # extern crate ringbuf;
+//! use ringbuf::{RingBuffer, PushError, PopError};
+//! # fn main() {
+//! let rb = RingBuffer::<i32>::new(2);
+//! let (mut prod, mut cons) = rb.split();
+//! 
+//! prod.push(0).unwrap();
+//! prod.push(1).unwrap();
+//! assert_eq!(prod.push(2), Err(PushError::Full(2)));
+//! 
+//! assert_eq!(cons.pop().unwrap(), 0);
+//! 
+//! prod.push(2).unwrap();
+//! 
+//! assert_eq!(cons.pop().unwrap(), 1);
+//! assert_eq!(cons.pop().unwrap(), 2);
+//! assert_eq!(cons.pop(), Err(PopError::Empty));
+//! # }
+//! ```
+//!
+//! ## Message transfer
+//!
+//! This is more complicated example of transfering text message between threads.
+//!
+//! ```rust
+//! # extern crate ringbuf;
+//! use std::io::{Read};
+//! use std::thread;
+//! use std::time::{Duration};
+//! 
+//! use ringbuf::{RingBuffer};
+//! # fn main() {
+//! let rb = RingBuffer::<u8>::new(10);
+//! let (mut prod, mut cons) = rb.split();
+//! 
+//! let smsg = "The quick brown fox jumps over the lazy dog";
+//! 
+//! let pjh = thread::spawn(move || {
+//!     println!("-> sending message: '{}'", smsg);
+//! 
+//!     let zero = [0 as u8];
+//!     let mut bytes = smsg.as_bytes().chain(&zero[..]);
+//!     loop {
+//!         match prod.read_from(&mut bytes, None) {
+//!             Ok(n) => {
+//!                 if n == 0 {
+//!                     break;
+//!                 }
+//!                 println!("-> {} bytes sent", n);
+//!             },
+//!             Err(_) => {
+//!                 println!("-> buffer is full, waiting");
+//!                 thread::sleep(Duration::from_millis(1));
+//!             },
+//!         }
+//!     }
+//! 
+//!     println!("-> message sent");
+//! });
+//! 
+//! let cjh = thread::spawn(move || {
+//!     println!("<- receiving message");
+//! 
+//!     let mut bytes = Vec::<u8>::new();
+//!     loop {
+//!         match cons.write_into(&mut bytes, None) {
+//!             Ok(n) => println!("<- {} bytes received", n),
+//!             Err(_) => {
+//!                 if bytes.ends_with(&[0]) {
+//!                     break;
+//!                 } else {
+//!                     println!("<- buffer is empty, waiting");
+//!                     thread::sleep(Duration::from_millis(1));
+//!                 }
+//!             },
+//!         }
+//!     }
+//! 
+//!     assert_eq!(bytes.pop().unwrap(), 0);
+//!     let msg = String::from_utf8(bytes).unwrap();
+//!     println!("<- message received: '{}'", msg);
+//! 
+//!     msg
+//! });
+//! 
+//! pjh.join().unwrap();
+//! let rmsg = cjh.join().unwrap();
+//! 
+//! assert_eq!(smsg, rmsg);
+//! # }
+//! ```
+//!
+
+
+#![cfg_attr(rustc_nightly, feature(test))]
+
+#[cfg(test)]
+#[cfg(rustc_nightly)]
+extern crate test;
+
+#[cfg(test)]
+mod tests;
+
+#[cfg(test)]
+#[cfg(rustc_nightly)]
+mod benchmarks;
+
+
+use std::mem;
+use std::cell::{UnsafeCell};
+use std::sync::{Arc, atomic::{Ordering, AtomicUsize}};
+use std::io::{self, Read, Write};
+
+
+#[derive(Debug, PartialEq, Eq)]
+/// `Producer::push` error.
+pub enum PushError<T: Sized> {
+    /// Cannot push: ring buffer is full.
+    Full(T),
+}
+
+#[derive(Debug, PartialEq, Eq)]
+/// `Consumer::pop` error.
+pub enum PopError {
+    /// Cannot pop: ring buffer is empty.
+    Empty,
+}
+
+#[derive(Debug, PartialEq, Eq)]
+/// `Producer::push_slice` error.
+pub enum PushSliceError {
+    /// Cannot push: ring buffer is full.
+    Full,
+}
+
+#[derive(Debug, PartialEq, Eq)]
+/// `Consumer::pop_slice` error.
+pub enum PopSliceError {
+    /// Cannot pop: ring buffer is empty.
+    Empty,
+}
+
+#[derive(Debug, PartialEq, Eq)]
+/// `{Producer, Consumer}::move_slice` error.
+pub enum MoveSliceError {
+    /// Cannot pop: ring buffer is empty.
+    Empty,
+    /// Cannot push: ring buffer is full.
+    Full,
+}
+
+#[derive(Debug, PartialEq, Eq)]
+/// `Producer::push_access` error.
+pub enum PushAccessError {
+    /// Cannot push: ring buffer is full.
+    Full,
+    /// User function returned invalid length.
+    BadLen,
+}
+
+#[derive(Debug, PartialEq, Eq)]
+/// `Consumer::pop_access` error.
+pub enum PopAccessError {
+    /// Cannot pop: ring buffer is empty.
+    Empty,
+    /// User function returned invalid length.
+    BadLen,
+}
+
+#[derive(Debug)]
+/// `Producer::read_from` error.
+pub enum ReadFromError {
+    /// Error returned by [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html).
+    Read(io::Error),
+    /// Ring buffer is full.
+    RbFull,
+}
+
+#[derive(Debug)]
+/// `Consumer::write_into` error.
+pub enum WriteIntoError {
+    /// Error returned by [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html).
+    Write(io::Error),
+    /// Ring buffer is empty.
+    RbEmpty,
+}
+
+struct SharedVec<T: Sized> {
+    cell: UnsafeCell<Vec<T>>,
+}
+
+unsafe impl<T: Sized> Sync for SharedVec<T> {}
+
+impl<T: Sized> SharedVec<T> {
+    fn new(data: Vec<T>) -> Self {
+        Self { cell: UnsafeCell::new(data) }
+    }
+    unsafe fn get_ref(&self) -> &Vec<T> {
+        self.cell.get().as_ref().unwrap()
+    }
+    unsafe fn get_mut(&self) -> &mut Vec<T> {
+        self.cell.get().as_mut().unwrap()
+    }
+}
+
+/// Ring buffer itself.
+pub struct RingBuffer<T: Sized> {
+    data: SharedVec<T>,
+    head: AtomicUsize,
+    tail: AtomicUsize,
+}
+
+/// Producer part of ring buffer.
+pub struct Producer<T> {
+    rb: Arc<RingBuffer<T>>,
+}
+
+/// Consumer part of ring buffer.
+pub struct Consumer<T> {
+    rb: Arc<RingBuffer<T>>,
+}
+
+impl<T: Sized> RingBuffer<T> {
+    /// Creates a new instance of a ring buffer.
+    pub fn new(capacity: usize) -> Self {
+        let vec_cap = capacity + 1;
+        let mut data = Vec::with_capacity(vec_cap);
+        unsafe { data.set_len(vec_cap); }
+        Self {
+            data: SharedVec::new(data),
+            head: AtomicUsize::new(0),
+            tail: AtomicUsize::new(0),
+        }
+    }
+
+    /// Splits ring buffer into producer and consumer.
+    pub fn split(self) -> (Producer<T>, Consumer<T>) {
+        let arc = Arc::new(self);
+        (
+            Producer { rb: arc.clone() },
+            Consumer { rb: arc },
+        )
+    }
+
+    /// Returns capacity of the ring buffer.
+    pub fn capacity(&self) -> usize {
+        unsafe { self.data.get_ref() }.len() - 1
+    }
+
+    /// Checks if the ring buffer is empty.
+    pub fn is_empty(&self) -> bool {
+        let head = self.head.load(Ordering::SeqCst);
+        let tail = self.tail.load(Ordering::SeqCst);
+        head == tail
+    }
+
+    /// Checks if the ring buffer is full.
+    pub fn is_full(&self) -> bool {
+        let head = self.head.load(Ordering::SeqCst);
+        let tail = self.tail.load(Ordering::SeqCst);
+        (tail + 1) % (self.capacity() + 1) == head
+    }
+}
+
+impl<T: Sized> Drop for RingBuffer<T> {
+    fn drop(&mut self) {
+        let data = unsafe { self.data.get_mut() };
+
+        let head = self.head.load(Ordering::SeqCst);
+        let tail = self.tail.load(Ordering::SeqCst);
+        let len = data.len();
+        
+        let slices = if head <= tail {
+            (head..tail, 0..0)
+        } else {
+            (head..len, 0..tail)
+        };
+
+        let drop = |elem_ref: &mut T| {
+            mem::drop(mem::replace(elem_ref, unsafe { mem::uninitialized() }));
+        };
+        for elem in data[slices.0].iter_mut() {
+            drop(elem);
+        }
+        for elem in data[slices.1].iter_mut() {
+            drop(elem);
+        }
+
+        unsafe { data.set_len(0); }
+    }
+}
+
+impl<T: Sized> Producer<T> {
+    /// Returns capacity of the ring buffer.
+    pub fn capacity(&self) -> usize {
+        self.rb.capacity()
+    }
+
+    /// Checks if the ring buffer is empty.
+    pub fn is_empty(&self) -> bool {
+        self.rb.is_empty()
+    }
+
+    /// Checks if the ring buffer is full.
+    pub fn is_full(&self) -> bool {
+        self.rb.is_full()
+    }
+    
+    /// Appends an element to the ring buffer.
+    /// On failure returns an error containing the element that hasn't beed appended.
+    pub fn push(&mut self, elem: T) -> Result<(), PushError<T>> {
+        let mut elem_opt = Some(elem);
+        match unsafe { self.push_access(|slice, _| {
+            mem::forget(mem::replace(&mut slice[0], elem_opt.take().unwrap()));
+            Ok((1, ()))
+        }) } {
+            Ok(res) => match res {
+                Ok((n, ())) => {
+                    debug_assert_eq!(n, 1);
+                    Ok(())
+                },
+                Err(()) => unreachable!(),
+            },
+            Err(e) => match e {
+                PushAccessError::Full => Err(PushError::Full(elem_opt.unwrap())),
+                PushAccessError::BadLen => unreachable!(),
+            }
+        }
+    }
+}
+
+impl<T: Sized + Copy> Producer<T> {
+    /// Appends elements from slice to the ring buffer.
+    /// Elements should be [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html).
+    ///
+    /// On success returns count of elements been appended to the ring buffer.
+    pub fn push_slice(&mut self, elems: &[T]) -> Result<usize, PushSliceError> {
+        let push_fn = |left: &mut [T], right: &mut [T]| {
+            Ok((if elems.len() < left.len() {
+                left[0..elems.len()].copy_from_slice(elems);
+                elems.len()
+            } else {
+                left.copy_from_slice(&elems[0..left.len()]);
+                if elems.len() < left.len() + right.len() {
+                    right[0..(elems.len() - left.len())]
+                        .copy_from_slice(&elems[left.len()..elems.len()]);
+                    elems.len()
+                } else {
+                    right.copy_from_slice(&elems[left.len()..(left.len() + right.len())]);
+                    left.len() + right.len()
+                }
+            }, ()))
+        };
+        match unsafe { self.push_access(push_fn) } {
+            Ok(res) => match res {
+                Ok((n, ())) => {
+                    Ok(n)
+                },
+                Err(()) => unreachable!(),
+            },
+            Err(e) => match e {
+                PushAccessError::Full => Err(PushSliceError::Full),
+                PushAccessError::BadLen => unreachable!(),
+            }
+        }
+    }
+
+    /// Removes at most `count` elements from the `Consumer` of the ring buffer
+    /// and appends them to the `Producer` of the another one.
+    /// If `count` is `None` then as much as possible elements will be moved.
+    ///
+    /// Elements should be [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html).
+    ///
+    /// On success returns count of elements been moved.
+    pub fn move_slice(&mut self, other: &mut Consumer<T>, count: Option<usize>)
+    -> Result<usize, MoveSliceError> {
+        let move_fn = |left: &mut [T], right: &mut [T]|
+        -> Result<(usize, ()), PopSliceError> {
+            let (left, right) = match count {
+                Some(c) => {
+                    if c < left.len() {
+                        (&mut left[0..c], &mut right[0..0])
+                    } else if c < left.len() + right.len() {
+                        let l = c - left.len();
+                        (left, &mut right[0..l])
+                    } else {
+                        (left, right)
+                    }
+                },
+                None => (left, right)
+            };
+            other.pop_slice(left).and_then(|n| {
+                if n == left.len() {
+                    other.pop_slice(right).and_then(|m| {
+                        Ok((n + m, ()))
+                    }).or_else(|e| {
+                        match e {
+                            PopSliceError::Empty => Ok((n, ())),
+                        }
+                    })
+                } else {
+                    debug_assert!(n < left.len());
+                    Ok((n, ()))
+                }
+            })
+        };
+        match unsafe { self.push_access(move_fn) } {
+            Ok(res) => match res {
+                Ok((n, ())) => Ok(n),
+                Err(e) => match e {
+                    PopSliceError::Empty => Err(MoveSliceError::Empty),
+                },
+            },
+            Err(e) => match e {
+                PushAccessError::Full => Err(MoveSliceError::Full),
+                PushAccessError::BadLen => unreachable!(),
+            }
+        }
+    }
+}
+
+impl Producer<u8> {
+    /// Reads at most `count` bytes
+    /// from [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) instance
+    /// and appends them to the ring buffer.
+    /// If `count` is `None` then as much as possible bytes will be read.
+    pub fn read_from(&mut self, reader: &mut dyn Read, count: Option<usize>)
+    -> Result<usize, ReadFromError> {
+        let push_fn = |left: &mut [u8], _right: &mut [u8]|
+        -> Result<(usize, ()), io::Error> {
+            let left = match count {
+                Some(c) => {
+                    if c < left.len() {
+                        &mut left[0..c]
+                    } else {
+                        left
+                    }
+                },
+                None => left,
+            };
+            reader.read(left).and_then(|n| {
+                if n <= left.len() {
+                    Ok((n, ()))
+                } else {
+                    Err(io::Error::new(
+                        io::ErrorKind::InvalidInput,
+                        "Read operation returned invalid number",
+                    ))
+                }
+            })
+        };
+        match unsafe { self.push_access(push_fn) } {
+            Ok(res) => match res {
+                Ok((n, ())) => Ok(n),
+                Err(e) => Err(ReadFromError::Read(e)),
+            },
+            Err(e) => match e {
+                PushAccessError::Full => Err(ReadFromError::RbFull),
+                PushAccessError::BadLen => unreachable!(),
+            }
+        }
+    }
+}
+
+impl Write for Producer<u8> {
+    fn write(&mut self, buffer: &[u8]) -> io::Result<usize> {
+        self.push_slice(buffer).or_else(|e| match e {
+            PushSliceError::Full => Err(io::Error::new(
+                io::ErrorKind::WouldBlock,
+                "Ring buffer is full",
+            ))
+        })
+    }
+
+    fn flush(&mut self) -> io::Result<()> {
+        Ok(())
+    }
+}
+
+impl<T: Sized> Producer<T> {
+    /// Allows to write into ring buffer memory directry.
+    ///
+    /// *This function is unsafe beacuse it gives access to possibly uninitialized memory
+    /// and transfers to the user the responsibility of manually calling destructors*
+    ///
+    /// Takes a function `f` as argument.
+    /// `f` takes two slices of ring buffer content (the second one may be empty). First slice contains older elements.
+    ///
+    /// `f` should return:
+    /// + On success: pair of number of elements been written, and some arbitrary data.
+    /// + On failure: some another arbitrary data.
+    ///
+    /// On success returns data returned from `f`.
+    pub unsafe fn push_access<R, E, F>(&mut self, f: F) -> Result<Result<(usize, R), E>, PushAccessError>
+    where R: Sized, E: Sized, F: FnOnce(&mut [T], &mut [T]) -> Result<(usize, R), E> {
+        let head = self.rb.head.load(Ordering::SeqCst);
+        let tail = self.rb.tail.load(Ordering::SeqCst);
+        let len = self.rb.data.get_ref().len();
+
+        let ranges = if tail >= head {
+            if head > 0 {
+                Ok((tail..len, 0..(head - 1)))
+            } else {
+                if tail < len - 1 {
+                    Ok((tail..(len - 1), 0..0))
+                } else {
+                    Err(PushAccessError::Full)
+                }
+            }
+        } else {
+            if tail < head - 1 {
+                Ok((tail..(head - 1), 0..0))
+            } else {
+                Err(PushAccessError::Full)
+            }
+        }?;
+
+        let slices = (
+            &mut self.rb.data.get_mut()[ranges.0],
+            &mut self.rb.data.get_mut()[ranges.1],
+        );
+
+        match f(slices.0, slices.1) {
+            Ok((n, r)) => {
+                if n > slices.0.len() + slices.1.len() {
+                    Err(PushAccessError::BadLen)
+                } else {
+                    let new_tail = (tail + n) % len;
+                    self.rb.tail.store(new_tail, Ordering::SeqCst);
+                    Ok(Ok((n, r)))
+                }
+            },
+            Err(e) => {
+                Ok(Err(e))
+            }
+        }
+    }
+}
+
+impl<T: Sized> Consumer<T> {
+    /// Returns capacity of the ring buffer.
+    pub fn capacity(&self) -> usize {
+        self.rb.capacity()
+    }
+
+    /// Checks if the ring buffer is empty.
+    pub fn is_empty(&self) -> bool {
+        self.rb.is_empty()
+    }
+
+    /// Checks if the ring buffer is full.
+    pub fn is_full(&self) -> bool {
+        self.rb.is_full()
+    }
+
+    /// Removes first element from the ring buffer and returns it.
+    pub fn pop(&mut self) -> Result<T, PopError> {
+        match unsafe { self.pop_access(|slice, _| {
+            let elem = mem::replace(&mut slice[0], mem::uninitialized());
+            Ok((1, elem))
+        }) } {
+            Ok(res) => match res {
+                Ok((n, elem)) => {
+                    debug_assert_eq!(n, 1);
+                    Ok(elem)
+                },
+                Err(()) => unreachable!(),
+            },
+            Err(e) => match e {
+                PopAccessError::Empty => Err(PopError::Empty),
+                PopAccessError::BadLen => unreachable!(),
+            }
+        }
+    }
+}
+
+impl<T: Sized + Copy> Consumer<T> {
+    /// Removes first elements from the ring buffer and writes them into a slice.
+    /// Elements should be [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html).
+    ///
+    /// On success returns count of elements been removed from the ring buffer.
+    pub fn pop_slice(&mut self, elems: &mut [T]) -> Result<usize, PopSliceError> {
+        let pop_fn = |left: &mut [T], right: &mut [T]| {
+            let elems_len = elems.len();
+            Ok((if elems_len < left.len() {
+                elems.copy_from_slice(&left[0..elems_len]);
+                elems_len
+            } else {
+                elems[0..left.len()].copy_from_slice(left);
+                if elems_len < left.len() + right.len() {
+                    elems[left.len()..elems_len]
+                        .copy_from_slice(&right[0..(elems_len - left.len())]);
+                    elems_len
+                } else {
+                    elems[left.len()..(left.len() + right.len())].copy_from_slice(right);
+                    left.len() + right.len()
+                }
+            }, ()))
+        };
+        match unsafe { self.pop_access(pop_fn) } {
+            Ok(res) => match res {
+                Ok((n, ())) => {
+                    Ok(n)
+                },
+                Err(()) => unreachable!(),
+            },
+            Err(e) => match e {
+                PopAccessError::Empty => Err(PopSliceError::Empty),
+                PopAccessError::BadLen => unreachable!(),
+            }
+        }
+    }
+
+    /// Removes at most `count` elements from the `Consumer` of the ring buffer
+    /// and appends them to the `Producer` of the another one.
+    /// If `count` is `None` then as much as possible elements will be moved.
+    ///
+    /// Elements should be [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html).
+    ///
+    /// On success returns count of elements been moved.
+    pub fn move_slice(&mut self, other: &mut Producer<T>, count: Option<usize>)
+    -> Result<usize, MoveSliceError> {
+        other.move_slice(self, count)
+    }
+}
+
+impl Consumer<u8> {
+    /// Removes at most first `count` bytes from the ring buffer and writes them into
+    /// a [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html) instance.
+    /// If `count` is `None` then as much as possible bytes will be written.
+    pub fn write_into(&mut self, writer: &mut dyn Write, count: Option<usize>)
+    -> Result<usize, WriteIntoError> {
+        let pop_fn = |left: &mut [u8], _right: &mut [u8]|
+        -> Result<(usize, ()), io::Error> {
+            let left = match count {
+                Some(c) => {
+                    if c < left.len() {
+                        &mut left[0..c]
+                    } else {
+                        left
+                    }
+                },
+                None => left,
+            };
+            writer.write(left).and_then(|n| {
+                if n <= left.len() {
+                    Ok((n, ()))
+                } else {
+                    Err(io::Error::new(
+                        io::ErrorKind::InvalidInput,
+                        "Write operation returned invalid number",
+                    ))
+                }
+            })
+        };
+        match unsafe { self.pop_access(pop_fn) } {
+            Ok(res) => match res {
+                Ok((n, ())) => Ok(n),
+                Err(e) => Err(WriteIntoError::Write(e)),
+            },
+            Err(e) => match e {
+                PopAccessError::Empty => Err(WriteIntoError::RbEmpty),
+                PopAccessError::BadLen => unreachable!(),
+            }
+        }
+    }
+}
+
+impl Read for Consumer<u8> {
+    fn read(&mut self, buffer: &mut [u8]) -> io::Result<usize> {
+        self.pop_slice(buffer).or_else(|e| match e {
+            PopSliceError::Empty => Err(io::Error::new(
+                io::ErrorKind::WouldBlock,
+                "Ring buffer is empty",
+            ))
+        })
+    }
+}
+
+impl<T: Sized> Consumer<T> {
+    /// Allows to read from ring buffer memory directry.
+    ///
+    /// *This function is unsafe beacuse it gives access to possibly uninitialized memory
+    /// and transfers to the user the responsibility of manually calling destructors*
+    ///
+    /// Takes a function `f` as argument.
+    /// `f` takes two slices of ring buffer content (the second one may be empty). First slice contains older elements.
+    ///
+    /// `f` should return:
+    /// + On success: pair of number of elements been read, and some arbitrary data.
+    /// + On failure: some another arbitrary data.
+    ///
+    /// On success returns data returned from `f`.
+    pub unsafe fn pop_access<R, E, F>(&mut self, f: F) -> Result<Result<(usize, R), E>, PopAccessError>
+    where R: Sized, E: Sized, F: FnOnce(&mut [T], &mut [T]) -> Result<(usize, R), E> {
+        let head = self.rb.head.load(Ordering::SeqCst);
+        let tail = self.rb.tail.load(Ordering::SeqCst);
+        let len = self.rb.data.get_ref().len();
+
+        let ranges = if head < tail {
+            Ok((head..tail, 0..0))
+        } else if head > tail {
+            Ok((head..len, 0..tail))
+        } else {
+            Err(PopAccessError::Empty)
+        }?;
+
+        let slices = (
+            &mut self.rb.data.get_mut()[ranges.0],
+            &mut self.rb.data.get_mut()[ranges.1],
+        );
+
+        match f(slices.0, slices.1) {
+            Ok((n, r)) => {
+                if n > slices.0.len() + slices.1.len() {
+                    Err(PopAccessError::BadLen)
+                } else {
+                    let new_head = (head + n) % len;
+                    self.rb.head.store(new_head, Ordering::SeqCst);
+                    Ok(Ok((n, r)))
+                }
+            },
+            Err(e) => {
+                Ok(Err(e))
+            }
+        }
+    }
+}
+
+#[cfg(test)]
+#[test]
+fn dummy_test() {
+    let rb = RingBuffer::<i32>::new(16);
+    rb.split();
+}
diff --git a/third_party/rust/ringbuf/src/tests.rs b/third_party/rust/ringbuf/src/tests.rs
new file mode 100644
--- /dev/null
+++ b/third_party/rust/ringbuf/src/tests.rs
@@ -0,0 +1,992 @@
+use super::*;
+
+use std::cell::{Cell};
+use std::thread;
+use std::io::{Read, Write};
+use std::time::{Duration};
+
+fn head_tail<T>(rb: &RingBuffer<T>) -> (usize, usize) {
+    (rb.head.load(Ordering::SeqCst), rb.tail.load(Ordering::SeqCst))
+}
+
+#[test]
+fn capacity() {
+    let cap = 13;
+    let buf = RingBuffer::<i32>::new(cap);
+    assert_eq!(buf.capacity(), cap);
+}
+
+#[test]
+fn split_capacity() {
+    let cap = 13;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (prod, cons) = buf.split();
+    
+    assert_eq!(prod.capacity(), cap);
+    assert_eq!(cons.capacity(), cap);
+}
+
+#[test]
+fn split_threads() {
+    let buf = RingBuffer::<i32>::new(10);
+    let (prod, cons) = buf.split();
+    
+    let pjh = thread::spawn(move || {
+        let _ = prod;
+    });
+
+    let cjh = thread::spawn(move || {
+        let _ = cons;
+    });
+
+    pjh.join().unwrap();
+    cjh.join().unwrap();
+}
+
+#[test]
+fn push() {
+    let cap = 2;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (mut prod, _) = buf.split();
+    
+
+    assert_eq!(head_tail(&prod.rb), (0, 0));
+
+    assert_eq!(prod.push(123), Ok(()));
+    assert_eq!(head_tail(&prod.rb), (0, 1));
+
+    assert_eq!(prod.push(234), Ok(()));
+    assert_eq!(head_tail(&prod.rb), (0, 2));
+
+    assert_eq!(prod.push(345), Err(PushError::Full(345)));
+    assert_eq!(head_tail(&prod.rb), (0, 2));
+}
+
+#[test]
+fn pop_empty() {
+    let cap = 2;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (_, mut cons) = buf.split();
+
+
+    assert_eq!(head_tail(&cons.rb), (0, 0));
+
+    assert_eq!(cons.pop(), Err(PopError::Empty));
+    assert_eq!(head_tail(&cons.rb), (0, 0));
+}
+
+#[test]
+fn push_pop_one() {
+    let cap = 2;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (mut prod, mut cons) = buf.split();
+
+    let vcap = cap + 1;
+    let values = [12, 34, 56, 78, 90];
+    assert_eq!(head_tail(&cons.rb), (0, 0));
+
+    for (i, v) in values.iter().enumerate() {
+        assert_eq!(prod.push(*v), Ok(()));
+        assert_eq!(head_tail(&cons.rb), (i % vcap, (i + 1) % vcap));
+
+        match cons.pop() {
+            Ok(w) => assert_eq!(w, *v),
+            other => panic!(other),
+        }
+        assert_eq!(head_tail(&cons.rb), ((i + 1) % vcap, (i + 1) % vcap));
+
+        assert_eq!(cons.pop(), Err(PopError::Empty));
+        assert_eq!(head_tail(&cons.rb), ((i + 1) % vcap, (i + 1) % vcap));
+    }
+}
+
+#[test]
+fn push_pop_all() {
+    let cap = 2;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (mut prod, mut cons) = buf.split();
+
+    let vcap = cap + 1;
+    let values = [(12, 34, 13), (56, 78, 57), (90, 10, 91)];
+    assert_eq!(head_tail(&cons.rb), (0, 0));
+
+    for (i, v) in values.iter().enumerate() {
+        assert_eq!(prod.push(v.0), Ok(()));
+        assert_eq!(head_tail(&cons.rb), (cap*i % vcap, (cap*i + 1) % vcap));
+
+        assert_eq!(prod.push(v.1), Ok(()));
+        assert_eq!(head_tail(&cons.rb), (cap*i % vcap, (cap*i + 2) % vcap));
+
+        match prod.push(v.2) {
+            Err(PushError::Full(w)) => assert_eq!(w, v.2),
+            other => panic!(other),
+        }
+        assert_eq!(head_tail(&cons.rb), (cap*i % vcap, (cap*i + 2) % vcap));
+
+
+        match cons.pop() {
+            Ok(w) => assert_eq!(w, v.0),
+            other => panic!(other),
+        }
+        assert_eq!(head_tail(&cons.rb), ((cap*i + 1) % vcap, (cap*i + 2) % vcap));
+
+        match cons.pop() {
+            Ok(w) => assert_eq!(w, v.1),
+            other => panic!(other),
+        }
+        assert_eq!(head_tail(&cons.rb), ((cap*i + 2) % vcap, (cap*i + 2) % vcap));
+
+        assert_eq!(cons.pop(), Err(PopError::Empty));
+        assert_eq!(head_tail(&cons.rb), ((cap*i + 2) % vcap, (cap*i + 2) % vcap));
+    }
+}
+
+#[test]
+fn empty_full() {
+    let buf = RingBuffer::<i32>::new(1);
+    let (mut prod, cons) = buf.split();
+
+    assert!(prod.is_empty());
+    assert!(cons.is_empty());
+    assert!(!prod.is_full());
+    assert!(!cons.is_full());
+
+    assert_eq!(prod.push(123), Ok(()));
+
+    assert!(!prod.is_empty());
+    assert!(!cons.is_empty());
+    assert!(prod.is_full());
+    assert!(cons.is_full());
+}
+
+#[derive(Debug)]
+struct Dropper<'a> {
+    cnt: &'a Cell<i32>,
+}
+
+impl<'a> Dropper<'a> {
+    fn new(c: &'a Cell<i32>) -> Self {
+        Self { cnt: c }
+    }
+}
+
+impl<'a> Drop for Dropper<'a> {
+    fn drop(&mut self) {
+        self.cnt.set(self.cnt.get() + 1);
+    }
+}
+
+#[test]
+fn drop() {
+    let (ca, cb) = (Cell::new(0), Cell::new(0));
+    let (da, db) = (Dropper::new(&ca), Dropper::new(&cb));
+
+    let cap = 3;
+    let buf = RingBuffer::new(cap);
+
+    {
+        let (mut prod, mut cons) = buf.split();
+
+        assert_eq!((ca.get(), cb.get()), (0, 0));
+
+        prod.push(da).unwrap();
+        assert_eq!((ca.get(), cb.get()), (0, 0));
+
+        prod.push(db).unwrap();
+        assert_eq!((ca.get(), cb.get()), (0, 0));
+
+        cons.pop().unwrap();
+        assert_eq!((ca.get(), cb.get()), (1, 0));
+    }
+    
+    assert_eq!((ca.get(), cb.get()), (1, 1));
+}
+
+#[test]
+fn push_access() {
+    let cap = 2;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (mut prod, mut cons) = buf.split();
+
+    let vs_20 = (123, 456);
+    let push_fn_20 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 2);
+        assert_eq!(right.len(), 0);
+        left[0] = vs_20.0;
+        left[1] = vs_20.1;
+        Ok((2, ()))
+    };
+
+    assert_eq!(unsafe { prod.push_access(push_fn_20) }.unwrap().unwrap(), (2, ()));
+
+    assert_eq!(cons.pop().unwrap(), vs_20.0);
+    assert_eq!(cons.pop().unwrap(), vs_20.1);
+    assert_eq!(cons.pop(), Err(PopError::Empty));
+
+    let vs_11 = (123, 456);
+    let push_fn_11 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 1);
+        assert_eq!(right.len(), 1);
+        left[0] = vs_11.0;
+        right[0] = vs_11.1;
+        Ok((2, ()))
+    };
+
+    assert_eq!(unsafe { prod.push_access(push_fn_11) }.unwrap().unwrap(), (2, ()));
+
+    assert_eq!(cons.pop().unwrap(), vs_11.0);
+    assert_eq!(cons.pop().unwrap(), vs_11.1);
+    assert_eq!(cons.pop(), Err(PopError::Empty));
+}
+
+/*
+/// This test doesn't compile.
+/// And that's good :)
+#[test]
+fn push_access_oref() {
+    let cap = 2;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (mut prod, _) = buf.split();
+
+    let mut ovar = 123;
+    let mut oref = &mut 123;
+    let push_fn_20 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        left[0] = 456;
+        oref = &mut left[0];
+        Ok((1, ()))
+    };
+
+    assert_eq!(unsafe {
+        prod.push_access(push_fn_20)
+    }.unwrap().unwrap(), (1, ()));
+
+    assert_eq!(*oref, 456);
+}
+*/
+
+#[test]
+fn pop_access_full() {
+    let cap = 2;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (_, mut cons) = buf.split();
+
+    let dummy_fn = |_l: &mut [i32], _r: &mut [i32]| -> Result<(usize, ()), ()> {
+        if true {
+            Ok((0, ()))
+        } else {
+            Err(())
+        }
+    };
+    assert_eq!(unsafe { cons.pop_access(dummy_fn) }, Err(PopAccessError::Empty));
+}
+
+#[test]
+fn pop_access_empty() {
+    let cap = 2;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (_, mut cons) = buf.split();
+
+    let dummy_fn = |_l: &mut [i32], _r: &mut [i32]| -> Result<(usize, ()), ()> {
+        if true {
+            Ok((0, ()))
+        } else {
+            Err(())
+        }
+    };
+    assert_eq!(unsafe { cons.pop_access(dummy_fn) }, Err(PopAccessError::Empty));
+}
+
+#[test]
+fn pop_access() {
+    let cap = 2;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (mut prod, mut cons) = buf.split();
+
+
+    let vs_20 = (123, 456);
+
+    assert_eq!(prod.push(vs_20.0), Ok(()));
+    assert_eq!(prod.push(vs_20.1), Ok(()));
+    assert_eq!(prod.push(0), Err(PushError::Full(0)));
+
+    let pop_fn_20 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 2);
+        assert_eq!(right.len(), 0);
+        assert_eq!(left[0], vs_20.0);
+        assert_eq!(left[1], vs_20.1);
+        Ok((2, ()))
+    };
+
+    assert_eq!(unsafe { cons.pop_access(pop_fn_20) }.unwrap().unwrap(), (2, ()));
+
+
+    let vs_11 = (123, 456);
+    
+    assert_eq!(prod.push(vs_11.0), Ok(()));
+    assert_eq!(prod.push(vs_11.1), Ok(()));
+    assert_eq!(prod.push(0), Err(PushError::Full(0)));
+    
+    let pop_fn_11 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 1);
+        assert_eq!(right.len(), 1);
+        assert_eq!(left[0], vs_11.0);
+        assert_eq!(right[0], vs_11.1);
+        Ok((2, ()))
+    };
+
+    assert_eq!(unsafe { cons.pop_access(pop_fn_11) }.unwrap().unwrap(), (2, ()));
+
+}
+
+#[test]
+fn push_access_return() {
+    let cap = 2;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (mut prod, mut cons) = buf.split();
+
+    let push_fn_3 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 2);
+        assert_eq!(right.len(), 0);
+        Ok((3, ()))
+    };
+
+    assert_eq!(unsafe { prod.push_access(push_fn_3) }, Err(PushAccessError::BadLen)
+    );
+
+    let push_fn_err = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), i32> {
+        assert_eq!(left.len(), 2);
+        assert_eq!(right.len(), 0);
+        Err(123)
+    };
+
+    assert_eq!(unsafe { prod.push_access(push_fn_err) }, Ok(Err(123))
+    );
+
+    let push_fn_0 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 2);
+        assert_eq!(right.len(), 0);
+        Ok((0, ()))
+    };
+
+    assert_eq!(unsafe { prod.push_access(push_fn_0) }, Ok(Ok((0, ())))
+    );
+
+    let push_fn_1 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 2);
+        assert_eq!(right.len(), 0);
+        left[0] = 12;
+        Ok((1, ()))
+    };
+
+    assert_eq!(unsafe { prod.push_access(push_fn_1) }, Ok(Ok((1, ())))
+    );
+
+    let push_fn_2 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 1);
+        assert_eq!(right.len(), 0);
+        left[0] = 34;
+        Ok((1, ()))
+    };
+
+    assert_eq!(unsafe { prod.push_access(push_fn_2) }, Ok(Ok((1, ())))
+    );
+
+    assert_eq!(cons.pop().unwrap(), 12);
+    assert_eq!(cons.pop().unwrap(), 34);
+    assert_eq!(cons.pop(), Err(PopError::Empty));
+}
+
+#[test]
+fn pop_access_return() {
+    let cap = 2;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (mut prod, mut cons) = buf.split();
+
+    assert_eq!(prod.push(12), Ok(()));
+    assert_eq!(prod.push(34), Ok(()));
+    assert_eq!(prod.push(0), Err(PushError::Full(0)));
+
+    let pop_fn_3 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 2);
+        assert_eq!(right.len(), 0);
+        Ok((3, ()))
+    };
+
+    assert_eq!(unsafe { cons.pop_access(pop_fn_3) }, Err(PopAccessError::BadLen)
+    );
+
+    let pop_fn_err = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), i32> {
+        assert_eq!(left.len(), 2);
+        assert_eq!(right.len(), 0);
+        Err(123)
+    };
+
+    assert_eq!(unsafe { cons.pop_access(pop_fn_err) }, Ok(Err(123))
+    );
+
+    let pop_fn_0 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 2);
+        assert_eq!(right.len(), 0);
+        Ok((0, ()))
+    };
+
+    assert_eq!(unsafe { cons.pop_access(pop_fn_0) }, Ok(Ok((0, ())))
+    );
+
+    let pop_fn_1 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 2);
+        assert_eq!(right.len(), 0);
+        assert_eq!(left[0], 12);
+        Ok((1, ()))
+    };
+
+    assert_eq!(unsafe { cons.pop_access(pop_fn_1) }, Ok(Ok((1, ())))
+    );
+
+    let pop_fn_2 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 1);
+        assert_eq!(right.len(), 0);
+        assert_eq!(left[0], 34);
+        Ok((1, ()))
+    };
+
+    assert_eq!(unsafe { cons.pop_access(pop_fn_2) }, Ok(Ok((1, ())))
+    );
+}
+
+#[test]
+fn push_pop_access() {
+    let cap = 2;
+    let buf = RingBuffer::<i32>::new(cap);
+    let (mut prod, mut cons) = buf.split();
+
+    let vs_20 = (123, 456);
+    let push_fn_20 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 2);
+        assert_eq!(right.len(), 0);
+        left[0] = vs_20.0;
+        left[1] = vs_20.1;
+        Ok((2, ()))
+    };
+
+    assert_eq!(unsafe { prod.push_access(push_fn_20) }.unwrap().unwrap(), (2, ()));
+
+    let pop_fn_20 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 2);
+        assert_eq!(right.len(), 0);
+        assert_eq!(left[0], vs_20.0);
+        assert_eq!(left[1], vs_20.1);
+        Ok((2, ()))
+    };
+
+    assert_eq!(unsafe { cons.pop_access(pop_fn_20) }.unwrap().unwrap(), (2, ()));
+
+
+    let vs_11 = (123, 456);
+    let push_fn_11 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 1);
+        assert_eq!(right.len(), 1);
+        left[0] = vs_11.0;
+        right[0] = vs_11.1;
+        Ok((2, ()))
+    };
+
+    assert_eq!(unsafe { prod.push_access(push_fn_11) }.unwrap().unwrap(), (2, ()));
+
+    let pop_fn_11 = |left: &mut [i32], right: &mut [i32]| -> Result<(usize, ()), ()> {
+        assert_eq!(left.len(), 1);
+        assert_eq!(right.len(), 1);
+        assert_eq!(left[0], vs_11.0);
+        assert_eq!(right[0], vs_11.1);
+        Ok((2, ()))
+    };
+
+    assert_eq!(unsafe { cons.pop_access(pop_fn_11) }.unwrap().unwrap(), (2, ()));
+}
+
+#[test]
+fn push_pop_slice() {
+    let buf = RingBuffer::<i32>::new(4);
+    let (mut prod, mut cons) = buf.split();
+
+    let mut tmp = [0; 5];
+
+    assert_eq!(prod.push_slice(&[]), Ok(0));
+    assert_eq!(prod.push_slice(&[0, 1, 2]), Ok(3));
+
+    assert_eq!(cons.pop_slice(&mut tmp[0..2]), Ok(2));
+    assert_eq!(tmp[0..2], [0, 1]);
+
+    assert_eq!(prod.push_slice(&[3, 4]), Ok(2));
+    assert_eq!(prod.push_slice(&[5, 6]), Ok(1));
+
+    assert_eq!(cons.pop_slice(&mut tmp[0..3]), Ok(3));
+    assert_eq!(tmp[0..3], [2, 3, 4]);
+
+    assert_eq!(prod.push_slice(&[6, 7, 8, 9]), Ok(3));
+
+    assert_eq!(cons.pop_slice(&mut tmp), Ok(4));
+    assert_eq!(tmp[0..4], [5, 6, 7, 8]);
+}
+
+#[test]
+fn move_slice() {
+    let buf0 = RingBuffer::<i32>::new(4);
+    let buf1 = RingBuffer::<i32>::new(4);
+    let (mut prod0, mut cons0) = buf0.split();
+    let (mut prod1, mut cons1) = buf1.split();
+
+    let mut tmp = [0; 5];
+
+    assert_eq!(prod0.push_slice(&[0, 1, 2]), Ok(3));
+
+    assert_eq!(prod1.move_slice(&mut cons0, None), Ok(3));
+    assert_eq!(prod1.move_slice(&mut cons0, None), Err(MoveSliceError::Empty));
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(3));
+    assert_eq!(tmp[0..3], [0, 1, 2]);
+
+
+    assert_eq!(prod0.push_slice(&[3, 4, 5]), Ok(3));
+
+    assert_eq!(prod1.move_slice(&mut cons0, None), Ok(3));
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(3));
+    assert_eq!(tmp[0..3], [3, 4, 5]);
+
+
+    assert_eq!(prod1.push_slice(&[6, 7, 8]), Ok(3));
+    assert_eq!(prod0.push_slice(&[9, 10]), Ok(2));
+
+    assert_eq!(prod1.move_slice(&mut cons0, None), Ok(1));
+    assert_eq!(prod1.move_slice(&mut cons0, None), Err(MoveSliceError::Full));
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(4));
+    assert_eq!(tmp[0..4], [6, 7, 8, 9]);
+}
+
+#[test]
+fn move_slice_count() {
+    let buf0 = RingBuffer::<i32>::new(4);
+    let buf1 = RingBuffer::<i32>::new(4);
+    let (mut prod0, mut cons0) = buf0.split();
+    let (mut prod1, mut cons1) = buf1.split();
+
+    let mut tmp = [0; 5];
+
+    assert_eq!(prod0.push_slice(&[0, 1, 2]), Ok(3));
+
+    assert_eq!(prod1.move_slice(&mut cons0, Some(2)), Ok(2));
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(2));
+    assert_eq!(tmp[0..2], [0, 1]);
+
+    assert_eq!(prod1.move_slice(&mut cons0, Some(2)), Ok(1));
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(1));
+    assert_eq!(tmp[0..1], [2]);
+
+
+    assert_eq!(prod0.push_slice(&[3, 4, 5, 6]), Ok(4));
+
+    assert_eq!(prod1.move_slice(&mut cons0, Some(3)), Ok(3));
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(3));
+    assert_eq!(tmp[0..3], [3, 4, 5]);
+
+    assert_eq!(prod0.push_slice(&[7, 8, 9]), Ok(3));
+
+    assert_eq!(prod1.move_slice(&mut cons0, Some(5)), Ok(4));
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(4));
+    assert_eq!(tmp[0..4], [6, 7, 8, 9]);
+}
+
+#[test]
+fn read_from() {
+    let buf0 = RingBuffer::<u8>::new(4);
+    let buf1 = RingBuffer::<u8>::new(4);
+    let (mut prod0, mut cons0) = buf0.split();
+    let (mut prod1, mut cons1) = buf1.split();
+
+    let mut tmp = [0; 5];
+
+    assert_eq!(prod0.push_slice(&[0, 1, 2]), Ok(3));
+
+    match prod1.read_from(&mut cons0, None) {
+        Ok(n) => assert_eq!(n, 3),
+        other => panic!("{:?}", other),
+    }
+    match prod1.read_from(&mut cons0, None) {
+        Err(ReadFromError::Read(e)) => {
+            assert_eq!(e.kind(), io::ErrorKind::WouldBlock);
+        },
+        other => panic!("{:?}", other),
+    }
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(3));
+    assert_eq!(tmp[0..3], [0, 1, 2]);
+
+
+    assert_eq!(prod0.push_slice(&[3, 4, 5]), Ok(3));
+
+    match prod1.read_from(&mut cons0, None) {
+        Ok(n) => assert_eq!(n, 2),
+        other => panic!("{:?}", other),
+    }
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(2));
+    assert_eq!(tmp[0..2], [3, 4]);
+
+    match prod1.read_from(&mut cons0, None) {
+        Ok(n) => assert_eq!(n, 1),
+        other => panic!("{:?}", other),
+    }
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(1));
+    assert_eq!(tmp[0..1], [5]);
+
+
+    assert_eq!(prod1.push_slice(&[6, 7, 8]), Ok(3));
+    assert_eq!(prod0.push_slice(&[9, 10]), Ok(2));
+
+    match prod1.read_from(&mut cons0, None) {
+        Ok(n) => assert_eq!(n, 1),
+        other => panic!("{:?}", other),
+    }
+    match prod1.read_from(&mut cons0, None) {
+        Err(ReadFromError::RbFull) => (),
+        other => panic!("{:?}", other),
+    }
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(4));
+    assert_eq!(tmp[0..4], [6, 7, 8, 9]);
+}
+
+#[test]
+fn write_into() {
+    let buf0 = RingBuffer::<u8>::new(4);
+    let buf1 = RingBuffer::<u8>::new(4);
+    let (mut prod0, mut cons0) = buf0.split();
+    let (mut prod1, mut cons1) = buf1.split();
+
+    let mut tmp = [0; 5];
+
+    assert_eq!(prod0.push_slice(&[0, 1, 2]), Ok(3));
+
+    match cons0.write_into(&mut prod1, None) {
+        Ok(n) => assert_eq!(n, 3),
+        other => panic!("{:?}", other),
+    }
+    match cons0.write_into(&mut prod1, None) {
+        Err(WriteIntoError::RbEmpty) => (),
+        other => panic!("{:?}", other),
+    }
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(3));
+    assert_eq!(tmp[0..3], [0, 1, 2]);
+
+
+    assert_eq!(prod0.push_slice(&[3, 4, 5]), Ok(3));
+
+    match cons0.write_into(&mut prod1, None) {
+        Ok(n) => assert_eq!(n, 2),
+        other => panic!("{:?}", other),
+    }
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(2));
+    assert_eq!(tmp[0..2], [3, 4]);
+
+    match cons0.write_into(&mut prod1, None) {
+        Ok(n) => assert_eq!(n, 1),
+        other => panic!("{:?}", other),
+    }
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(1));
+    assert_eq!(tmp[0..1], [5]);
+
+
+    assert_eq!(prod1.push_slice(&[6, 7, 8]), Ok(3));
+    assert_eq!(prod0.push_slice(&[9, 10]), Ok(2));
+
+    match cons0.write_into(&mut prod1, None) {
+        Ok(n) => assert_eq!(n, 1),
+        other => panic!("{:?}", other),
+    }
+    match cons0.write_into(&mut prod1, None) {
+        Err(WriteIntoError::Write(e)) => {
+            assert_eq!(e.kind(), io::ErrorKind::WouldBlock);
+        },
+        other => panic!("{:?}", other),
+    }
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(4));
+    assert_eq!(tmp[0..4], [6, 7, 8, 9]);
+}
+
+#[test]
+fn read_from_write_into_count() {
+    let buf0 = RingBuffer::<u8>::new(4);
+    let buf1 = RingBuffer::<u8>::new(4);
+    let (mut prod0, mut cons0) = buf0.split();
+    let (mut prod1, mut cons1) = buf1.split();
+
+    let mut tmp = [0; 5];
+
+    assert_eq!(prod0.push_slice(&[0, 1, 2, 3]), Ok(4));
+
+    match prod1.read_from(&mut cons0, Some(3)) {
+        Ok(n) => assert_eq!(n, 3),
+        other => panic!("{:?}", other),
+    }
+    match prod1.read_from(&mut cons0, Some(2)) {
+        Ok(n) => assert_eq!(n, 1),
+        other => panic!("{:?}", other),
+    }
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(4));
+    assert_eq!(tmp[0..4], [0, 1, 2, 3]);
+
+
+    assert_eq!(prod0.push_slice(&[4, 5, 6, 7]), Ok(4));
+
+    match cons0.write_into(&mut prod1, Some(3)) {
+        Ok(n) => assert_eq!(n, 1),
+        other => panic!("{:?}", other),
+    }
+    match cons0.write_into(&mut prod1, Some(2)) {
+        Ok(n) => assert_eq!(n, 2),
+        other => panic!("{:?}", other),
+    }
+    match cons0.write_into(&mut prod1, Some(2)) {
+        Ok(n) => assert_eq!(n, 1),
+        other => panic!("{:?}", other),
+    }
+
+    assert_eq!(cons1.pop_slice(&mut tmp), Ok(4));
+    assert_eq!(tmp[0..4], [4, 5, 6, 7]);
+}
+
+#[test]
+fn push_pop_access_message() {
+    let buf = RingBuffer::<u8>::new(7);
+    let (mut prod, mut cons) = buf.split();
+
+    let smsg = "The quick brown fox jumps over the lazy dog";
+    
+    let pjh = thread::spawn(move || {
+        let zero = [0 as u8];
+        let mut bytes = smsg.as_bytes().chain(&zero[..]);
+        loop {
+            let push_fn = |left: &mut [u8], right: &mut [u8]| -> Result<(usize, ()),()> {
+                let n = bytes.read(left).unwrap();
+                let m = if n == left.len() {
+                    bytes.read(right).unwrap()
+                } else {
+                    0
+                };
+                Ok((n + m, ()))
+            };
+            match unsafe { prod.push_access(push_fn) } {
+                Ok(res) => match res {
+                    Ok((n, ())) => if n == 0 { break; },
+                    Err(()) => unreachable!(),
+                },
+                Err(e) => match e {
+                    PushAccessError::Full => thread::sleep(Duration::from_millis(1)),
+                    PushAccessError::BadLen => unreachable!(),
+                }
+            }
+        }
+    });
+
+    let cjh = thread::spawn(move || {
+        let mut bytes = Vec::<u8>::new();
+        loop {
+            let pop_fn = |left: &mut [u8], right: &mut [u8]| -> Result<(usize, ()),()> {
+                let n = bytes.write(left).unwrap();
+                let m = if n == left.len() {
+                    bytes.write(right).unwrap()
+                } else {
+                    0
+                };
+                Ok((n + m, ()))
+            };
+            match unsafe { cons.pop_access(pop_fn) } {
+                Ok(res) => match res {
+                    Ok((_n, ())) => (),
+                    Err(()) => unreachable!(),
+                },
+                Err(e) => match e {
+                    PopAccessError::Empty => {
+                        if bytes.ends_with(&[0]) {
+                            break;
+                        } else {
+                            thread::sleep(Duration::from_millis(1));
+                        }
+                    },
+                    PopAccessError::BadLen => unreachable!(),
+                }
+            }
+        }
+
+        assert_eq!(bytes.pop().unwrap(), 0);
+        String::from_utf8(bytes).unwrap()
+    });
+
+    pjh.join().unwrap();
+    let rmsg = cjh.join().unwrap();
+
+    assert_eq!(smsg, rmsg);
+}
+
+#[test]
+fn push_pop_slice_message() {
+    let buf = RingBuffer::<u8>::new(7);
+    let (mut prod, mut cons) = buf.split();
+
+    let smsg = "The quick brown fox jumps over the lazy dog";
+    
+    let pjh = thread::spawn(move || {
+        let mut bytes = smsg.as_bytes();
+        while bytes.len() > 0 {
+            match prod.push_slice(bytes) {
+                Ok(n) => bytes = &bytes[n..bytes.len()],
+                Err(PushSliceError::Full) => thread::sleep(Duration::from_millis(1)),
+            }
+        }
+        loop {
+            match prod.push(0) {
+                Ok(()) => break,
+                Err(PushError::Full(_)) => thread::sleep(Duration::from_millis(1)),
+            }
+        }
+    });
+
+    let cjh = thread::spawn(move || {
+        let mut bytes = Vec::<u8>::new();
+        let mut buffer = [0; 5];
+        loop {
+            match cons.pop_slice(&mut buffer) {
+                Ok(n) => bytes.extend_from_slice(&buffer[0..n]),
+                Err(PopSliceError::Empty) => {
+                    if bytes.ends_with(&[0]) {
+                        break;
+                    } else {
+                        thread::sleep(Duration::from_millis(1));
+                    }
+                }
+            }
+        }
+
+        assert_eq!(bytes.pop().unwrap(), 0);
+        String::from_utf8(bytes).unwrap()
+    });
+
+    pjh.join().unwrap();
+    let rmsg = cjh.join().unwrap();
+
+    assert_eq!(smsg, rmsg);
+}
+
+#[test]
+fn read_from_write_into_message() {
+    let buf = RingBuffer::<u8>::new(7);
+    let (mut prod, mut cons) = buf.split();
+
+    let smsg = "The quick brown fox jumps over the lazy dog";
+    
+    let pjh = thread::spawn(move || {
+        let zero = [0 as u8];
+        let mut bytes = smsg.as_bytes().chain(&zero[..]);
+        loop {
+            match prod.read_from(&mut bytes, None) {
+                Ok(n) => if n == 0 { break; },
+                Err(err) => {
+                    if let ReadFromError::RbFull = err {
+                        thread::sleep(Duration::from_millis(1));
+                    } else {
+                        unreachable!();
+                    }
+                },
+            }
+        }
+    });
+
+    let cjh = thread::spawn(move || {
+        let mut bytes = Vec::<u8>::new();
+        loop {
+            match cons.write_into(&mut bytes, None) {
+                Ok(_n) => (),
+                Err(err) => {
+                    if let WriteIntoError::RbEmpty = err {
+                        if bytes.ends_with(&[0]) {
+                            break;
+                        } else {
+                            thread::sleep(Duration::from_millis(1));
+                        }
+                    } else {
+                        unreachable!();
+                    }
+                },
+            }
+        }
+
+        assert_eq!(bytes.pop().unwrap(), 0);
+        String::from_utf8(bytes).unwrap()
+    });
+
+    pjh.join().unwrap();
+    let rmsg = cjh.join().unwrap();
+
+    assert_eq!(smsg, rmsg);
+}
+
+#[test]
+fn read_write_message() {
+    let buf = RingBuffer::<u8>::new(7);
+    let (mut prod, mut cons) = buf.split();
+
+    let smsg = "The quick brown fox jumps over the lazy dog";
+    
+    let pjh = thread::spawn(move || {
+        let mut bytes = smsg.as_bytes();
+        while bytes.len() > 0 {
+            match prod.write(bytes) {
+                Ok(n) => bytes = &bytes[n..bytes.len()],
+                Err(err) => {
+                    assert_eq!(err.kind(), io::ErrorKind::WouldBlock);
+                    thread::sleep(Duration::from_millis(1));
+                },
+            }
+        }
+        loop {
+            match prod.push(0) {
+                Ok(()) => break,
+                Err(PushError::Full(_)) => thread::sleep(Duration::from_millis(1)),
+            }
+        }
+    });
+
+    let cjh = thread::spawn(move || {
+        let mut bytes = Vec::<u8>::new();
+        let mut buffer = [0; 5];
+        loop {
+            match cons.read(&mut buffer) {
+                Ok(n) => bytes.extend_from_slice(&buffer[0..n]),
+                Err(err) => {
+                    assert_eq!(err.kind(), io::ErrorKind::WouldBlock);
+                    if bytes.ends_with(&[0]) {
+                        break;
+                    } else {
+                        thread::sleep(Duration::from_millis(1));
+                    }
+                },
+            }
+        }
+
+        assert_eq!(bytes.pop().unwrap(), 0);
+        String::from_utf8(bytes).unwrap()
+    });
+
+    pjh.join().unwrap();
+    let rmsg = cjh.join().unwrap();
+
+    assert_eq!(smsg, rmsg);
+}


