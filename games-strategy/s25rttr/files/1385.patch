From 2065e532c3f55c9281608b9200d96f90d3b5889f Mon Sep 17 00:00:00 2001
From: Johannes Doerfert <johannes@jdoerfert.de>
Date: Sun, 28 Feb 2021 11:22:14 -0600
Subject: [PATCH] Cluster mineable resources in random maps

The random map did place resources purely random in a mountain. This is
not great. Manual maps always cluster resources and we should do so too.
However, having all resources in every mountain is also a good thing for
the balance of the game so we want to keep the clusters small. This is a
try to build small clusters while keeping the ratio as it was before.
---
 libs/s25main/mapGenerator/Resources.cpp | 76 +++++++++++++++++--------
 1 file changed, 51 insertions(+), 25 deletions(-)

diff --git a/libs/s25main/mapGenerator/Resources.cpp b/libs/s25main/mapGenerator/Resources.cpp
index 777334f14..54b5081ca 100644
--- a/libs/s25main/mapGenerator/Resources.cpp
+++ b/libs/s25main/mapGenerator/Resources.cpp
@@ -177,39 +177,65 @@ namespace rttr { namespace mapGenerator {
     {
         const auto& textures = map.textureMap;
         auto& resources = map.resources;
+        struct MineableResourceInfo
+        {
+            // The current "budget", that is, how many many are we over, or under, compared to the desired distribution.
+            int budget = 0;
+            // The ratio is the user defined ratio for this resource.
+            int ratio;
+            // The resource encoding
+            libsiedler2::Resource resource;
+            mineableResourceInfo(int ratio, libsiedler2::Resource resource) : ratio(ratio), resource(resource) {}
+        };
+        mineableResourceInfo mRIs[4] = {mineableResourceInfo(settings.ratioCoal, libsiedler2::R_Coal),
+                                        mineableResourceInfo(settings.ratioGold, libsiedler2::R_Gold),
+                                        mineableResourceInfo(settings.ratioIron, libsiedler2::R_Iron),
+                                        mineableResourceInfo(settings.ratioGranite, libsiedler2::R_Granite)};
         int total = settings.ratioCoal + settings.ratioGold + settings.ratioIron + settings.ratioGranite;
 
         RTTR_FOREACH_PT(MapPoint, map.size)
         {
             if(textures.All(pt, IsMinableMountain))
             {
+                int ratio = 0;
                 int randomNumber = rnd.RandomValue(1, total);
-                int ratio = settings.ratioGold;
-
-                if(randomNumber < ratio)
-                {
-                    resources[pt] = libsiedler2::R_Gold + rnd.RandomValue(0, 8);
-                    continue;
-                }
-
-                ratio += settings.ratioCoal;
-                if(randomNumber < ratio)
-                {
-                    resources[pt] = libsiedler2::R_Coal + rnd.RandomValue(0, 8);
-                    continue;
-                }
-
-                ratio += settings.ratioIron;
-                if(randomNumber < ratio)
-                {
-                    resources[pt] = libsiedler2::R_Iron + rnd.RandomValue(0, 8);
-                    continue;
-                }
-
-                ratio += settings.ratioGranite;
-                if(randomNumber < ratio)
+                for(auto mRI : mRIs)
                 {
-                    resources[pt] = libsiedler2::R_Granite + rnd.RandomValue(0, 8);
+                    ratio += mRI.ratio;
+
+                    // Wrong resource, look further.
+                    if(randomNumber > ratio)
+                        continue;
+
+                    // Right resource, adjust and check the budget.
+                    ++mRI.budget;
+                    if(mRI.budget <= 0)
+                        break;
+
+                    // Budget is positive, avoid overwriting existing clusters though
+                    if(resources[pt])
+                        continue;
+
+                    // Cluster the resource around the map point.
+                    for(int xd = -4; xd <= 4; ++xd)
+                    {
+                        for(int yd = -4; yd <= 4; ++yd)
+                        {
+                            MapPoint pt_d(pt.x + xd, pt.y + yd);
+                            // Avoid out of bound accesses.
+                            if(pt_d.x >= map.size.x || pt_d.y >= map.size.y)
+                                continue;
+
+                            // Only place it on mines that have no resource yet, adjust the budget for each placed
+                            // resource.
+                            if(textures.All(pt_d, IsMinableMountain) && !resources[pt_d])
+                            {
+                                --mRI.budget;
+                                resources[pt_d] = mRI.resource + rnd.RandomValue(1, 8);
+                            }
+                        }
+                    }
+                    break;
                 }
             } else if(textures.All(pt, IsWater))
             {
