From c29cf9580a48548327f61e35f7f5ded396571e36 Mon Sep 17 00:00:00 2001
From: Flamefire <Flamefire@users.noreply.github.com>
Date: Sun, 11 Aug 2019 22:01:46 +0200
Subject: [PATCH] Rework ColorARGB to ColorBGRA

---
 libs/s25main/IngameMinimap.cpp                |  6 ++--
 libs/s25main/Loader.cpp                       | 10 +++---
 libs/s25main/Minimap.cpp                      |  6 ++--
 libs/s25main/WindowManager.cpp                |  4 +--
 libs/s25main/ogl/glArchivItem_Bitmap.cpp      |  4 +--
 .../ogl/glArchivItem_Bitmap_Direct.cpp        |  6 ++--
 libs/s25main/ogl/glArchivItem_Bitmap_Direct.h |  4 +--
 .../ogl/glArchivItem_Bitmap_Player.cpp        |  4 +--
 libs/s25main/ogl/glArchivItem_Font.cpp        |  6 ++--
 libs/s25main/ogl/glSmartBitmap.cpp            | 14 ++++----
 libs/s25main/ogl/glSmartBitmap.h              |  4 +--
 libs/s25main/ogl/glTexturePacker.cpp          |  6 ++--
 libs/s25main/ogl/glTexturePacker.h            |  4 +--
 libs/s25main/ogl/glTexturePackerNode.cpp      |  4 +--
 libs/s25main/ogl/glTexturePackerNode.h        |  4 +--
 libs/s25main/ogl/saveBitmap.cpp               |  2 +-
 libs/s25main/ogl/saveBitmap.h                 |  4 +--
 tests/s25Main/UI/testSmartBitmap.cpp          | 34 +++++++++----------
 tests/s25Main/UI/testTexturePacker.cpp        |  4 +--
 19 files changed, 65 insertions(+), 65 deletions(-)

diff --git a/libs/s25main/IngameMinimap.cpp b/libs/s25main/IngameMinimap.cpp
index c38a2a6c1..43e3c1a1e 100644
--- a/libs/s25main/IngameMinimap.cpp
+++ b/libs/s25main/IngameMinimap.cpp
@@ -23,7 +23,7 @@
 #include "world/GameWorldViewer.h"
 #include "gameData/MinimapConsts.h"
 #include "gameData/TerrainDesc.h"
-#include "libsiedler2/ColorARGB.h"
+#include "libsiedler2/ColorBGRA.h"
 
 IngameMinimap::IngameMinimap(const GameWorldViewer& gwv)
     : Minimap(gwv.GetWorld().GetSize()), gwv(gwv), nodes_updated(GetMapSize().x * GetMapSize().y, false),
@@ -230,7 +230,7 @@ void IngameMinimap::BeforeDrawing()
                 {
                     unsigned color = CalcPixelColor(it, t);
                     DrawPoint texPos((it.x * 2 + t + (it.y & 1)) % (GetMapSize().x * 2), it.y);
-                    map.updatePixel(texPos, libsiedler2::ColorARGB(color));
+                    map.updatePixel(texPos, libsiedler2::ColorBGRA(color));
                 }
                 nodes_updated[GetMMIdx(it)] = false;
             }
@@ -268,7 +268,7 @@ void IngameMinimap::UpdateAll(const DrawnObject drawn_object)
             {
                 unsigned color = CalcPixelColor(pt, t);
                 DrawPoint texPos((pt.x * 2 + t + (pt.y & 1)) % (GetMapSize().x * 2), pt.y);
-                map.updatePixel(texPos, libsiedler2::ColorARGB(color));
+                map.updatePixel(texPos, libsiedler2::ColorBGRA(color));
             }
         }
     }
diff --git a/libs/s25main/Loader.cpp b/libs/s25main/Loader.cpp
index 9e60e7f55..845319069 100644
--- a/libs/s25main/Loader.cpp
+++ b/libs/s25main/Loader.cpp
@@ -42,7 +42,7 @@
 #include "libsiedler2/ArchivItem_PaletteAnimation.h"
 #include "libsiedler2/ArchivItem_Text.h"
 #include "libsiedler2/ErrorCodes.h"
-#include "libsiedler2/PixelBufferARGB.h"
+#include "libsiedler2/PixelBufferBGRA.h"
 #include "libsiedler2/PixelBufferPaletted.h"
 #include "libsiedler2/libsiedler2.h"
 #include "libutil/Log.h"
@@ -283,14 +283,14 @@ void Loader::LoadDummyGUIFiles()
     for(unsigned id = 4; id < 36; id++)
     {
         auto bmp = std::make_unique<glArchivItem_Bitmap_RLE>();
-        libsiedler2::PixelBufferARGB buffer(1, 1);
+        libsiedler2::PixelBufferBGRA buffer(1, 1);
         bmp->create(buffer);
         resource.set(id, std::move(bmp));
     }
     for(unsigned id = 36; id < 57; id++)
     {
         auto bmp = std::make_unique<glArchivItem_Bitmap_Raw>();
-        libsiedler2::PixelBufferARGB buffer(1, 1);
+        libsiedler2::PixelBufferBGRA buffer(1, 1);
         bmp->create(buffer);
         resource.set(id, std::move(bmp));
     }
@@ -298,7 +298,7 @@ void Loader::LoadDummyGUIFiles()
     for(unsigned id = 0; id < 264; id++)
     {
         auto bmp = std::make_unique<glArchivItem_Bitmap_Raw>();
-        libsiedler2::PixelBufferARGB buffer(1, 1);
+        libsiedler2::PixelBufferBGRA buffer(1, 1);
         bmp->create(buffer);
         io.push(std::move(bmp));
     }
@@ -306,7 +306,7 @@ void Loader::LoadDummyGUIFiles()
     libsiedler2::Archiv& fonts = files_["outline_fonts"].archiv;
     auto* palette = GetPaletteN("colors");
     fonts.alloc(3);
-    libsiedler2::PixelBufferARGB buffer(15, 16);
+    libsiedler2::PixelBufferBGRA buffer(15, 16);
     for(unsigned i = 0; i < 3; i++)
     {
         auto font = std::make_unique<glArchivItem_Font>();
diff --git a/libs/s25main/Minimap.cpp b/libs/s25main/Minimap.cpp
index 0066206f8..a09f19c3d 100644
--- a/libs/s25main/Minimap.cpp
+++ b/libs/s25main/Minimap.cpp
@@ -17,7 +17,7 @@
 
 #include "rttrDefines.h" // IWYU pragma: keep
 #include "Minimap.h"
-#include "libsiedler2/PixelBufferARGB.h"
+#include "libsiedler2/PixelBufferBGRA.h"
 
 Minimap::Minimap(const MapExtent& mapSize) : mapSize(mapSize) {}
 
@@ -26,14 +26,14 @@ void Minimap::CreateMapTexture()
     map.DeleteTexture();
 
     /// Buffer für die Daten erzeugen
-    libsiedler2::PixelBufferARGB buffer(mapSize.x * 2, mapSize.y);
+    libsiedler2::PixelBufferBGRA buffer(mapSize.x * 2, mapSize.y);
 
     RTTR_FOREACH_PT(MapPoint, mapSize)
     {
         // Die 2. Terraindreiecke durchgehen
         for(unsigned t = 0; t < 2; ++t)
         {
-            libsiedler2::ColorARGB color(CalcPixelColor(pt, t));
+            libsiedler2::ColorBGRA color(CalcPixelColor(pt, t));
             unsigned xCoord = (pt.x * 2 + t + (pt.y & 1)) % buffer.getWidth();
             buffer.set(xCoord, pt.y, color);
         }
diff --git a/libs/s25main/WindowManager.cpp b/libs/s25main/WindowManager.cpp
index ab6fcedad..eacab0966 100644
--- a/libs/s25main/WindowManager.cpp
+++ b/libs/s25main/WindowManager.cpp
@@ -34,7 +34,7 @@
 #include "ogl/glArchivItem_Font.h"
 #include "ogl/saveBitmap.h"
 #include "gameData/const_gui_ids.h"
-#include "libsiedler2/PixelBufferARGB.h"
+#include "libsiedler2/PixelBufferBGRA.h"
 #include "libutil/Log.h"
 #include "libutil/MyTime.h"
 #include <algorithm>
@@ -784,7 +784,7 @@ void WindowManager::SetActiveWindow(Window& wnd)
 
 void WindowManager::TakeScreenshot()
 {
-    libsiedler2::PixelBufferARGB buffer(curRenderSize.x, curRenderSize.y);
+    libsiedler2::PixelBufferBGRA buffer(curRenderSize.x, curRenderSize.y);
     glReadPixels(0, 0, curRenderSize.x, curRenderSize.y, GL_BGRA, GL_UNSIGNED_BYTE, buffer.getPixelPtr());
     bfs::path outFilepath = bfs::path(RTTRCONFIG.ExpandPath(FILE_PATHS[100])) / (s25util::Time::FormatTime("%Y-%m-%d_%H-%i-%s") + ".bmp");
     try
diff --git a/libs/s25main/ogl/glArchivItem_Bitmap.cpp b/libs/s25main/ogl/glArchivItem_Bitmap.cpp
index f48c89962..57c2d6ea1 100644
--- a/libs/s25main/ogl/glArchivItem_Bitmap.cpp
+++ b/libs/s25main/ogl/glArchivItem_Bitmap.cpp
@@ -19,7 +19,7 @@
 #include "glArchivItem_Bitmap.h"
 #include "Point.h"
 #include "drivers/VideoDriverWrapper.h"
-#include "libsiedler2/PixelBufferARGB.h"
+#include "libsiedler2/PixelBufferBGRA.h"
 #include <glad/glad.h>
 
 glArchivItem_Bitmap::glArchivItem_Bitmap() = default;
@@ -112,7 +112,7 @@ void glArchivItem_Bitmap::FillTexture()
     int iformat = GetInternalFormat(), dformat = GL_BGRA;
 
     const Extent texSize = GetTexSize();
-    libsiedler2::PixelBufferARGB buffer(texSize.x, texSize.y);
+    libsiedler2::PixelBufferBGRA buffer(texSize.x, texSize.y);
     print(buffer);
     glTexImage2D(GL_TEXTURE_2D, 0, iformat, texSize.x, texSize.y, 0, dformat, GL_UNSIGNED_BYTE, buffer.getPixelPtr());
 }
diff --git a/libs/s25main/ogl/glArchivItem_Bitmap_Direct.cpp b/libs/s25main/ogl/glArchivItem_Bitmap_Direct.cpp
index bcb728b74..770ddfe72 100644
--- a/libs/s25main/ogl/glArchivItem_Bitmap_Direct.cpp
+++ b/libs/s25main/ogl/glArchivItem_Bitmap_Direct.cpp
@@ -18,7 +18,7 @@
 #include "rttrDefines.h" // IWYU pragma: keep
 #include "glArchivItem_Bitmap_Direct.h"
 #include "drivers/VideoDriverWrapper.h"
-#include "libsiedler2/PixelBufferARGB.h"
+#include "libsiedler2/PixelBufferBGRA.h"
 #include <glad/glad.h>
 #include <stdexcept>
 
@@ -45,7 +45,7 @@ void glArchivItem_Bitmap_Direct::endUpdate()
     if(prodOfComponents(areaToUpdate_.getSize()) == 0 || !GetTexNoCreate())
         return;
 
-    libsiedler2::PixelBufferARGB buffer(areaToUpdate_.getSize().x, areaToUpdate_.getSize().y);
+    libsiedler2::PixelBufferBGRA buffer(areaToUpdate_.getSize().x, areaToUpdate_.getSize().y);
     Position origin = areaToUpdate_.getOrigin();
     int ec = print(buffer, nullptr, 0, 0, origin.x, origin.y);
     RTTR_Assert(ec == 0);
@@ -54,7 +54,7 @@ void glArchivItem_Bitmap_Direct::endUpdate()
                     buffer.getPixelPtr());
 }
 
-void glArchivItem_Bitmap_Direct::updatePixel(const DrawPoint& pos, const libsiedler2::ColorARGB& clr)
+void glArchivItem_Bitmap_Direct::updatePixel(const DrawPoint& pos, const libsiedler2::ColorBGRA& clr)
 {
     RTTR_Assert(isUpdating_);
     RTTR_Assert(pos.x >= 0 && pos.y >= 0);
diff --git a/libs/s25main/ogl/glArchivItem_Bitmap_Direct.h b/libs/s25main/ogl/glArchivItem_Bitmap_Direct.h
index ca9111f5c..09441725c 100644
--- a/libs/s25main/ogl/glArchivItem_Bitmap_Direct.h
+++ b/libs/s25main/ogl/glArchivItem_Bitmap_Direct.h
@@ -23,7 +23,7 @@
 #include "glArchivItem_Bitmap.h"
 
 namespace libsiedler2 {
-struct ColorARGB;
+struct ColorBGRA;
 }
 
 /// Klasse für GL-Direct-Bitmaps.
@@ -39,7 +39,7 @@ class glArchivItem_Bitmap_Direct : public glArchivItem_Bitmap //-V690
     /// Call after updating texture
     void endUpdate();
     /// Updates a pixels color
-    void updatePixel(const DrawPoint& pos, const libsiedler2::ColorARGB& clr);
+    void updatePixel(const DrawPoint& pos, const libsiedler2::ColorBGRA& clr);
 
     /// lädt die Bilddaten aus einer Datei.
     int load(std::istream& /*file*/, const libsiedler2::ArchivItem_Palette* /*palette*/) override { return 254; }
diff --git a/libs/s25main/ogl/glArchivItem_Bitmap_Player.cpp b/libs/s25main/ogl/glArchivItem_Bitmap_Player.cpp
index f37b88acc..67d0a3fad 100644
--- a/libs/s25main/ogl/glArchivItem_Bitmap_Player.cpp
+++ b/libs/s25main/ogl/glArchivItem_Bitmap_Player.cpp
@@ -20,7 +20,7 @@
 #include "Loader.h"
 #include "Point.h"
 #include "drivers/VideoDriverWrapper.h"
-#include "libsiedler2/PixelBufferARGB.h"
+#include "libsiedler2/PixelBufferBGRA.h"
 #include <glad/glad.h>
 
 namespace {
@@ -122,7 +122,7 @@ void glArchivItem_Bitmap_Player::FillTexture()
     int iformat = GetInternalFormat(), dformat = GL_BGRA; // GL_BGRA_EXT;
 
     Extent texSize = GetTexSize();
-    libsiedler2::PixelBufferARGB buffer(texSize.x, texSize.y);
+    libsiedler2::PixelBufferBGRA buffer(texSize.x, texSize.y);
 
     print(buffer, palette, 128, 0, 0, 0, 0, 0, 0, false);
     print(buffer, palette, 128, texSize.x / 2u, 0, 0, 0, 0, 0, true);
diff --git a/libs/s25main/ogl/glArchivItem_Font.cpp b/libs/s25main/ogl/glArchivItem_Font.cpp
index cc7219524..99d38573f 100644
--- a/libs/s25main/ogl/glArchivItem_Font.cpp
+++ b/libs/s25main/ogl/glArchivItem_Font.cpp
@@ -24,7 +24,7 @@
 #include "helpers/containerUtils.h"
 #include "libsiedler2/ArchivItem_Bitmap_Player.h"
 #include "libsiedler2/IAllocator.h"
-#include "libsiedler2/PixelBufferARGB.h"
+#include "libsiedler2/PixelBufferBGRA.h"
 #include "libsiedler2/libsiedler2.h"
 #include "libutil/Log.h"
 #include <utf8.h>
@@ -568,8 +568,8 @@ void glArchivItem_Font::initFont()
 
     constexpr Extent spacing(1, 1);
     Extent texSize = (Extent(dx, dy) + spacing * 2u) * Extent(numCharsPerLine, numLines) + spacing * 2u;
-    libsiedler2::PixelBufferARGB bufferWithOutline(texSize.x, texSize.y);
-    libsiedler2::PixelBufferARGB bufferNoOutline(texSize.x, texSize.y);
+    libsiedler2::PixelBufferBGRA bufferWithOutline(texSize.x, texSize.y);
+    libsiedler2::PixelBufferBGRA bufferNoOutline(texSize.x, texSize.y);
 
     const libsiedler2::ArchivItem_Palette* const palette = LOADER.GetPaletteN("colors");
     Position curPos(spacing);
diff --git a/libs/s25main/ogl/glSmartBitmap.cpp b/libs/s25main/ogl/glSmartBitmap.cpp
index fc08b0df7..fb96fedde 100644
--- a/libs/s25main/ogl/glSmartBitmap.cpp
+++ b/libs/s25main/ogl/glSmartBitmap.cpp
@@ -22,7 +22,7 @@
 #include "ogl/glBitmapItem.h"
 #include "libsiedler2/ArchivItem_Bitmap.h"
 #include "libsiedler2/ArchivItem_Bitmap_Player.h"
-#include "libsiedler2/PixelBufferARGB.h"
+#include "libsiedler2/PixelBufferBGRA.h"
 #include "libutil/colors.h"
 #include <glad/glad.h>
 #include <limits>
@@ -113,7 +113,7 @@ void glSmartBitmap::calcDimensions()
     size_ = Extent(origin_ + maxPos);
 }
 
-void glSmartBitmap::drawTo(libsiedler2::PixelBufferARGB& buffer, const Extent& bufOffset) const
+void glSmartBitmap::drawTo(libsiedler2::PixelBufferBGRA& buffer, const Extent& bufOffset) const
 {
     libsiedler2::ArchivItem_Palette* p_colors = LOADER.GetPaletteN("colors");
     libsiedler2::ArchivItem_Palette* p_5 = LOADER.GetPaletteN("pal5");
@@ -127,7 +127,7 @@ void glSmartBitmap::drawTo(libsiedler2::PixelBufferARGB& buffer, const Extent& b
 
         if(bmpItem.type == TYPE_ARCHIVITEM_BITMAP_SHADOW)
         {
-            libsiedler2::PixelBufferARGB tmp(size_.x, size_.y);
+            libsiedler2::PixelBufferBGRA tmp(size_.x, size_.y);
 
             dynamic_cast<libsiedler2::baseArchivItem_Bitmap*>(bmpItem.bmp) //-V522
               ->print(tmp, p_5, offset.x, offset.y, bmpItem.pos.x, bmpItem.pos.y, bmpItem.size.x, bmpItem.size.y);
@@ -139,7 +139,7 @@ void glSmartBitmap::drawTo(libsiedler2::PixelBufferARGB& buffer, const Extent& b
                 for(unsigned x = 0; x < size_.x; ++x)
                 {
                     if(tmp.get(tmpIdx).getAlpha() != 0x00 && buffer.get(idx).getAlpha() == 0x00)
-                        buffer.set(idx, libsiedler2::ColorARGB(0x40, 0, 0, 0));
+                        buffer.set(idx, libsiedler2::ColorBGRA(0, 0, 0, 0x40));
                     idx++;
                     tmpIdx++;
                 }
@@ -154,7 +154,7 @@ void glSmartBitmap::drawTo(libsiedler2::PixelBufferARGB& buffer, const Extent& b
         } else
         {
             // There is a player bitmap -> First write to temp buffer
-            libsiedler2::PixelBufferARGB tmp(size_.x, size_.y);
+            libsiedler2::PixelBufferBGRA tmp(size_.x, size_.y);
             if(bmpItem.type == TYPE_ARCHIVITEM_BITMAP)
             {
                 dynamic_cast<libsiedler2::baseArchivItem_Bitmap*>(bmpItem.bmp)
@@ -180,7 +180,7 @@ void glSmartBitmap::drawTo(libsiedler2::PixelBufferARGB& buffer, const Extent& b
                         // Copy to buffer
                         buffer.set(idx, tmp.get(tmpIdx));
                         // Reset player color to transparent
-                        buffer.set(idx + size_.x, libsiedler2::ColorARGB(0));
+                        buffer.set(idx + size_.x, libsiedler2::ColorBGRA());
                     }
                     ++idx;
                     ++tmpIdx;
@@ -212,7 +212,7 @@ void glSmartBitmap::generateTexture()
 
     const Extent bufSize = VIDEODRIVER.calcPreferredTextureSize(getRequiredTexSize());
 
-    libsiedler2::PixelBufferARGB buffer(bufSize.x, bufSize.y);
+    libsiedler2::PixelBufferBGRA buffer(bufSize.x, bufSize.y);
     drawTo(buffer);
 
     VIDEODRIVER.BindTexture(texture);
diff --git a/libs/s25main/ogl/glSmartBitmap.h b/libs/s25main/ogl/glSmartBitmap.h
index b7f8a6c43..9b2da0e96 100644
--- a/libs/s25main/ogl/glSmartBitmap.h
+++ b/libs/s25main/ogl/glSmartBitmap.h
@@ -28,7 +28,7 @@
 namespace libsiedler2 {
 class baseArchivItem_Bitmap;
 class ArchivItem_Bitmap_Player;
-class PixelBufferARGB;
+class PixelBufferBGRA;
 } // namespace libsiedler2
 
 class glBitmapItem;
@@ -77,7 +77,7 @@ class glSmartBitmap : public ITexture
     void draw(DrawPoint drawPt, unsigned color = 0xFFFFFFFF, unsigned player_color = 0);
     void drawPercent(DrawPoint drawPt, unsigned percent, unsigned color = 0xFFFFFFFF, unsigned player_color = 0);
     /// Draw the bitmap(s) to the specified buffer at the position starting at bufOffset (must be positive)
-    void drawTo(libsiedler2::PixelBufferARGB& buffer, const Extent& bufOffset = Extent(0, 0)) const;
+    void drawTo(libsiedler2::PixelBufferBGRA& buffer, const Extent& bufOffset = Extent(0, 0)) const;
 
     void add(libsiedler2::baseArchivItem_Bitmap* bmp, bool transferOwnership = false);
     void add(libsiedler2::ArchivItem_Bitmap_Player* bmp, bool transferOwnership = false);
diff --git a/libs/s25main/ogl/glTexturePacker.cpp b/libs/s25main/ogl/glTexturePacker.cpp
index f734e20c5..5c67f0625 100644
--- a/libs/s25main/ogl/glTexturePacker.cpp
+++ b/libs/s25main/ogl/glTexturePacker.cpp
@@ -21,7 +21,7 @@
 #include "ogl/glSmartBitmap.h"
 #include "ogl/glTexturePackerNode.h"
 #include "ogl/saveBitmap.h"
-#include "libsiedler2/PixelBufferARGB.h"
+#include "libsiedler2/PixelBufferBGRA.h"
 #include <glad/glad.h>
 #include <algorithm>
 #include <utility>
@@ -74,7 +74,7 @@ bool glTexturePacker::packHelper(std::vector<glSmartBitmap*>& list)
             // list to store bitmaps we could not fit in our current texture
             std::vector<glSmartBitmap*> left;
 
-            libsiedler2::PixelBufferARGB buffer(curSize.x, curSize.y);
+            libsiedler2::PixelBufferBGRA buffer(curSize.x, curSize.y);
 
             // try storing bitmaps in the big texture
             for(glSmartBitmap* bmp : list)
@@ -186,7 +186,7 @@ bool glTexture::checkSize(const Extent& size)
     return resultWidth > 0;
 }
 
-bool glTexture::uploadData(const libsiedler2::PixelBufferARGB& buffer)
+bool glTexture::uploadData(const libsiedler2::PixelBufferBGRA& buffer)
 {
     if(!handle)
         return false;
diff --git a/libs/s25main/ogl/glTexturePacker.h b/libs/s25main/ogl/glTexturePacker.h
index b4a830d1a..9375ff1b9 100644
--- a/libs/s25main/ogl/glTexturePacker.h
+++ b/libs/s25main/ogl/glTexturePacker.h
@@ -24,7 +24,7 @@
 class glSmartBitmap;
 
 namespace libsiedler2 {
-class PixelBufferARGB;
+class PixelBufferBGRA;
 }
 
 class glTexture
@@ -46,7 +46,7 @@ class glTexture
 
     void bind();
     bool checkSize(const Extent&);
-    bool uploadData(const libsiedler2::PixelBufferARGB&);
+    bool uploadData(const libsiedler2::PixelBufferBGRA&);
 };
 
 class glTexturePacker
diff --git a/libs/s25main/ogl/glTexturePackerNode.cpp b/libs/s25main/ogl/glTexturePackerNode.cpp
index 7f639a09c..9007ed665 100644
--- a/libs/s25main/ogl/glTexturePackerNode.cpp
+++ b/libs/s25main/ogl/glTexturePackerNode.cpp
@@ -18,9 +18,9 @@
 #include "rttrDefines.h" // IWYU pragma: keep
 #include "glTexturePackerNode.h"
 #include "ogl/glSmartBitmap.h"
-#include "libsiedler2/PixelBufferARGB.h"
+#include "libsiedler2/PixelBufferBGRA.h"
 
-bool glTexturePackerNode::insert(glSmartBitmap* b, libsiedler2::PixelBufferARGB& buffer, std::vector<glTexturePackerNode*>& todo)
+bool glTexturePackerNode::insert(glSmartBitmap* b, libsiedler2::PixelBufferBGRA& buffer, std::vector<glTexturePackerNode*>& todo)
 {
     todo.clear();
 
diff --git a/libs/s25main/ogl/glTexturePackerNode.h b/libs/s25main/ogl/glTexturePackerNode.h
index c2a9c45bf..ca0a0c5ec 100644
--- a/libs/s25main/ogl/glTexturePackerNode.h
+++ b/libs/s25main/ogl/glTexturePackerNode.h
@@ -23,7 +23,7 @@
 
 class glSmartBitmap;
 namespace libsiedler2 {
-class PixelBufferARGB;
+class PixelBufferBGRA;
 } // namespace libsiedler2
 
 class glTexturePackerNode
@@ -41,7 +41,7 @@ class glTexturePackerNode
     glTexturePackerNode(const Extent& size) : pos(0, 0), size(size), bmp(nullptr) { child[0] = child[1] = nullptr; }
     /// Find a position in the buffer to draw the bitmap starting at this node
     /// todo list is cleared and used to avoid frequent allocations
-    bool insert(glSmartBitmap* b, libsiedler2::PixelBufferARGB& buffer, std::vector<glTexturePackerNode*>& todo);
+    bool insert(glSmartBitmap* b, libsiedler2::PixelBufferBGRA& buffer, std::vector<glTexturePackerNode*>& todo);
     void destroy(unsigned reserve = 0);
 };
 
diff --git a/libs/s25main/ogl/saveBitmap.cpp b/libs/s25main/ogl/saveBitmap.cpp
index 5117038ab..28eedda56 100644
--- a/libs/s25main/ogl/saveBitmap.cpp
+++ b/libs/s25main/ogl/saveBitmap.cpp
@@ -22,7 +22,7 @@
 #include "libsiedler2/libsiedler2.h"
 #include <stdexcept>
 
-void saveBitmap(const libsiedler2::PixelBufferARGB& buffer, const boost::filesystem::path& path)
+void saveBitmap(const libsiedler2::PixelBufferBGRA& buffer, const boost::filesystem::path& path)
 {
     auto bmp = std::make_unique<libsiedler2::ArchivItem_Bitmap_Raw>();
     bmp->create(buffer);
diff --git a/libs/s25main/ogl/saveBitmap.h b/libs/s25main/ogl/saveBitmap.h
index 9b8b2aab0..cb47dc7c8 100644
--- a/libs/s25main/ogl/saveBitmap.h
+++ b/libs/s25main/ogl/saveBitmap.h
@@ -18,9 +18,9 @@
 #ifndef SAVE_BITMAP_H__
 #define SAVE_BITMAP_H__
 
-#include <libsiedler2/PixelBufferARGB.h>
+#include <libsiedler2/PixelBufferBGRA.h>
 #include <boost/filesystem/path.hpp>
 
-void saveBitmap(const libsiedler2::PixelBufferARGB&, const boost::filesystem::path&);
+void saveBitmap(const libsiedler2::PixelBufferBGRA&, const boost::filesystem::path&);
 
 #endif
diff --git a/tests/s25Main/UI/testSmartBitmap.cpp b/tests/s25Main/UI/testSmartBitmap.cpp
index 7011fb309..d1df5d9fc 100644
--- a/tests/s25Main/UI/testSmartBitmap.cpp
+++ b/tests/s25Main/UI/testSmartBitmap.cpp
@@ -21,7 +21,7 @@
 #include <libsiedler2/ArchivItem_Bitmap_Player.h>
 #include <libsiedler2/ArchivItem_Bitmap_Raw.h>
 #include <libsiedler2/ArchivItem_Palette.h>
-#include <libsiedler2/PixelBufferARGB.h>
+#include <libsiedler2/PixelBufferBGRA.h>
 #include <rttr/test/random.hpp>
 #include <boost/test/unit_test.hpp>
 #include <iomanip>
@@ -31,10 +31,10 @@
 using namespace libsiedler2;
 
 namespace libsiedler2 {
-static std::ostream& boost_test_print_type(std::ostream& os, const ColorARGB color)
+static std::ostream& boost_test_print_type(std::ostream& os, const ColorBGRA color)
 {
     os.imbue(std::locale::classic());
-    return os << std::hex << std::setw(8) << color.clrValue;
+    return os << std::hex << std::setw(2) << color.value[3] << color.value[2] << color.value[1] << color.value[0];
 }
 } // namespace libsiedler2
 
@@ -66,7 +66,7 @@ std::unique_ptr<ArchivItem_Bitmap_Player> createRandPlayerBmp(unsigned percentTr
     bmp->setNx(offset.x);
     bmp->setNy(offset.y);
     using rttr::test::randomValue;
-    PixelBufferARGB buffer(size.x, size.y);
+    PixelBufferBGRA buffer(size.x, size.y);
     RTTR_FOREACH_PT(Position, size)
     {
         if(randomValue(1u, 100u) > percentTransparent)
@@ -94,8 +94,8 @@ BOOST_AUTO_TEST_CASE(CreateRandBmp_Works)
 BOOST_AUTO_TEST_CASE(PrintColor)
 {
     std::stringstream s;
-    boost_test_print_type(s, ColorARGB(0x42, 0x13, 0x37, 0x99));
-    BOOST_TEST(s.str() == "42133799");
+    boost_test_print_type(s, ColorBGRA(0x42, 0x13, 0x37, 0x99));
+    BOOST_TEST(s.str() == "99371342");
 }
 
 BOOST_AUTO_TEST_CASE(RegularBitmap)
@@ -104,7 +104,7 @@ BOOST_AUTO_TEST_CASE(RegularBitmap)
     auto bmpSrc = createRandBmp(0);
     const Extent size(bmpSrc->getWidth(), bmpSrc->getHeight());
     const auto offset = rttr::test::randomPoint<Extent>(0, 100);
-    PixelBufferARGB buffer(size.x * 2 + offset.x, size.y * 2 + offset.y);
+    PixelBufferBGRA buffer(size.x * 2 + offset.x, size.y * 2 + offset.y);
     glSmartBitmap smartBmp;
     smartBmp.add(bmpSrc.get());
     BOOST_TEST(smartBmp.GetSize() == size);
@@ -116,7 +116,7 @@ BOOST_AUTO_TEST_CASE(RegularBitmap)
     {
         const Position bmpPos = pt - offset;
         if(bmpPos.x < 0 || bmpPos.y < 0 || bmpPos.x >= iSize.x || bmpPos.y >= iSize.y)
-            BOOST_TEST(buffer.get(pt.x, pt.y) == ColorARGB());
+            BOOST_TEST(buffer.get(pt.x, pt.y) == ColorBGRA());
         else
             BOOST_TEST(buffer.get(pt.x, pt.y) == bmpSrc->getPixel(bmpPos.x, bmpPos.y));
     }
@@ -150,13 +150,13 @@ BOOST_AUTO_TEST_CASE(MultiRegularBitmap)
 
     const auto offset = rttr::test::randomPoint<Extent>(0, 100);
     // Draw to a large buffer (detect pixels at wrong positions)
-    PixelBufferARGB buffer(size.x * 2 + offset.x, size.y * 2 + offset.y);
+    PixelBufferBGRA buffer(size.x * 2 + offset.x, size.y * 2 + offset.y);
     smartBmp.drawTo(buffer, offset);
     RTTR_FOREACH_PT(Position, Extent(buffer.getWidth(), buffer.getHeight()))
     {
         const Position curPos = pt - offset;
         // Bitmaps are drawn in order added, so final pixel value is determined by all bitmaps at that position
-        ColorARGB expectedColor;
+        ColorBGRA expectedColor;
         for(const auto& bmp : bmps)
         {
             // Drawing buffer at `pos` - commonOrigin should be equal to drawing bmp at `pos` - origin
@@ -164,7 +164,7 @@ BOOST_AUTO_TEST_CASE(MultiRegularBitmap)
             const Position bmpPos = curPos + curOriginOffset;
             if(bmpPos.x >= 0 && bmpPos.y >= 0 && bmpPos.x < bmp->getWidth() && bmpPos.y < bmp->getHeight())
             {
-                const ColorARGB color = bmp->getPixel(bmpPos.x, bmpPos.y);
+                const ColorBGRA color = bmp->getPixel(bmpPos.x, bmpPos.y);
                 if(color.getAlpha() != 0)
                     expectedColor = color;
             }
@@ -186,12 +186,12 @@ BOOST_AUTO_TEST_CASE(PlayerBitmap)
     BOOST_TEST(smartBmp.GetSize() == size);
     BOOST_TEST(smartBmp.getRequiredTexSize() == Extent(size.x * 2, size.y));
     BOOST_TEST(smartBmp.GetOrigin() == Position(bmp->getNx(), bmp->getNy()));
-    PixelBufferARGB buffer(size.x * 4 + offset.x, size.y * 4 + offset.y);
+    PixelBufferBGRA buffer(size.x * 4 + offset.x, size.y * 4 + offset.y);
     smartBmp.drawTo(buffer, offset);
     RTTR_FOREACH_PT(Position, Extent(buffer.getWidth(), buffer.getHeight()))
     {
         const Position bmpPos = pt - offset;
-        ColorARGB expectedColor;
+        ColorBGRA expectedColor;
         if(bmpPos.x >= 0 && bmpPos.y >= 0 && bmpPos.y < bmp->getHeight())
         {
             if(bmpPos.x >= static_cast<int>(smartBmp.GetSize().x))
@@ -240,7 +240,7 @@ BOOST_AUTO_TEST_CASE(MultiPlayerBitmap)
 
     const auto offset = rttr::test::randomPoint<Extent>(0, 100);
     // Draw to a large buffer (detect pixels at wrong positions)
-    PixelBufferARGB buffer(size.x * 4 + offset.x, size.y * 4 + offset.y);
+    PixelBufferBGRA buffer(size.x * 4 + offset.x, size.y * 4 + offset.y);
     smartBmp.drawTo(buffer, offset);
     const auto* pal = LOADER.GetPaletteN("colors");
     RTTR_FOREACH_PT(Position, Extent(buffer.getWidth(), buffer.getHeight()))
@@ -249,7 +249,7 @@ BOOST_AUTO_TEST_CASE(MultiPlayerBitmap)
         const bool isPlayerClrRegion =
           (curPos.x >= static_cast<int>(smartBmp.GetSize().x) && curPos.x < static_cast<int>(smartBmp.GetSize().x) * 2);
         // Bitmaps are drawn in order added, so final pixel value is determined by all bitmaps at that position
-        ColorARGB expectedColor;
+        ColorBGRA expectedColor;
         for(const auto& bmp : bmps)
         {
             // Drawing buffer at `pos` - commonOrigin should be equal to drawing bmp at `pos` - origin
@@ -257,11 +257,11 @@ BOOST_AUTO_TEST_CASE(MultiPlayerBitmap)
             const Position bmpPos = curPos + curOriginOffset - Extent(isPlayerClrRegion ? smartBmp.GetSize().x : 0, 0);
             if(bmpPos.x >= 0 && bmpPos.y >= 0 && bmpPos.x < bmp->getWidth() && bmpPos.y < bmp->getHeight())
             {
-                const ColorARGB color = bmp->getPixel(bmpPos.x, bmpPos.y);
+                const ColorBGRA color = bmp->getPixel(bmpPos.x, bmpPos.y);
                 if(color.getAlpha() != 0)
                 {
                     // Color overwrite (make transparent) player clr
-                    expectedColor = isPlayerClrRegion ? ColorARGB() : color;
+                    expectedColor = isPlayerClrRegion ? ColorBGRA() : color;
                 }
                 if(bmp->isPlayerColor(bmpPos.x, bmpPos.y))
                     expectedColor = pal->get(bmp->getPlayerColorIdx(bmpPos.x, bmpPos.y) + 128);
diff --git a/tests/s25Main/UI/testTexturePacker.cpp b/tests/s25Main/UI/testTexturePacker.cpp
index d019d2e5f..6d8e4af6c 100644
--- a/tests/s25Main/UI/testTexturePacker.cpp
+++ b/tests/s25Main/UI/testTexturePacker.cpp
@@ -20,7 +20,7 @@
 #include "ogl/glTexturePacker.h"
 #include "uiHelper/uiHelpers.hpp"
 #include "libsiedler2/ArchivItem_Bitmap_Raw.h"
-#include "libsiedler2/PixelBufferARGB.h"
+#include "libsiedler2/PixelBufferBGRA.h"
 #include <boost/test/unit_test.hpp>
 #include <Rect.h>
 #include <array>
@@ -34,7 +34,7 @@ BOOST_AUTO_TEST_CASE(SizeAndPosCorrect)
     glTexturePacker packer;
     for(unsigned i = 0; i < bmps.size(); ++i)
     {
-        libsiedler2::PixelBufferARGB buffer(5 + i, 11 + i * 3, libsiedler2::ColorARGB(0xFFFFFFFF));
+        libsiedler2::PixelBufferBGRA buffer(5 + i, 11 + i * 3, libsiedler2::ColorBGRA(0xFFFFFFFF));
         bmps[i].create(buffer);
         smartBmps[i].add(&bmps[i]);
         packer.add(smartBmps[i]);

