diff --git a/external/s25edit/CGame.cpp b/external/s25edit/CGame.cpp
index 1a2f884..6ee5e11 100644
--- a/external/s25edit/CGame.cpp
+++ b/external/s25edit/CGame.cpp
@@ -56,6 +56,14 @@ int CGame::Execute()
     return 0;
 }
 
+void CGame::RenderPresent()
+{
+    SDL_UpdateTexture(displayTexture_.get(), nullptr, Surf_Display->pixels, Surf_Display->w * sizeof(Uint32));
+    SDL_RenderClear(renderer_.get());
+    SDL_RenderCopy(renderer_.get(), displayTexture_.get(), nullptr, nullptr);
+    SDL_RenderPresent(renderer_.get());
+}
+
 CMenu* CGame::RegisterMenu(std::unique_ptr<CMenu> Menu)
 {
     for(auto& i : Menus)
diff --git a/external/s25edit/CGame.h b/external/s25edit/CGame.h
index 0962768..43b749d 100644
--- a/external/s25edit/CGame.h
+++ b/external/s25edit/CGame.h
@@ -21,8 +21,10 @@ public:
 
     bool Running;
     bool showLoadScreen;
-    bool useOpenGL = false;
-    SdlSurface Surf_Display, Surf_DisplayGL;
+    SdlSurface Surf_Display;
+    SdlTexture displayTexture_;
+    SdlRenderer renderer_;
+    SdlWindow window_;
 
 private:
 #ifdef _ADMINMODE
@@ -75,6 +77,8 @@ public:
 
     void Render();
 
+    void RenderPresent();
+
     CMenu* RegisterMenu(std::unique_ptr<CMenu> Menu);
     bool UnregisterMenu(CMenu* Menu);
     CWindow* RegisterWindow(std::unique_ptr<CWindow> Window);
@@ -85,7 +89,6 @@ public:
     CMap* getMapObj();
     void delMapObj();
     SDL_Surface* getDisplaySurface() { return Surf_Display.get(); };
-    SDL_Surface* getDisplayGLSurface() { return Surf_DisplayGL.get(); };
     auto getRes() { return GameResolution; }
 };
 
diff --git a/external/s25edit/CGame_Init.cpp b/external/s25edit/CGame_Init.cpp
index 4c1d921..87479cb 100644
--- a/external/s25edit/CGame_Init.cpp
+++ b/external/s25edit/CGame_Init.cpp
@@ -12,31 +12,21 @@
 
 bool CGame::ReCreateWindow()
 {
-    useOpenGL = CSurface::useOpenGL;
-    static char CENTER_ENV[] = "SDL_VIDEO_CENTERED=center";
-    SDL_putenv(CENTER_ENV);
-
-    if(useOpenGL)
-    {
-        SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
-        SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
-        SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);
-        SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
-        SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 1);
-        Surf_DisplayGL.reset(SDL_SetVideoMode(GameResolution.x, GameResolution.y, 32, SDL_OPENGL | (fullscreen ? SDL_FULLSCREEN : 0)));
-        Surf_Display = makeSdlSurface(SDL_SWSURFACE, GameResolution.x, GameResolution.y, 32);
-        if(!Surf_Display || !Surf_DisplayGL)
-            return false;
-    } else
-    {
-        Surf_Display.reset(
-          SDL_SetVideoMode(GameResolution.x, GameResolution.y, 32, SDL_SWSURFACE | SDL_DOUBLEBUF | (fullscreen ? SDL_FULLSCREEN : 0)));
-        Surf_DisplayGL.reset();
-        if(!Surf_Display)
-            return false;
-    }
+    displayTexture_.reset();
+    renderer_.reset();
+    window_.reset();
+    window_.reset(SDL_CreateWindow("Return to the Roots Map editor [BETA]", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
+                                   GameResolution.x, GameResolution.y, fullscreen ? SDL_WINDOW_FULLSCREEN : 0));
+    if(!window_)
+        return false;
+    renderer_.reset(SDL_CreateRenderer(window_.get(), -1, 0));
+    if(!renderer_)
+        return false;
+    displayTexture_ = makeSdlTexture(renderer_, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, GameResolution.x, GameResolution.y);
+    Surf_Display = makeRGBSurface(GameResolution.x, GameResolution.y, true);
+    if(!displayTexture_ || !Surf_Display)
+        return false;
 
-    SDL_WM_SetCaption("Return to the Roots Map editor [BETA]", nullptr);
     SetAppIcon();
     return true;
 }
@@ -45,7 +35,6 @@ bool CGame::Init()
 {
     std::cout << "Return to the Roots Map editor\n";
 
-    SDL_EnableKeyRepeat(100, 100);
     SDL_ShowCursor(SDL_DISABLE);
 
     std::cout << "Create Window...";
@@ -54,7 +43,6 @@ bool CGame::Init()
         std::cout << "failure";
         return false;
     }
-    sge_Update_OFF();
     sge_Lock_OFF();
     CFile::init();
 
@@ -89,7 +77,7 @@ bool CGame::Init()
     auto& surfSplash = global::bmpArray[SPLASHSCREEN_LOADING_S2SCREEN].surface;
     sge_TexturedRect(Surf_Display.get(), 0, 0, Surf_Display->w - 1, 0, 0, Surf_Display->h - 1, Surf_Display->w - 1, Surf_Display->h - 1,
                      surfSplash.get(), 0, 0, surfSplash->w - 1, 0, 0, surfSplash->h - 1, surfSplash->w - 1, surfSplash->h - 1);
-    SDL_Flip(Surf_Display.get());
+    RenderPresent();
 
     GameDataLoader gdLoader(global::worldDesc);
     if(!gdLoader.Load())
diff --git a/external/s25edit/CGame_Render.cpp b/external/s25edit/CGame_Render.cpp
index 05fa4d6..39dd3fd 100644
--- a/external/s25edit/CGame_Render.cpp
+++ b/external/s25edit/CGame_Render.cpp
@@ -26,17 +26,17 @@ void CGame::SetAppIcon()
     SDL_SysWMinfo info;
     // get window handle from SDL
     SDL_VERSION(&info.version);
-    if(SDL_GetWMInfo(&info) != 1)
+    if(SDL_GetWindowWMInfo(window_.get(), &info) != 1)
         return;
-    SendMessage(info.window, WM_SETICON, ICON_BIG, icon);
-    SendMessage(info.window, WM_SETICON, ICON_SMALL, icon);
+    SendMessage(info.info.win.window, WM_SETICON, ICON_BIG, icon);
+    SendMessage(info.info.win.window, WM_SETICON, ICON_SMALL, icon);
 #endif // _WIN32
 }
 
 void CGame::Render()
 {
-    if(Extent(Surf_Display->w, Surf_Display->h) != GameResolution || fullscreen != ((Surf_Display->flags & SDL_FULLSCREEN) != 0)
-       || useOpenGL != CSurface::useOpenGL)
+    if(Extent(Surf_Display->w, Surf_Display->h) != GameResolution
+       || fullscreen != ((SDL_GetWindowFlags(window_.get()) & SDL_WINDOW_FULLSCREEN) != 0))
     {
         ReCreateWindow();
     }
@@ -49,13 +49,7 @@ void CGame::Render()
         sge_TexturedRect(Surf_Display.get(), 0, 0, Surf_Display->w - 1, 0, 0, Surf_Display->h - 1, Surf_Display->w - 1, Surf_Display->h - 1,
                          surfLoadScreen.get(), 0, 0, surfLoadScreen->w - 1, 0, 0, surfLoadScreen->h - 1, surfLoadScreen->w - 1,
                          surfLoadScreen->h - 1);
-
-        if(useOpenGL)
-        {
-            SDL_BlitSurface(Surf_Display.get(), nullptr, Surf_DisplayGL.get(), nullptr);
-            SDL_GL_SwapBuffers();
-        } else
-            SDL_Flip(Surf_Display.get());
+        RenderPresent();
         return;
     }
 
@@ -131,13 +125,7 @@ void CGame::Render()
     }
     CSurface::Draw(Surf_Display, lastFps.getSurface(), 0, 0);
 
-    if(useOpenGL)
-    {
-        SDL_BlitSurface(Surf_Display.get(), nullptr, Surf_DisplayGL.get(), nullptr);
-        SDL_Flip(Surf_DisplayGL.get());
-        SDL_GL_SwapBuffers();
-    } else
-        SDL_Flip(Surf_Display.get());
+    RenderPresent();
 
     if(msWait)
         SDL_Delay(msWait);
diff --git a/external/s25edit/CIO/CButton.cpp b/external/s25edit/CIO/CButton.cpp
index 3372c68..2543ecc 100644
--- a/external/s25edit/CIO/CButton.cpp
+++ b/external/s25edit/CIO/CButton.cpp
@@ -145,7 +145,7 @@ bool CButton::render()
     // if we need a new surface
     if(!Surf_Button)
     {
-        if((Surf_Button = makeSdlSurface(SDL_SWSURFACE, w, h, 32)) == nullptr)
+        if((Surf_Button = makeRGBSurface(w, h)) == nullptr)
             return false;
     }
 
diff --git a/external/s25edit/CIO/CFile.cpp b/external/s25edit/CIO/CFile.cpp
index 68e9392..228076e 100644
--- a/external/s25edit/CIO/CFile.cpp
+++ b/external/s25edit/CIO/CFile.cpp
@@ -435,9 +435,11 @@ bool CFile::open_lbm(const std::string& filename)
     CHECK_READ(libendian::be_read_ui(&length, fp));
 
     // now we are ready to read the picture lines and fill the surface, so lets create one
-    if(!(bmpArray->surface = makeSdlSurface(SDL_SWSURFACE, bmpArray->w, bmpArray->h, 8)))
+    if(!(bmpArray->surface = makePalSurface(bmpArray->w, bmpArray->h, colors)))
+    {
+        std::cerr << "Failed to create surface: " << SDL_GetError() << std::endl;
         return false;
-    SDL_SetPalette(bmpArray->surface.get(), SDL_LOGPAL, colors.data(), 0, colors.size());
+    }
 
     if(compression_flag == 0)
     {
@@ -501,12 +503,12 @@ bool CFile::open_lbm(const std::string& filename)
        || filename.find("TEX7.LBM") != std::string::npos || filename.find("TEXTUR_0.LBM") != std::string::npos
        || filename.find("TEXTUR_3.LBM") != std::string::npos)
     {
-        SDL_SetColorKey(bmpArray->surface.get(), SDL_SRCCOLORKEY, SDL_MapRGB(bmpArray->surface->format, 0, 0, 0));
+        SDL_SetColorKey(bmpArray->surface.get(), SDL_TRUE, SDL_MapRGB(bmpArray->surface->format, 0, 0, 0));
 
         bmpArray++;
-        if((bmpArray->surface = makeSdlSurface(SDL_SWSURFACE, (bmpArray - 1)->w, (bmpArray - 1)->h, 32)))
+        if((bmpArray->surface = makeRGBSurface((bmpArray - 1)->w, (bmpArray - 1)->h)))
         {
-            SDL_SetColorKey(bmpArray->surface.get(), SDL_SRCCOLORKEY, SDL_MapRGB(bmpArray->surface->format, 0, 0, 0));
+            SDL_SetColorKey(bmpArray->surface.get(), SDL_TRUE, SDL_MapRGB(bmpArray->surface->format, 0, 0, 0));
             CSurface::Draw(bmpArray->surface, (bmpArray - 1)->surface, 0, 0);
         } else
             bmpArray--;
@@ -1054,10 +1056,9 @@ bool CFile::read_bob02()
         CHECK_READ(libendian::le_read_us(&starts[y], fp));
 
     // now we are ready to read the picture lines and fill the surface, so lets create one
-    if((bmpArray->surface = makeSdlSurface(SDL_SWSURFACE, bmpArray->w, bmpArray->h, 8)) == nullptr)
+    if((bmpArray->surface = makePalSurface(bmpArray->w, bmpArray->h, palActual->colors)) == nullptr)
         return false;
-    SDL_SetPalette(bmpArray->surface.get(), SDL_LOGPAL, palActual->colors.data(), 0, palActual->colors.size());
-    SDL_SetColorKey(bmpArray->surface.get(), SDL_SRCCOLORKEY | SDL_RLEACCEL, SDL_MapRGB(bmpArray->surface->format, 0, 0, 0));
+    SDL_SetColorKey(bmpArray->surface.get(), SDL_TRUE, SDL_MapRGB(bmpArray->surface->format, 0, 0, 0));
     // SDL_SetAlpha(bmpArray->surface, SDL_SRCALPHA, 128);
 
     // main loop for reading picture lines
@@ -1224,11 +1225,10 @@ bool CFile::read_bob04(int player_color)
         CHECK_READ(libendian::le_read_us(&starts[y], fp));
 
     // now we are ready to read the picture lines and fill the surface, so lets create one
-    if((bmpArray->surface = makeSdlSurface(SDL_SWSURFACE, bmpArray->w, bmpArray->h, 8)) == nullptr)
+    if((bmpArray->surface = makePalSurface(bmpArray->w, bmpArray->h, palActual->colors)) == nullptr)
         return false;
 
-    SDL_SetPalette(bmpArray->surface.get(), SDL_LOGPAL, palActual->colors.data(), 0, palActual->colors.size());
-    SDL_SetColorKey(bmpArray->surface.get(), SDL_SRCCOLORKEY, SDL_MapRGB(bmpArray->surface->format, 0, 0, 0));
+    SDL_SetColorKey(bmpArray->surface.get(), SDL_TRUE, SDL_MapRGB(bmpArray->surface->format, 0, 0, 0));
 
     // main loop for reading picture lines
     for(int y = 0; y < bmpArray->h; y++)
@@ -1363,9 +1363,8 @@ bool CFile::read_bob07()
         CHECK_READ(libendian::le_read_us(&starts[y], fp));
 
     // now we are ready to read the picture lines and fill the surface, so lets create one
-    if((shadowArray->surface = makeSdlSurface(SDL_SWSURFACE, shadowArray->w, shadowArray->h, 8)) == nullptr)
+    if((shadowArray->surface = makePalSurface(shadowArray->w, shadowArray->h, palActual->colors)) == nullptr)
         return false;
-    SDL_SetPalette(shadowArray->surface.get(), SDL_LOGPAL, palActual->colors.data(), 0, palActual->colors.size());
     // SDL_SetAlpha(shadowArray->surface, SDL_SRCALPHA, 128);
 
     // main loop for reading picture lines
@@ -1472,9 +1471,8 @@ bool CFile::read_bob14()
         return true;
 
     // now we are ready to read the picture lines and fill the surface, so lets create one
-    if((bmpArray->surface = makeSdlSurface(SDL_SWSURFACE, bmpArray->w, bmpArray->h, 8)) == nullptr)
+    if((bmpArray->surface = makePalSurface(bmpArray->w, bmpArray->h, palActual->colors)) == nullptr)
         return false;
-    SDL_SetPalette(bmpArray->surface.get(), SDL_LOGPAL, palActual->colors.data(), 0, palActual->colors.size());
 
     // set fp to back to the first offset of data block
     fseek(fp, data_start, SEEK_SET);
diff --git a/external/s25edit/CIO/CFont.cpp b/external/s25edit/CIO/CFont.cpp
index b511024..d8c33a6 100644
--- a/external/s25edit/CIO/CFont.cpp
+++ b/external/s25edit/CIO/CFont.cpp
@@ -254,10 +254,10 @@ void CFont::writeText()
                     pixel_ctr_w = pixel_ctr_w_tmp;
                 w = pixel_ctr_w;
                 h = pixel_ctr_h;
-                Surf_Font = makeSdlSurface(SDL_SWSURFACE, w, h, 32);
+                Surf_Font = makeRGBSurface(w, h);
                 if(!Surf_Font)
                     return;
-                SDL_SetColorKey(Surf_Font.get(), SDL_SRCCOLORKEY, SDL_MapRGB(Surf_Font->format, 0, 0, 0));
+                SDL_SetColorKey(Surf_Font.get(), SDL_TRUE, SDL_MapRGB(Surf_Font->format, 0, 0, 0));
                 chiffre = string_.begin();
                 pixel_count_loop = false;
                 continue;
diff --git a/external/s25edit/CIO/CMenu.cpp b/external/s25edit/CIO/CMenu.cpp
index 6e200f5..298ae36 100644
--- a/external/s25edit/CIO/CMenu.cpp
+++ b/external/s25edit/CIO/CMenu.cpp
@@ -17,7 +17,7 @@ bool CMenu::render()
     // if we need a new surface
     if(!surface)
     {
-        surface = makeSdlSurface(SDL_SWSURFACE, global::s2->getRes().x, global::s2->getRes().y, 32);
+        surface = makeRGBSurface(global::s2->getRes().x, global::s2->getRes().y);
         if(!surface)
             return false;
     }
diff --git a/external/s25edit/CIO/CPicture.cpp b/external/s25edit/CIO/CPicture.cpp
index 5e2ac80..1fa48d8 100644
--- a/external/s25edit/CIO/CPicture.cpp
+++ b/external/s25edit/CIO/CPicture.cpp
@@ -72,10 +72,10 @@ bool CPicture::render()
     // if we need a new surface
     if(!Surf_Picture)
     {
-        Surf_Picture = makeSdlSurface(SDL_SWSURFACE, w, h, 32);
+        Surf_Picture = makeRGBSurface(w, h);
         if(!Surf_Picture)
             return false;
-        SDL_SetColorKey(Surf_Picture.get(), SDL_SRCCOLORKEY, SDL_MapRGB(Surf_Picture->format, 0, 0, 0));
+        SDL_SetColorKey(Surf_Picture.get(), SDL_TRUE, SDL_MapRGB(Surf_Picture->format, 0, 0, 0));
     }
 
     CSurface::Draw(Surf_Picture, global::bmpArray[picture_].surface, 0, 0);
diff --git a/external/s25edit/CIO/CSelectBox.cpp b/external/s25edit/CIO/CSelectBox.cpp
index 559eac7..6ba07d6 100644
--- a/external/s25edit/CIO/CSelectBox.cpp
+++ b/external/s25edit/CIO/CSelectBox.cpp
@@ -213,7 +213,7 @@ bool CSelectBox::render()
     // if we need a new surface
     if(!Surf_SelectBox)
     {
-        if((Surf_SelectBox = makeSdlSurface(SDL_SWSURFACE, w_, h_, 32)) == nullptr)
+        if((Surf_SelectBox = makeRGBSurface(w_, h_)) == nullptr)
             return false;
     }
 
diff --git a/external/s25edit/CIO/CTextfield.cpp b/external/s25edit/CIO/CTextfield.cpp
index 935d87c..d7d9438 100644
--- a/external/s25edit/CIO/CTextfield.cpp
+++ b/external/s25edit/CIO/CTextfield.cpp
@@ -270,7 +270,7 @@ bool CTextfield::render()
     // if we need a new surface
     if(!Surf_Text)
     {
-        Surf_Text = makeSdlSurface(SDL_SWSURFACE, w, h, 32);
+        Surf_Text = makeRGBSurface(w, h);
         if(!Surf_Text)
             return false;
     }
diff --git a/external/s25edit/CIO/CWindow.cpp b/external/s25edit/CIO/CWindow.cpp
index 889a5b9..a3efd67 100644
--- a/external/s25edit/CIO/CWindow.cpp
+++ b/external/s25edit/CIO/CWindow.cpp
@@ -279,7 +279,7 @@ bool CWindow::render()
     // if we need a new surface
     if(!surface)
     {
-        if(!(surface = makeSdlSurface(SDL_SWSURFACE, w_, h_, 32)))
+        if(!(surface = makeRGBSurface(w_, h_)))
             return false;
     }
 
diff --git a/external/s25edit/CMap.cpp b/external/s25edit/CMap.cpp
index 763daca..6e8ec3a 100644
--- a/external/s25edit/CMap.cpp
+++ b/external/s25edit/CMap.cpp
@@ -7,6 +7,7 @@
 #include "globals.h"
 #include "gameData/external/s25edit/LandscapeDesc.h"
 #include "gameData/external/s25edit/TerrainDesc.h"
+#include <cassert>
 #include <iostream>
 #include <string>
 
@@ -496,171 +497,153 @@ void CMap::moveMap(Position offset)
 void CMap::setMouseData(const SDL_MouseMotionEvent& motion)
 {
     // following code important for blitting the right field of the map
-    // is right mouse button pressed?
-    if(motion.state & SDL_BUTTON(3))
-    {
-        Position offset{};
-        if(!HorizontalMovementLocked)
-            offset.x = motion.xrel;
-        if(!VerticalMovementLocked)
-            offset.y = motion.yrel;
+    // Are we scrolling?
+    if(startScrollPos)
+    {
+        assert(motion.state & SDL_BUTTON(3));
+        Position offset = Position(motion.x, motion.y) - *startScrollPos;
+        if(HorizontalMovementLocked)
+            offset.x = 0;
+        if(VerticalMovementLocked)
+            offset.y = 0;
         moveMap(offset);
 
         // this whole "warping-thing" is to prevent cursor-moving WITHIN the window while user moves over the map
         SDL_EventState(SDL_MOUSEMOTION, SDL_IGNORE);
-        SDL_WarpMouse(motion.x - motion.xrel, motion.y - motion.yrel);
+        SDL_WarpMouseInWindow(nullptr, startScrollPos->x, startScrollPos->y);
         SDL_EventState(SDL_MOUSEMOTION, SDL_ENABLE);
     }
 
     storeVerticesFromMouse(motion.x, motion.y, motion.state);
 }
 
+void CMap::onLeftMouseDown(const Point32& pos)
+{ // find out if user clicked on one of the game menu pictures
+    // we start with lower menubar
+    const Point32 displaySize(displayRect.getSize());
+    if(pos.x >= (displaySize.x / 2 - 236) && pos.x <= (displaySize.x / 2 - 199) && pos.y >= (displaySize.y - 35)
+       && pos.y <= (displaySize.y - 3))
+    {
+        // the height-mode picture was clicked
+        mode = EDITOR_MODE_HEIGHT_RAISE;
+    } else if(pos.x >= (displaySize.x / 2 - 199) && pos.x <= (displaySize.x / 2 - 162) && pos.y >= (displaySize.y - 35)
+              && pos.y <= (displaySize.y - 3))
+    {
+        // the texture-mode picture was clicked
+        mode = EDITOR_MODE_TEXTURE;
+        callback::EditorTextureMenu(INITIALIZING_CALL);
+    } else if(pos.x >= (displaySize.x / 2 - 162) && pos.x <= (displaySize.x / 2 - 125) && pos.y >= (displaySize.y - 35)
+              && pos.y <= (displaySize.y - 3))
+    {
+        // the tree-mode picture was clicked
+        mode = EDITOR_MODE_TREE;
+        callback::EditorTreeMenu(INITIALIZING_CALL);
+    } else if(pos.x >= (displaySize.x / 2 - 125) && pos.x <= (displaySize.x / 2 - 88) && pos.y >= (displaySize.y - 35)
+              && pos.y <= (displaySize.y - 3))
+    {
+        // the resource-mode picture was clicked
+        mode = EDITOR_MODE_RESOURCE_RAISE;
+        callback::EditorResourceMenu(INITIALIZING_CALL);
+    } else if(pos.x >= (displaySize.x / 2 - 88) && pos.x <= (displaySize.x / 2 - 51) && pos.y >= (displaySize.y - 35)
+              && pos.y <= (displaySize.y - 3))
+    {
+        // the landscape-mode picture was clicked
+        mode = EDITOR_MODE_LANDSCAPE;
+        callback::EditorLandscapeMenu(INITIALIZING_CALL);
+    } else if(pos.x >= (displaySize.x / 2 - 51) && pos.x <= (displaySize.x / 2 - 14) && pos.y >= (displaySize.y - 35)
+              && pos.y <= (displaySize.y - 3))
+    {
+        // the animal-mode picture was clicked
+        mode = EDITOR_MODE_ANIMAL;
+        callback::EditorAnimalMenu(INITIALIZING_CALL);
+    } else if(pos.x >= (displaySize.x / 2 - 14) && pos.x <= (displaySize.x / 2 + 23) && pos.y >= (displaySize.y - 35)
+              && pos.y <= (displaySize.y - 3))
+    {
+        // the player-mode picture was clicked
+        mode = EDITOR_MODE_FLAG;
+        ChangeSection_ = 0;
+        setupVerticesActivity();
+        callback::EditorPlayerMenu(INITIALIZING_CALL);
+    } else if(pos.x >= (displaySize.x / 2 + 96) && pos.x <= (displaySize.x / 2 + 133) && pos.y >= (displaySize.y - 35)
+              && pos.y <= (displaySize.y - 3))
+    {
+        // the build-help picture was clicked
+        RenderBuildHelp = !RenderBuildHelp;
+    } else if(pos.x >= (displaySize.x / 2 + 131) && pos.x <= (displaySize.x / 2 + 168) && pos.y >= (displaySize.y - 35)
+              && pos.y <= (displaySize.y - 3))
+    {
+        // the minimap picture was clicked
+        callback::MinimapMenu(INITIALIZING_CALL);
+    } else if(pos.x >= (displaySize.x / 2 + 166) && pos.x <= (displaySize.x / 2 + 203) && pos.y >= (displaySize.y - 35)
+              && pos.y <= (displaySize.y - 3))
+    {
+        // the create-world picture was clicked
+        callback::EditorCreateMenu(INITIALIZING_CALL);
+    } else if(pos.x >= (displaySize.x / 2 + 203) && pos.x <= (displaySize.x / 2 + 240) && pos.y >= (displaySize.y - 35)
+              && pos.y <= (displaySize.y - 3))
+    {
+        // the editor-main-menu picture was clicked
+        callback::EditorMainMenu(INITIALIZING_CALL);
+    }
+    // now we check the right menubar
+    else if(pos.x >= (displaySize.x - 37) && pos.x <= (displaySize.x) && pos.y >= (displaySize.y / 2 + 162)
+            && pos.y <= (displaySize.y / 2 + 199))
+    {
+        // the bugkill picture was clicked for quickload
+        callback::PleaseWait(INITIALIZING_CALL);
+        // we have to close the windows and initialize them again to prevent failures
+        callback::EditorCursorMenu(MAP_QUIT);
+        callback::EditorTextureMenu(MAP_QUIT);
+        callback::EditorTreeMenu(MAP_QUIT);
+        callback::EditorLandscapeMenu(MAP_QUIT);
+        callback::MinimapMenu(MAP_QUIT);
+        callback::EditorResourceMenu(MAP_QUIT);
+        callback::EditorAnimalMenu(MAP_QUIT);
+        callback::EditorPlayerMenu(MAP_QUIT);
+
+        destructMap();
+        constructMap(global::userMapsPath + "/quicksave.swd");
+        callback::PleaseWait(WINDOW_QUIT_MESSAGE);
+    } else if(pos.x >= (displaySize.x - 37) && pos.x <= (displaySize.x) && pos.y >= (displaySize.y / 2 + 200)
+              && pos.y <= (displaySize.y / 2 + 237))
+    {
+        // the bugkill picture was clicked for quicksave
+        callback::PleaseWait(INITIALIZING_CALL);
+        if(!CFile::save_file(global::userMapsPath + "/quicksave.swd", SWD, getMap()))
+        {
+            callback::ShowStatus(INITIALIZING_CALL);
+            callback::ShowStatus(2);
+        }
+        callback::PleaseWait(WINDOW_QUIT_MESSAGE);
+    } else if(pos.x >= (displaySize.x - 37) && pos.x <= (displaySize.x) && pos.y >= (displaySize.y / 2 - 239)
+              && pos.y <= (displaySize.y / 2 - 202))
+    {
+        // the cursor picture was clicked
+        callback::EditorCursorMenu(INITIALIZING_CALL);
+    } else
+    {
+        // no picture was clicked
+        // touch vertex data
+        modify = true;
+        saveCurrentVertices = true;
+    }
+}
+
 void CMap::setMouseData(const SDL_MouseButtonEvent& button)
 {
     if(button.state == SDL_PRESSED)
     {
-        // find out if user clicked on one of the game menu pictures
-        // we start with lower menubar
-        if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x / 2 - 236)
-           && button.x <= (displayRect.getSize().x / 2 - 199) && button.y >= (displayRect.getSize().y - 35)
-           && button.y <= (displayRect.getSize().y - 3))
-        {
-            // the height-mode picture was clicked
-            mode = EDITOR_MODE_HEIGHT_RAISE;
-            return;
-        } else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x / 2 - 199)
-                  && button.x <= (displayRect.getSize().x / 2 - 162) && button.y >= (displayRect.getSize().y - 35)
-                  && button.y <= (displayRect.getSize().y - 3))
-        {
-            // the texture-mode picture was clicked
-            mode = EDITOR_MODE_TEXTURE;
-            callback::EditorTextureMenu(INITIALIZING_CALL);
-            return;
-        } else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x / 2 - 162)
-                  && button.x <= (displayRect.getSize().x / 2 - 125) && button.y >= (displayRect.getSize().y - 35)
-                  && button.y <= (displayRect.getSize().y - 3))
-        {
-            // the tree-mode picture was clicked
-            mode = EDITOR_MODE_TREE;
-            callback::EditorTreeMenu(INITIALIZING_CALL);
-            return;
-        } else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x / 2 - 125)
-                  && button.x <= (displayRect.getSize().x / 2 - 88) && button.y >= (displayRect.getSize().y - 35)
-                  && button.y <= (displayRect.getSize().y - 3))
-        {
-            // the resource-mode picture was clicked
-            mode = EDITOR_MODE_RESOURCE_RAISE;
-            callback::EditorResourceMenu(INITIALIZING_CALL);
-            return;
-        } else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x / 2 - 88)
-                  && button.x <= (displayRect.getSize().x / 2 - 51) && button.y >= (displayRect.getSize().y - 35)
-                  && button.y <= (displayRect.getSize().y - 3))
-        {
-            // the landscape-mode picture was clicked
-            mode = EDITOR_MODE_LANDSCAPE;
-            callback::EditorLandscapeMenu(INITIALIZING_CALL);
-            return;
-        } else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x / 2 - 51)
-                  && button.x <= (displayRect.getSize().x / 2 - 14) && button.y >= (displayRect.getSize().y - 35)
-                  && button.y <= (displayRect.getSize().y - 3))
-        {
-            // the animal-mode picture was clicked
-            mode = EDITOR_MODE_ANIMAL;
-            callback::EditorAnimalMenu(INITIALIZING_CALL);
-            return;
-        } else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x / 2 - 14)
-                  && button.x <= (displayRect.getSize().x / 2 + 23) && button.y >= (displayRect.getSize().y - 35)
-                  && button.y <= (displayRect.getSize().y - 3))
-        {
-            // the player-mode picture was clicked
-            mode = EDITOR_MODE_FLAG;
-            ChangeSection_ = 0;
-            setupVerticesActivity();
-            callback::EditorPlayerMenu(INITIALIZING_CALL);
-            return;
-        } else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x / 2 + 96)
-                  && button.x <= (displayRect.getSize().x / 2 + 133) && button.y >= (displayRect.getSize().y - 35)
-                  && button.y <= (displayRect.getSize().y - 3))
-        {
-            // the build-help picture was clicked
-            RenderBuildHelp = !RenderBuildHelp;
-            return;
-        } else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x / 2 + 131)
-                  && button.x <= (displayRect.getSize().x / 2 + 168) && button.y >= (displayRect.getSize().y - 35)
-                  && button.y <= (displayRect.getSize().y - 3))
-        {
-            // the minimap picture was clicked
-            callback::MinimapMenu(INITIALIZING_CALL);
-            return;
-        } else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x / 2 + 166)
-                  && button.x <= (displayRect.getSize().x / 2 + 203) && button.y >= (displayRect.getSize().y - 35)
-                  && button.y <= (displayRect.getSize().y - 3))
-        {
-            // the create-world picture was clicked
-            callback::EditorCreateMenu(INITIALIZING_CALL);
-            return;
-        } else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x / 2 + 203)
-                  && button.x <= (displayRect.getSize().x / 2 + 240) && button.y >= (displayRect.getSize().y - 35)
-                  && button.y <= (displayRect.getSize().y - 3))
-        {
-            // the editor-main-menu picture was clicked
-            callback::EditorMainMenu(INITIALIZING_CALL);
-            return;
-        }
-        // now we check the right menubar
-        else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x - 37) && button.x <= (displayRect.getSize().x)
-                && button.y >= (displayRect.getSize().y / 2 + 162) && button.y <= (displayRect.getSize().y / 2 + 199))
-        {
-            // the bugkill picture was clicked for quickload
-            callback::PleaseWait(INITIALIZING_CALL);
-            // we have to close the windows and initialize them again to prevent failures
-            callback::EditorCursorMenu(MAP_QUIT);
-            callback::EditorTextureMenu(MAP_QUIT);
-            callback::EditorTreeMenu(MAP_QUIT);
-            callback::EditorLandscapeMenu(MAP_QUIT);
-            callback::MinimapMenu(MAP_QUIT);
-            callback::EditorResourceMenu(MAP_QUIT);
-            callback::EditorAnimalMenu(MAP_QUIT);
-            callback::EditorPlayerMenu(MAP_QUIT);
-
-            destructMap();
-            constructMap(global::userMapsPath + "/quicksave.swd");
-            callback::PleaseWait(WINDOW_QUIT_MESSAGE);
-            return;
-        } else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x - 37) && button.x <= (displayRect.getSize().x)
-                  && button.y >= (displayRect.getSize().y / 2 + 200) && button.y <= (displayRect.getSize().y / 2 + 237))
-        {
-            // the bugkill picture was clicked for quicksave
-            callback::PleaseWait(INITIALIZING_CALL);
-            if(!CFile::save_file(global::userMapsPath + "/quicksave.swd", SWD, getMap()))
-            {
-                callback::ShowStatus(INITIALIZING_CALL);
-                callback::ShowStatus(2);
-            }
-            callback::PleaseWait(WINDOW_QUIT_MESSAGE);
-            return;
-        } else if(button.button == SDL_BUTTON_LEFT && button.x >= (displayRect.getSize().x - 37) && button.x <= (displayRect.getSize().x)
-                  && button.y >= (displayRect.getSize().y / 2 - 239) && button.y <= (displayRect.getSize().y / 2 - 202))
-        {
-            // the cursor picture was clicked
-            callback::EditorCursorMenu(INITIALIZING_CALL);
-            return;
-        } else
-        {
-            // no picture was clicked
-
-            // touch vertex data
-            if(button.button == SDL_BUTTON_LEFT)
-            {
-                modify = true;
-                saveCurrentVertices = true;
-            }
-        }
+        if(button.button == SDL_BUTTON_LEFT)
+            onLeftMouseDown({button.x, button.y});
+        else if(button.button == SDL_BUTTON_RIGHT)
+            startScrollPos = Position(button.x, button.y);
     } else if(button.state == SDL_RELEASED)
     {
         // stop touching vertex data
         if(button.button == SDL_BUTTON_LEFT)
             modify = false;
+        else if(button.button == SDL_BUTTON_RIGHT)
+            startScrollPos = boost::none;
     }
 }
 
@@ -669,9 +652,9 @@ SavedVertex saveVertex(Position pt, const bobMAP& map)
 {
     SavedVertex res;
     res.pos = pt;
-    for(int i = pt.x - MAX_CHANGE_SECTION - 10 - 2, k = 0; i <= pt.x + MAX_CHANGE_SECTION + 10 + 2; i++, k++)
+    for(int i = pt.x - SavedVertex::NODES_PER_DIR, k = 0; i <= pt.x + SavedVertex::NODES_PER_DIR; i++, k++)
     {
-        for(int j = pt.y - MAX_CHANGE_SECTION - 10 - 2, l = 0; j <= pt.y + MAX_CHANGE_SECTION + 10 + 2; j++, l++)
+        for(int j = pt.y - SavedVertex::NODES_PER_DIR, l = 0; j <= pt.y + SavedVertex::NODES_PER_DIR; j++, l++)
         {
             // i und j muessen wegen den mapraendern noch korrigiert werden!
             int m = i;
@@ -692,9 +675,9 @@ SavedVertex saveVertex(Position pt, const bobMAP& map)
 
 void restoreVertex(const SavedVertex& vertex, bobMAP& map)
 {
-    for(int i = vertex.pos.x - MAX_CHANGE_SECTION - 10 - 2, k = 0; i <= vertex.pos.x + MAX_CHANGE_SECTION + 10 + 2; i++, k++)
+    for(int i = vertex.pos.x - SavedVertex::NODES_PER_DIR, k = 0; i <= vertex.pos.x + SavedVertex::NODES_PER_DIR; i++, k++)
     {
-        for(int j = vertex.pos.y - MAX_CHANGE_SECTION - 10 - 2, l = 0; j <= vertex.pos.y + MAX_CHANGE_SECTION + 10 + 2; j++, l++)
+        for(int j = vertex.pos.y - SavedVertex::NODES_PER_DIR, l = 0; j <= vertex.pos.y + SavedVertex::NODES_PER_DIR; j++, l++)
         {
             int m = i;
             if(m < 0)
@@ -825,47 +808,47 @@ void CMap::setKeyboardData(const SDL_KeyboardEvent& key)
                 }
                 break;
             case SDLK_1:
-            case SDLK_KP1:
+            case SDLK_KP_1:
                 ChangeSection_ = 0;
                 setupVerticesActivity();
                 break;
             case SDLK_2:
-            case SDLK_KP2:
+            case SDLK_KP_2:
                 ChangeSection_ = 1;
                 setupVerticesActivity();
                 break;
             case SDLK_3:
-            case SDLK_KP3:
+            case SDLK_KP_3:
                 ChangeSection_ = 2;
                 setupVerticesActivity();
                 break;
             case SDLK_4:
-            case SDLK_KP4:
+            case SDLK_KP_4:
                 ChangeSection_ = 3;
                 setupVerticesActivity();
                 break;
             case SDLK_5:
-            case SDLK_KP5:
+            case SDLK_KP_5:
                 ChangeSection_ = 4;
                 setupVerticesActivity();
                 break;
             case SDLK_6:
-            case SDLK_KP6:
+            case SDLK_KP_6:
                 ChangeSection_ = 5;
                 setupVerticesActivity();
                 break;
             case SDLK_7:
-            case SDLK_KP7:
+            case SDLK_KP_7:
                 ChangeSection_ = 6;
                 setupVerticesActivity();
                 break;
             case SDLK_8:
-            case SDLK_KP8:
+            case SDLK_KP_8:
                 ChangeSection_ = 7;
                 setupVerticesActivity();
                 break;
             case SDLK_9:
-            case SDLK_KP9:
+            case SDLK_KP_9:
                 ChangeSection_ = 8;
                 setupVerticesActivity();
                 break;
@@ -1113,12 +1096,10 @@ void CMap::render()
     // if we need a new surface
     if(!Surf_Map)
     {
-        Surf_Map = makeSdlSurface(SDL_SWSURFACE, displayRect.getSize().x, displayRect.getSize().y, BitsPerPixel);
-        if(!Surf_Map)
-            return;
         if(BitsPerPixel == 8)
-            SDL_SetPalette(Surf_Map.get(), SDL_LOGPAL, global::palArray[PAL_xBBM].colors.data(), 0,
-                           global::palArray[PAL_xBBM].colors.size());
+            Surf_Map = makePalSurface(displayRect.getSize().x, displayRect.getSize().y, global::palArray[PAL_xBBM].colors);
+        else
+            Surf_Map = makeRGBSurface(displayRect.getSize().x, displayRect.getSize().y);
     }
     // else
     // clear the surface before drawing new (in normal case not needed)
@@ -1257,11 +1238,11 @@ void CMap::render()
     if(!Surf_RightMenubar)
     {
         // we permute width and height, cause we want to rotate the menubar 90 degrees
-        if((Surf_RightMenubar = makeSdlSurface(SDL_SWSURFACE, global::bmpArray[MENUBAR].h, global::bmpArray[MENUBAR].w, 8)) != nullptr)
+        if((Surf_RightMenubar =
+              makePalSurface(global::bmpArray[MENUBAR].h, global::bmpArray[MENUBAR].w, global::palArray[PAL_RESOURCE].colors))
+           != nullptr)
         {
-            SDL_SetPalette(Surf_RightMenubar.get(), SDL_LOGPAL, global::palArray[PAL_RESOURCE].colors.data(), 0,
-                           global::palArray[PAL_RESOURCE].colors.size());
-            SDL_SetColorKey(Surf_RightMenubar.get(), SDL_SRCCOLORKEY | SDL_RLEACCEL, SDL_MapRGB(Surf_RightMenubar->format, 0, 0, 0));
+            SDL_SetColorKey(Surf_RightMenubar.get(), SDL_TRUE, SDL_MapRGB(Surf_RightMenubar->format, 0, 0, 0));
             CSurface::Draw(Surf_RightMenubar, global::bmpArray[MENUBAR].surface, 0, 0, 270);
         }
     }
diff --git a/external/s25edit/CMap.h b/external/s25edit/CMap.h
index a1af01c..3619a5d 100644
--- a/external/s25edit/CMap.h
+++ b/external/s25edit/CMap.h
@@ -2,6 +2,7 @@
 #define _CMAP_H
 
 #include "defines.h"
+#include <boost/optional.hpp>
 #include <Point.h>
 #include <SDL.h>
 #include <array>
@@ -11,12 +12,25 @@
 
 struct SavedVertex
 {
+    template<typename T>
+    struct ArrayPtr
+    {
+        std::unique_ptr<T> array_;
+        auto& operator[](size_t index) { return (*array_)[index]; }
+        const auto& operator[](size_t index) const { return (*array_)[index]; }
+        ArrayPtr() : array_(std::make_unique<T>()) {}
+    };
     Position pos;
-    // MAX_CHANGE_SECTION * 2 + 1 = number of vertices in one row or col
+    // NUM_NODES = number of vertices in one row or col
     //+ 10 because if we raise a vertex then the other vertices will be raised too after 5 times
     // this ranges up to 10 vertices
     //+ 2 because modifications on a vertex will touch building and shading around
-    std::array<std::array<MapNode, (MAX_CHANGE_SECTION + 10 + 2) * 2 + 1>, (MAX_CHANGE_SECTION + 10 + 2) * 2 + 1> PointsArroundVertex;
+    // Using int due to signed arithmetic used later
+    static constexpr int NODES_PER_DIR = MAX_CHANGE_SECTION + 10 + 2;
+    static constexpr size_t NUM_NODES = NODES_PER_DIR * 2 + 1;
+    using PointArray = std::array<std::array<MapNode, NUM_NODES>, NUM_NODES>;
+    // Use a unique pointer to not create huge stack arrays
+    ArrayPtr<PointArray> PointsArroundVertex;
 };
 
 class CMap
@@ -81,6 +95,7 @@ private:
     // lock vertical or horizontal movement
     bool HorizontalMovementLocked;
     bool VerticalMovementLocked;
+    boost::optional<Position> startScrollPos;
 
 public:
     CMap(const std::string& filename);
@@ -205,6 +220,7 @@ private:
     void rotateMap();
     void MirrorMapOnXAxis();
     void MirrorMapOnYAxis();
+    void onLeftMouseDown(const Point32& pos);
 };
 
 #endif
diff --git a/external/s25edit/CSurface.cpp b/external/s25edit/CSurface.cpp
index 9f78a31..65f453a 100644
--- a/external/s25edit/CSurface.cpp
+++ b/external/s25edit/CSurface.cpp
@@ -30,8 +30,10 @@ void DrawPreCalcFadedTexturedTrigon(SDL_Surface* dest, const Point16& p1, const
     Sint16 right = rect.x + rect.w - 1;
     Sint16 middle = rect.x + rect.w / Sint16(2);
     Sint16 bottom = rect.y + rect.h - 1;
+    Uint32 colorKey;
+    const int keycount = (SDL_GetColorKey(source, &colorKey) < 0) ? 0 : 1;
     sge_PreCalcFadedTexturedTrigonColorKeys(dest, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, source, rect.x, rect.y, right, rect.y, middle, bottom,
-                                            I1, I2, I2, PreCalcPalettes, &source->format->colorkey, 1);
+                                            I1, I2, I2, PreCalcPalettes, &colorKey, keycount);
 }
 
 void DrawFadedTexturedTrigon(SDL_Surface* dest, const Point16& p1, const Point16& p2, const Point16& p3, SDL_Surface* source,
@@ -40,13 +42,14 @@ void DrawFadedTexturedTrigon(SDL_Surface* dest, const Point16& p1, const Point16
     Sint16 right = rect.x + rect.w - 1;
     Sint16 middle = rect.x + rect.w / Sint16(2);
     Sint16 bottom = rect.y + rect.h - 1;
+    Uint32 colorKey;
+    const int keycount = (SDL_GetColorKey(source, &colorKey) < 0) ? 0 : 1;
     sge_FadedTexturedTrigonColorKeys(dest, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, source, rect.x, rect.y, right, rect.y, middle, bottom, I1,
-                                     I2, I2, &source->format->colorkey, 1);
+                                     I2, I2, &colorKey, keycount);
 }
 } // namespace
 
 bool CSurface::drawTextures = false;
-bool CSurface::useOpenGL = false;
 
 bool CSurface::Draw(SDL_Surface* Surf_Dest, SDL_Surface* Surf_Src, int X, int Y)
 {
diff --git a/external/s25edit/CSurface.h b/external/s25edit/CSurface.h
index 2686d86..d17036e 100644
--- a/external/s25edit/CSurface.h
+++ b/external/s25edit/CSurface.h
@@ -39,8 +39,6 @@ public:
     static void get_nodeVectors(bobMAP& myMap);
     static void update_shading(bobMAP& myMap, int VertexX, int VertexY);
 
-    static bool useOpenGL;
-
 private:
     // to decide what to draw, triangle-textures or objects and texture-borders
     static bool drawTextures;
diff --git a/external/s25edit/SGE/CMakeLists.txt b/external/s25edit/SGE/CMakeLists.txt
index 54ed77c..eea7bdd 100644
--- a/external/s25edit/SGE/CMakeLists.txt
+++ b/external/s25edit/SGE/CMakeLists.txt
@@ -1,9 +1,8 @@
-FIND_PACKAGE(SDL REQUIRED)
+FIND_PACKAGE(SDL2 REQUIRED)
 
-file(GLOB SGE_SOURCES *.cpp *.h)
+file(GLOB_RECURSE SGE_SOURCES *.cpp *.h)
 add_library(SGE STATIC ${SGE_SOURCES})
-target_link_libraries(SGE PUBLIC ${SDL_LIBRARY} Boost::boost)
-target_include_directories(SGE SYSTEM PUBLIC ${SDL_INCLUDE_DIR})
+target_link_libraries(SGE PUBLIC Boost::boost SDL2::SDL2)
 target_include_directories(SGE PRIVATE include/SGE PUBLIC include)
 target_compile_features(SGE PUBLIC cxx_std_14)
 set_target_properties(SGE PROPERTIES CXX_EXTENSIONS OFF)
diff --git a/external/s25edit/SGE/include/SGE/sge.h b/external/s25edit/SGE/include/SGE/sge.h
index 82a984d..294e91e 100644
--- a/external/s25edit/SGE/include/SGE/sge.h
+++ b/external/s25edit/SGE/include/SGE/sge.h
@@ -18,14 +18,11 @@
 #define sge_H
 
 #include "sge_blib.h"
-#include "sge_bm_text.h"
 #include "sge_collision.h"
 #include "sge_misc.h"
 #include "sge_primitives.h"
 #include "sge_rotation.h"
 #include "sge_shape.h"
 #include "sge_surface.h"
-#include "sge_textpp.h"
-#include "sge_tt_text.h"
 
 #endif /* sge_H */
diff --git a/external/s25edit/SGE/include/SGE/sge_bm_text.h b/external/s25edit/SGE/include/SGE/sge_bm_text.h
deleted file mode 100644
index cb1778e..0000000
--- a/external/s25edit/SGE/include/SGE/sge_bm_text.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- *	SDL Graphics Extension
- *	Text/Bitmap font functions (header)
- *
- *	Started 990815
- *
- *	License: LGPL v2+ (see the file LICENSE)
- *	(c)1999-2003 Anders LindstrÃ¶m
- */
-
-/*********************************************************************
- *  This library is free software; you can redistribute it and/or    *
- *  modify it under the terms of the GNU Library General Public      *
- *  License as published by the Free Software Foundation; either     *
- *  version 2 of the License, or (at your option) any later version. *
- *********************************************************************/
-
-#ifndef sge_bm_text_H
-#define sge_bm_text_H
-
-#include "sge_internal.h"
-
-/* BF open flags */
-#define SGE_BFTRANSP SGE_FLAG1
-#define SGE_BFSFONT SGE_FLAG2
-#define SGE_BFNOCONVERT SGE_FLAG3
-#define SGE_BFPALETTE SGE_FLAG4
-
-/* Text input flags */
-#define SGE_IBG SGE_FLAG1
-#define SGE_IDEL SGE_FLAG2
-#define SGE_INOKR SGE_FLAG3
-
-/* the bitmap font structure */
-struct sge_bmpFont
-{
-    SDL_Surface* FontSurface;
-    Uint16 CharWidth;
-    Uint16 CharHeight;
-    Sint16* CharPos;
-    Sint16 yoffs;
-    Uint32 bcolor;
-    Sint16 Chars;
-};
-
-#ifdef _SGE_C
-extern "C" {
-#endif
-DECLSPEC sge_bmpFont* sge_BF_CreateFont(SDL_Surface* surface, Uint8 flags);
-DECLSPEC sge_bmpFont* sge_BF_OpenFont(const char* file, Uint8 flags);
-DECLSPEC void sge_BF_CloseFont(sge_bmpFont* font);
-DECLSPEC void sge_BF_SetColor(sge_bmpFont* font, Uint8 R, Uint8 G, Uint8 B);
-DECLSPEC void sge_BF_SetAlpha(sge_bmpFont* font, Uint8 alpha);
-DECLSPEC Sint16 sge_BF_GetHeight(sge_bmpFont* font);
-DECLSPEC Sint16 sge_BF_GetWidth(sge_bmpFont* font);
-DECLSPEC SDL_Rect sge_BF_TextSize(sge_bmpFont* font, const char* string);
-
-DECLSPEC SDL_Rect sge_BF_textout(SDL_Surface* surface, sge_bmpFont* font, const char* string, Sint16 x, Sint16 y);
-DECLSPEC SGE_ATTRIBUTE_FORMAT(5, 6) SDL_Rect
-  sge_BF_textoutf(SDL_Surface* surface, sge_bmpFont* font, Sint16 x, Sint16 y, const char* format, ...);
-
-DECLSPEC int sge_BF_input(SDL_Surface* screen, sge_bmpFont* font, char* string, Uint8 flags, int pos, unsigned len, Sint16 x, Sint16 y);
-DECLSPEC int sge_BF_inputAlpha(SDL_Surface* screen, sge_bmpFont* font, char* string, Uint8 flags, int pos, unsigned len, Sint16 x, Sint16 y,
-                               int Alpha);
-DECLSPEC int sge_BF_input_UNI(SDL_Surface* screen, sge_bmpFont* font, Uint16* string, Uint8 flags, int pos, unsigned len, Sint16 x,
-                              Sint16 y);
-DECLSPEC int sge_BF_inputAlpha_UNI(SDL_Surface* screen, sge_bmpFont* font, Uint16* string, Uint8 flags, int pos, unsigned len, Sint16 x,
-                                   Sint16 y, int Alpha);
-#ifdef _SGE_C
-}
-#endif
-
-#endif /* sge_bm_text_H */
diff --git a/external/s25edit/SGE/include/SGE/sge_internal.h b/external/s25edit/SGE/include/SGE/sge_internal.h
index 618f853..eb39084 100644
--- a/external/s25edit/SGE/include/SGE/sge_internal.h
+++ b/external/s25edit/SGE/include/SGE/sge_internal.h
@@ -56,35 +56,9 @@ constexpr auto absDiff(T a, T b)
 #define SGE_FLAG7 0x40
 #define SGE_FLAG8 0x80
 
-/*
- *  Define the right alpha values
- *  (they were fliped in SDL 1.1.5+)
- */
-#ifndef SDL_ALPHA_OPAQUE
-#define SDL_ALPHA_OPAQUE 0
-#endif
-#ifndef SDL_ALPHA_TRANSPARENT
-#define SDL_ALPHA_TRANSPARENT 255
-#endif
-
-/*
- *  Older versions of SDL doesn't have SDL_VERSIONNUM
- */
-#ifndef SDL_VERSIONNUM
-#define SDL_VERSIONNUM(X, Y, Z) (X) * 1000 + (Y)*100 + (Z)
-#endif
-
-/*
- *  Older versions of SDL doesn't have SDL_CreateRGBSurface
- */
-#ifndef SDL_AllocSurface
-#define SDL_CreateRGBSurface SDL_AllocSurface
-#endif
-
 /*
  *  Macro to get clipping
  */
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) >= SDL_VERSIONNUM(1, 1, 5)
 inline auto sge_clip_xmin(const SDL_Surface* pnt)
 {
     return pnt->clip_rect.x;
@@ -101,36 +75,6 @@ inline auto sge_clip_ymax(const SDL_Surface* pnt)
 {
     return (pnt->clip_rect.y + pnt->clip_rect.h - 1);
 }
-#else
-inline auto sge_clip_xmin(const SDL_Surface* pnt)
-{
-    pnt->clip_minx;
-}
-inline auto sge_clip_xmax(const SDL_Surface* pnt)
-{
-    pnt->clip_maxx;
-}
-inline auto sge_clip_ymin(const SDL_Surface* pnt)
-{
-    pnt->clip_miny;
-}
-inline auto sge_clip_ymax(const SDL_Surface* pnt)
-{
-    pnt->clip_maxy;
-}
-#endif
-
-/*
- *  We need to use alpha sometimes but older versions of SDL doesn't have
- *  alpha support.
- */
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) >= SDL_VERSIONNUM(1, 1, 5)
-#define sge_MapRGBA SDL_MapRGBA
-#define sge_GetRGBA SDL_GetRGBA
-#else
-#define sge_MapRGBA(fmt, r, g, b, a) SDL_MapRGB(fmt, r, g, b)
-#define sge_GetRGBA(pixel, fmt, r, g, b, a) SDL_GetRGBA(pixel, fmt, r, g, b)
-#endif
 
 /*
  *  Some compilers use a special export keyword
diff --git a/external/s25edit/SGE/include/SGE/sge_shape.h b/external/s25edit/SGE/include/SGE/sge_shape.h
index 6dd0087..01c6fce 100644
--- a/external/s25edit/SGE/include/SGE/sge_shape.h
+++ b/external/s25edit/SGE/include/SGE/sge_shape.h
@@ -36,43 +36,6 @@
 struct sge_cdata;
 class DECLSPEC sge_shape;
 
-//==================================================================================
-// The screen class
-//==================================================================================
-class DECLSPEC sge_screen
-{
-protected:
-    SDL_Surface* screen;         // The SDL screen surface
-    std::vector<SDL_Rect> rects; // The list of rectangles to be updated
-
-    std::list<sge_shape*> shapes;   // The list of shapes to draw on screen
-    std::list<sge_shape*> shapes_p; // The list of permanent shapes to draw on screen
-
-    using RI = std::list<SDL_Rect>::const_iterator;   // List iterator (for rects)
-    using SI = std::list<sge_shape*>::const_iterator; // List iterator (for shapes)
-
-    bool HW, DB, FS; // video memory, double-buffered or/and fullscreen?
-
-public:
-    sge_screen(SDL_Surface* screen);
-    ~sge_screen()
-    {
-        rects.clear();
-        shapes.clear();
-        shapes_p.clear();
-    }
-    void add_rect(SDL_Rect rect);
-    void add_rect(Sint16 x, Sint16 y, Uint32 w, Uint32 h);
-
-    void add_shape(sge_shape* shape);
-    void add_shape_p(sge_shape* shape); // Adds an shape permanently
-
-    void remove_shape_p(sge_shape* shape);
-    void clear_all();
-
-    void update();
-};
-
 //==================================================================================
 // sge_shape
 // Abstract base class for different shapes (surfaces, sprites, ...)
@@ -90,10 +53,6 @@ public:
     virtual ~sge_shape() = default; // Destructor
     virtual void draw() = 0;        // Draws the shape - prev_pos = last_pos; last_pos = the new position of shape
 
-    // Updates the screen (last_pos+prev_pos)
-    // If sge_screen is used this member will use it (the_screen) instead of doing it directly!
-    virtual void UpdateRects() = 0;
-
     // Some functions to clear (remove) shape
     virtual void clear(Uint32 color) = 0;                               // Clears to color
     virtual void clear(SDL_Surface* src, Sint16 srcX, Sint16 srcY) = 0; // Clears by blitting src
@@ -172,7 +131,6 @@ protected:
 
     // Helper functions
     void warp_draw();
-    void warp_update(SDL_Rect rec);
     void warp_clear(Uint32 color);
     void warp_clear(SDL_Surface* src, Sint16 srcX, Sint16 srcY);
 
@@ -187,8 +145,6 @@ public:
     virtual void clear(SDL_Surface* src, Sint16 srcX, Sint16 srcY) override;
     // virtual void clear(SDL_Surface *src){clear(src,last_pos.x,last_pos.y);}
 
-    virtual void UpdateRects() override;
-
     // Move the surface
     virtual void move_to(Sint16 x, Sint16 y)
     {
diff --git a/external/s25edit/SGE/include/SGE/sge_surface.h b/external/s25edit/SGE/include/SGE/sge_surface.h
index 1360fd6..075f75c 100644
--- a/external/s25edit/SGE/include/SGE/sge_surface.h
+++ b/external/s25edit/SGE/include/SGE/sge_surface.h
@@ -30,20 +30,14 @@
 #define sge_get_sblock16 sge_read_block16
 #define sge_get_sblock32 sge_read_block32
 
-DECLSPEC void sge_UpdateRect(SDL_Surface* screen, Sint16 x, Sint16 y, Uint16 w, Uint16 h);
-DECLSPEC void sge_UpdateRect(SDL_Surface* screen, const SDL_Rect& area);
 #ifdef _SGE_C
 extern "C" {
 #endif
-DECLSPEC void sge_Update_OFF();
-DECLSPEC void sge_Update_ON();
 DECLSPEC void sge_Lock_OFF();
 DECLSPEC void sge_Lock_ON();
-DECLSPEC Uint8 sge_getUpdate();
 DECLSPEC Uint8 sge_getLock();
 DECLSPEC SDL_Surface* sge_CreateAlphaSurface(Uint32 flags, int width, int height);
 DECLSPEC Uint32 sge_MapAlpha(Uint8 R, Uint8 G, Uint8 B, Uint8 A);
-DECLSPEC SGE_ATTRIBUTE_FORMAT(1, 2) void sge_SetError(const char* format, ...);
 
 DECLSPEC void _PutPixel(SDL_Surface* surface, Sint16 x, Sint16 y, Uint32 color);
 DECLSPEC void _PutPixel8(SDL_Surface* surface, Sint16 x, Sint16 y, Uint32 color);
diff --git a/external/s25edit/SGE/include/SGE/sge_textpp.h b/external/s25edit/SGE/include/SGE/sge_textpp.h
deleted file mode 100644
index eb6a0a5..0000000
--- a/external/s25edit/SGE/include/SGE/sge_textpp.h
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
- *	SDL Graphics Extension
- *	Text/TrueType classes (header)
- *
- *	Started 990826 / 010207 (new version)
- *
- *	License: LGPL v2+ (see the file LICENSE)
- *	(c)1999-2003 Anders LindstrÃ¶m
- *
- *	Uses the excellent FreeType 2 library, available at:
- *	http://www.freetype.org/
- */
-
-/*********************************************************************
- *  This library is free software; you can redistribute it and/or    *
- *  modify it under the terms of the GNU Library General Public      *
- *  License as published by the Free Software Foundation; either     *
- *  version 2 of the License, or (at your option) any later version. *
- *********************************************************************/
-
-#ifndef sge_textpp_H
-#define sge_textpp_H
-
-#include "sge_internal.h"
-
-#ifndef _SGE_NO_CLASSES
-
-#include "sge_shape.h"
-#include <string>
-
-struct sge_bmpFont;
-
-//==================================================================================
-// Edits text from SDL_Event
-//==================================================================================
-class DECLSPEC sge_TextEditor
-{
-protected:
-    // The text is stored in a double linked list
-
-    // The elements in the linked list
-    struct node
-    {
-        Uint16 c; // Unicode char
-
-        node* next;
-        node* prev;
-    };
-
-    // List metadata
-    node* start;
-    node* end;
-    node* cursor; // The current node (the cursor)
-
-    Uint16 cursor_char;  // The charactar for the cursor
-    unsigned int chars;  // Size of the string (without the cursor)
-    unsigned int mChars; // Max chars, 0 is default (unlimited)
-
-    // Create and fill a new node
-    node* new_node(node* p, node* n, Uint16 c);
-
-    // Swap two nodes
-    bool nswap(node* one, node* two);
-
-    // This indicates that the text has changed since last
-    // set to false (used for derived classes)
-    bool text_changed;
-
-public:
-    // Creator
-    sge_TextEditor();
-    // Destructor
-    virtual ~sge_TextEditor();
-
-    // Adds an char before the cursor
-    bool insert(Uint16 c);
-    // Removes the char left of cursor
-    bool remove_left();
-    // Removes the char right of cursor
-    bool remove_right();
-
-    // Move cursor left
-    inline bool move_left();
-    // Move cursor right
-    inline bool move_right();
-    // Move cursor to the start
-    bool move_start();
-    // Move cursor to the end
-    bool move_end();
-
-    // Returns text as latin1 or unicode with or without the cursor char
-    std::string get_string(bool wCursor = true);
-    // std::basic_string<Uint16> get_ustring(bool wCursor=true);
-    // Returns a unicode c-style string (allocated with new)
-    Uint16* get_ucstring(bool wCursor = true);
-
-    // Process a SDL_Event
-    // Returns true if the text changed
-    virtual bool check(SDL_Event* event);
-
-    // Change the cursor char
-    void change_cursor(Uint16 c)
-    {
-        cursor_char = c;
-        cursor->c = c;
-    }
-
-    // Change the text
-    void clear_text();
-    void change_text(const std::string& s);
-    // void change_utext(const std::basic_string<Uint16> s);
-    void change_uctext(Uint16* text);
-    SGE_ATTRIBUTE_FORMAT(2, 3) void change_textf(const char* text, ...); // printf c-style... urk
-
-    // Set max chars (default: limited only by memory)
-    void max_chars(unsigned int c) { mChars = c; }
-
-    // Returns the number of characters in the current string
-    unsigned int get_chars() { return chars; }
-};
-
-//==================================================================================
-// A class for rendering text
-//==================================================================================
-class DECLSPEC sge_text : public sge_TextEditor
-{
-protected:
-#ifndef _SGE_NOTTF
-    sge_TTFont* tt_font; // The truetype font
-#else
-    Uint8* tt_font;
-#endif
-
-    // TT Font color
-    SDL_Color color;
-    SDL_Color background;
-
-    sge_bmpFont* bm_font; // The bitmap font
-
-    Uint8 alpha_level; // Alpha level (default: opaque)
-
-    SDL_Surface* text_surface;
-    virtual void set_textSurface(SDL_Surface*) = 0;
-
-    // Use what render?
-    bool use_tt;
-
-    // Show cursor when rendering text?
-    bool sCursor;
-
-public:
-    // Constructor
-    sge_text()
-    {
-        tt_font = nullptr;
-        color.r = color.b = color.g = 0;
-        background.r = background.b = background.g = 0;
-        bm_font = nullptr;
-        alpha_level = SDL_ALPHA_OPAQUE;
-        text_surface = nullptr;
-        use_tt = true;
-        sCursor = false;
-    }
-    virtual ~sge_text()
-    {
-        if(text_surface)
-        {
-            SDL_FreeSurface(text_surface);
-        }
-    }
-
-    // Get a pointer to the text surface or (if copy=true) returns
-    // a copy (don't forget to free it later)
-    SDL_Surface* get_textSurface(bool copy = false);
-
-    // Updates the textsurface if the text has changed (or if force=true)
-    // and returns true if the surface was updated
-    bool update_textSurface(bool force = false);
-
-#ifndef _SGE_NOTTF
-    void set_ttFont(sge_TTFont* font, Uint8 r, Uint8 g, Uint8 b, Uint8 br = 0, Uint8 bg = 0, Uint8 bb = 0);
-#endif
-
-    bool get_color(SDL_Color* fg)
-    {
-        if(tt_font)
-        {
-            fg->r = color.r;
-            fg->g = color.g;
-            fg->b = color.b;
-            return true;
-        } else
-            return false;
-    }
-    bool get_bg(SDL_Color* bg)
-    {
-        if(tt_font)
-        {
-            bg->r = background.r;
-            bg->g = background.g;
-            bg->b = background.b;
-            return true;
-        } else
-            return false;
-    }
-
-    void set_bmFont(sge_bmpFont* font);
-
-    // Should a cursor be drawn?
-    void show_cursor(bool mode)
-    {
-        if(mode != sCursor)
-        {
-            text_changed = true;
-        }
-        sCursor = mode;
-    }
-
-    // Render text to a surface
-    SDL_Rect render_text(SDL_Surface* surface, Sint16 x, Sint16 y);
-
-    void use_TTrender()
-    {
-        if(tt_font)
-        {
-            use_tt = true;
-        }
-    }
-    void use_BMrender()
-    {
-        if(bm_font)
-        {
-            use_tt = false;
-        }
-    }
-
-    // set alpha level (default: opaque)
-    void set_alpha(Uint8 alpha) { alpha_level = alpha; }
-};
-
-//==================================================================================
-// sge_TextSurface (derived public from sge_text and sge_surface)
-// sge_TextSsprite (derived public from sge_text and sge_ssprite)
-// sge_TextSprite  (derived public from sge_text and sge_sprite)
-//==================================================================================
-class DECLSPEC sge_TextSurface : public sge_text, public sge_surface
-{
-protected:
-    virtual void set_textSurface(SDL_Surface* new_surf) override;
-
-public:
-    sge_TextSurface(SDL_Surface* screen, Sint16 x = 0, Sint16 y = 0) : sge_surface(screen, screen, x, y)
-    {
-        surface = nullptr;
-        current_pos.w = 0;
-        current_pos.h = 0;
-    }
-
-    sge_TextSurface(SDL_Surface* screen, const std::string& text, Sint16 x = 0, Sint16 y = 0) : sge_surface(screen, screen, x, y)
-    {
-        change_text(text);
-        current_pos.w = 0;
-        current_pos.h = 0;
-    }
-
-    virtual void draw() override;
-};
-
-class DECLSPEC sge_TextSsprite : public sge_text, public sge_ssprite
-{
-protected:
-    virtual void set_textSurface(SDL_Surface* new_surf) override;
-
-public:
-    sge_TextSsprite(SDL_Surface* screen, Sint16 x = 0, Sint16 y = 0) : sge_ssprite(screen, screen, x, y)
-    {
-        surface = nullptr;
-        current_pos.w = 0;
-        current_pos.h = 0;
-    }
-
-    sge_TextSsprite(SDL_Surface* screen, const std::string& text, Sint16 x = 0, Sint16 y = 0) : sge_ssprite(screen, screen, x, y)
-    {
-        change_text(text);
-        current_pos.w = 0;
-        current_pos.h = 0;
-    }
-
-    virtual void draw() override;
-};
-
-class DECLSPEC sge_TextSprite : public sge_text, public sge_sprite
-{
-protected:
-    virtual void set_textSurface(SDL_Surface* new_surf) override;
-
-public:
-    sge_TextSprite(SDL_Surface* screen, Sint16 x = 0, Sint16 y = 0) : sge_sprite(screen, screen, x, y)
-    {
-        surface = nullptr;
-        current_pos.w = 0;
-        current_pos.h = 0;
-    }
-
-    sge_TextSprite(SDL_Surface* screen, const std::string& text, Sint16 x = 0, Sint16 y = 0) : sge_sprite(screen, screen, x, y)
-    {
-        change_text(text);
-        current_pos.w = 0;
-        current_pos.h = 0;
-    }
-
-    virtual void draw() override;
-};
-
-//==================================================================================
-// A helper function for lazy users: blocking text input for sge_TextSurface
-// objects.
-// Flags is the same as for BM and TTF input (which now uses this function)
-//==================================================================================
-DECLSPEC int sge_text_input(sge_TextSurface* tc, Uint8 flags);
-
-#endif /* _SGE_NO_CLASSES */
-#endif /* sge_textpp_H */
diff --git a/external/s25edit/SGE/include/SGE/sge_tt_text.h b/external/s25edit/SGE/include/SGE/sge_tt_text.h
deleted file mode 100644
index 29dd624..0000000
--- a/external/s25edit/SGE/include/SGE/sge_tt_text.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- *	SDL Graphics Extension
- *	Text/TrueType functions (header)
- *
- *	Started 990815
- *
- *	License: LGPL v2+ (see the file LICENSE)
- *	(c)1999-2003 Anders LindstrÃ¶m
- *
- *	Uses the excellent FreeType 2 library, available at:
- *	http://www.freetype.org/
- */
-
-/*********************************************************************
- *  This library is free software; you can redistribute it and/or    *
- *  modify it under the terms of the GNU Library General Public      *
- *  License as published by the Free Software Foundation; either     *
- *  version 2 of the License, or (at your option) any later version. *
- *********************************************************************/
-
-#ifndef sge_tt_text_H
-#define sge_tt_text_H
-
-#include "sge_internal.h"
-
-/* Text input flags */
-#define SGE_IBG SGE_FLAG1
-#define SGE_IDEL SGE_FLAG2
-#define SGE_INOKR SGE_FLAG3
-
-#ifndef _SGE_NOTTF
-
-/* the truetype font structure */
-using sge_TTFont = struct _sge_TTFont;
-
-/* Font style */
-#define SGE_TTF_NORMAL SGE_FLAG0
-#define SGE_TTF_BOLD SGE_FLAG1
-#define SGE_TTF_ITALIC SGE_FLAG2
-#define SGE_TTF_UNDERLINE SGE_FLAG3
-
-/* ZERO WIDTH NO-BREAKSPACE (Unicode byte order mark) */
-#define UNICODE_BOM_NATIVE 0xFEFF
-#define UNICODE_BOM_SWAPPED 0xFFFE
-
-#endif /* _SGE_NOTTF */
-
-#ifdef _SGE_C
-extern "C" {
-#endif
-#ifndef _SGE_NOTTF
-DECLSPEC void sge_TTF_AAOff();
-DECLSPEC void sge_TTF_AAOn();
-DECLSPEC void sge_TTF_AA_Alpha();
-DECLSPEC void sge_TTF_ByteSwappedUNICODE(int swapped);
-
-DECLSPEC int sge_TTF_Init();
-DECLSPEC sge_TTFont* sge_TTF_OpenFont(const char* file, int ptsize);
-DECLSPEC sge_TTFont* sge_TTF_OpenFontRW(SDL_RWops* src, int freesrc, int ptsize, int xdpi, int ydpi);
-DECLSPEC sge_TTFont* sge_TTF_OpenFontIndex(const char* file, int ptsize, long index, int xdpi, int ydpi);
-DECLSPEC sge_TTFont* sge_TTF_OpenFontIndexRW(SDL_RWops* src, int freesrc, int ptsize, long index, int xdpi, int ydpi);
-DECLSPEC int sge_TTF_SetFontSize(sge_TTFont* font, int ptsize);
-DECLSPEC int sge_TTF_SetFontSizeDPI(sge_TTFont* font, int ptsize, int xdpi, int ydpi);
-
-DECLSPEC int sge_TTF_FontHeight(sge_TTFont* font);
-DECLSPEC int sge_TTF_FontAscent(sge_TTFont* font);
-DECLSPEC int sge_TTF_FontDescent(sge_TTFont* font);
-DECLSPEC int sge_TTF_FontLineSkip(sge_TTFont* font);
-DECLSPEC long sge_TTF_FontFaces(sge_TTFont* font);
-DECLSPEC int sge_TTF_FontFaceIsFixedWidth(sge_TTFont* font);
-DECLSPEC char* sge_TTF_FontFaceFamilyName(sge_TTFont* font);
-DECLSPEC char* sge_TTF_FontFaceStyleName(sge_TTFont* font);
-
-DECLSPEC void sge_TTF_SetFontStyle(sge_TTFont* font, Uint8 style);
-DECLSPEC Uint8 sge_TTF_GetFontStyle(sge_TTFont* font);
-
-DECLSPEC void sge_TTF_CloseFont(sge_TTFont* font);
-
-DECLSPEC SDL_Rect sge_TTF_TextSizeUNI(sge_TTFont* font, const Uint16* text);
-DECLSPEC SDL_Rect sge_TTF_TextSize(sge_TTFont* Font, char* Text);
-
-DECLSPEC SDL_Rect sge_tt_textout(SDL_Surface* Surface, sge_TTFont* font, const char* string, Sint16 x, Sint16 y, Uint32 fcolor,
-                                 Uint32 bcolor, int Alpha);
-DECLSPEC SDL_Rect sge_tt_textout_UTF8(SDL_Surface* Surface, sge_TTFont* font, const char* string, Sint16 x, Sint16 y, Uint32 fcolor,
-                                      Uint32 bcolor, int Alpha);
-DECLSPEC SDL_Rect sge_tt_textout_UNI(SDL_Surface* Surface, sge_TTFont* font, const Uint16* uni, Sint16 x, Sint16 y, Uint32 fcolor,
-                                     Uint32 bcolor, int Alpha);
-
-DECLSPEC SDL_Rect sge_tt_textoutf(SDL_Surface* Surface, sge_TTFont* font, Sint16 x, Sint16 y, Uint8 fR, Uint8 fG, Uint8 fB, Uint8 bR,
-                                  Uint8 bG, Uint8 bB, int Alpha, char* format, ...);
-
-DECLSPEC int sge_tt_input_UNI(SDL_Surface* screen, sge_TTFont* font, Uint16* string, Uint8 flags, int pos, int len, Sint16 x, Sint16 y,
-                              Uint32 fcol, Uint32 bcol, int Alpha);
-DECLSPEC int sge_tt_input(SDL_Surface* screen, sge_TTFont* font, char* string, Uint8 flags, int pos, int len, Sint16 x, Sint16 y,
-                          Uint32 fcol, Uint32 bcol, int Alpha);
-
-DECLSPEC SDL_Surface* sge_TTF_Render(sge_TTFont* font, const Uint16* text, SDL_Color fg, SDL_Color bg, int alpha_level);
-DECLSPEC SDL_Surface* sge_TTF_RenderUNICODE(sge_TTFont* font, const Uint16* text, SDL_Color fg, SDL_Color bg);
-#endif /* _SGE_NOTTF */
-
-DECLSPEC Uint16* sge_Latin1_Uni(const char* text);
-#ifdef _SGE_C
-}
-#endif
-
-#ifndef sge_C_ONLY
-#ifndef _SGE_NOTTF
-DECLSPEC SDL_Rect sge_tt_textout(SDL_Surface* Surface, sge_TTFont* font, const char* string, Sint16 x, Sint16 y, Uint8 fR, Uint8 fG,
-                                 Uint8 fB, Uint8 bR, Uint8 bG, Uint8 bB, int Alpha);
-DECLSPEC SDL_Rect sge_tt_textout_UTF8(SDL_Surface* Surface, sge_TTFont* font, const char* string, Sint16 x, Sint16 y, Uint8 fR, Uint8 fG,
-                                      Uint8 fB, Uint8 bR, Uint8 bG, Uint8 bB, int Alpha);
-DECLSPEC SDL_Rect sge_tt_textout_UNI(SDL_Surface* Surface, sge_TTFont* font, const Uint16* uni, Sint16 x, Sint16 y, Uint8 fR, Uint8 fG,
-                                     Uint8 fB, Uint8 bR, Uint8 bG, Uint8 bB, int Alpha);
-DECLSPEC int sge_tt_input_UNI(SDL_Surface* screen, sge_TTFont* font, Uint16* string, Uint8 flags, int pos, int len, Sint16 x, Sint16 y,
-                              Uint8 fR, Uint8 fG, Uint8 fB, Uint8 bR, Uint8 bG, Uint8 bB, int Alpha);
-DECLSPEC int sge_tt_input(SDL_Surface* screen, sge_TTFont* font, char* string, Uint8 flags, int pos, int len, Sint16 x, Sint16 y, Uint8 fR,
-                          Uint8 fG, Uint8 fB, Uint8 bR, Uint8 bG, Uint8 bB, int Alpha);
-#endif /* _SGE_NOTTF */
-#endif /* sge_C_ONLY */
-
-#endif /* sge_tt_text_H */
diff --git a/external/s25edit/SGE/sge_blib.cpp b/external/s25edit/SGE/sge_blib.cpp
index e344793..da7b6b9 100644
--- a/external/s25edit/SGE/sge_blib.cpp
+++ b/external/s25edit/SGE/sge_blib.cpp
@@ -24,10 +24,8 @@
 #include "sge_primitives.h"
 #include "sge_primitives_int.h"
 #include "sge_surface.h"
-#include <boost/numeric/conversion/cast.hpp>
 #include <array>
 
-using boost::numeric_cast;
 using FixedPoint = s25edit::FixedPoint<Sint32, 16>;
 using UFixedPoint = s25edit::FixedPoint<Uint32, 16>;
 
@@ -36,8 +34,7 @@ using UFixedPoint = s25edit::FixedPoint<Uint32, 16>;
     (x) = y;             \
     (y) = temp
 
-/* Globals used for sge_Update/sge_Lock (defined in sge_surface) */
-extern Uint8 _sge_update;
+/* Globals used for sge_Lock (defined in sge_surface) */
 extern Uint8 _sge_lock;
 extern Uint8 _sge_alpha_hack;
 
@@ -205,12 +202,6 @@ void sge_FadedLine(SDL_Surface* dest, Sint16 x1, Sint16 x2, Sint16 y, Uint8 r1,
 
     if(_sge_lock && SDL_MUSTLOCK(dest))
         SDL_UnlockSurface(dest);
-
-    if(!_sge_update)
-    {
-        return;
-    }
-    sge_UpdateRect(dest, x1, y, absDiff(x1, x2) + 1, 1);
 }
 
 template<int dstBytesPerPixel>
@@ -304,6 +295,14 @@ static void _CopyPixelsWithDifferentFormat(SDL_Surface* dest, Sint16 y, Sint16 x
     }
 }
 
+static Uint32 _GetColorKey(SDL_Surface* surf)
+{
+    Uint32 colorkey;
+    if(SDL_GetColorKey(surf, &colorkey) != 0)
+        throw std::invalid_argument("No colorkey set");
+    return colorkey;
+}
+
 //==================================================================================
 // Draws a horisontal, textured line
 //==================================================================================
@@ -352,6 +351,7 @@ static void _TexturedLine(SDL_Surface* dest, Sint16 x1, Sint16 x2, Sint16 y, SDL
         {
             case 1:
             { /* Assuming 8-bpp */
+                const Uint32 colorkey = _GetColorKey(source);
                 Uint8* row = (Uint8*)dest->pixels + y * dest->pitch;
 
                 for(int x = x1; x <= x2; x++)
@@ -360,7 +360,7 @@ static void _TexturedLine(SDL_Surface* dest, Sint16 x1, Sint16 x2, Sint16 y, SDL
 
                     const auto pixel_value = *((Uint8*)source->pixels + srcy.toInt() * source->pitch + srcx.toInt());
 
-                    if(pixel_value != source->format->colorkey)
+                    if(pixel_value != colorkey)
                         *pixel = pixel_value;
 
                     srcx += xstep;
@@ -416,7 +416,7 @@ static void _TexturedLine(SDL_Surface* dest, Sint16 x1, Sint16 x2, Sint16 y, SDL
                 Uint32* pixel = (Uint32*)dest->pixels + y * dest->pitch / sizeof(Uint32) + x1;
 
                 const Uint16 pitch = source->pitch / sizeof(Uint32);
-                const Uint32 colorkey = source->format->colorkey;
+                const Uint32 colorkey = _GetColorKey(source);
 
                 for(int x = x1; x <= x2; x++, ++pixel)
                 {
@@ -615,12 +615,6 @@ void sge_FadedTexturedLine(SDL_Surface* dest, Sint16 x1, Sint16 x2, Sint16 y, SD
         SDL_UnlockSurface(dest);
     if(_sge_lock && SDL_MUSTLOCK(source))
         SDL_UnlockSurface(source);
-
-    if(!_sge_update)
-    {
-        return;
-    }
-    sge_UpdateRect(dest, x1, y, absDiff(x1, x2) + 1, 1);
 }
 
 //==================================================================================
@@ -638,23 +632,6 @@ void sge_Trigon(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, S
 
     if(_sge_lock && SDL_MUSTLOCK(dest))
         SDL_UnlockSurface(dest);
-
-    if(!_sge_update)
-    {
-        return;
-    }
-
-    Sint16 xmax = x1, ymax = y1, xmin = x1, ymin = y1;
-    xmax = (xmax > x2) ? xmax : x2;
-    ymax = (ymax > y2) ? ymax : y2;
-    xmin = (xmin < x2) ? xmin : x2;
-    ymin = (ymin < y2) ? ymin : y2;
-    xmax = (xmax > x3) ? xmax : x3;
-    ymax = (ymax > y3) ? ymax : y3;
-    xmin = (xmin < x3) ? xmin : x3;
-    ymin = (ymin < y3) ? ymin : y3;
-
-    sge_UpdateRect(dest, xmin, ymin, numeric_cast<Uint16>(xmax - xmin + 1), numeric_cast<Uint16>(ymax - ymin + 1));
 }
 
 void sge_Trigon(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Sint16 x3, Sint16 y3, Uint8 R, Uint8 G, Uint8 B)
@@ -677,23 +654,6 @@ void sge_TrigonAlpha(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint16
 
     if(_sge_lock && SDL_MUSTLOCK(dest))
         SDL_UnlockSurface(dest);
-
-    if(!_sge_update)
-    {
-        return;
-    }
-
-    Sint16 xmax = x1, ymax = y1, xmin = x1, ymin = y1;
-    xmax = (xmax > x2) ? xmax : x2;
-    ymax = (ymax > y2) ? ymax : y2;
-    xmin = (xmin < x2) ? xmin : x2;
-    ymin = (ymin < y2) ? ymin : y2;
-    xmax = (xmax > x3) ? xmax : x3;
-    ymax = (ymax > y3) ? ymax : y3;
-    xmin = (xmin < x3) ? xmin : x3;
-    ymin = (ymin < y3) ? ymin : y3;
-
-    sge_UpdateRect(dest, xmin, ymin, numeric_cast<Uint16>(xmax - xmin + 1), numeric_cast<Uint16>(ymax - ymin + 1));
 }
 
 void sge_TrigonAlpha(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Sint16 x3, Sint16 y3, Uint8 R, Uint8 G, Uint8 B,
@@ -717,23 +677,6 @@ void sge_AATrigonAlpha(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint1
 
     if(_sge_lock && SDL_MUSTLOCK(dest))
         SDL_UnlockSurface(dest);
-
-    if(!_sge_update)
-    {
-        return;
-    }
-
-    Sint16 xmax = x1, ymax = y1, xmin = x1, ymin = y1;
-    xmax = (xmax > x2) ? xmax : x2;
-    ymax = (ymax > y2) ? ymax : y2;
-    xmin = (xmin < x2) ? xmin : x2;
-    ymin = (ymin < y2) ? ymin : y2;
-    xmax = (xmax > x3) ? xmax : x3;
-    ymax = (ymax > y3) ? ymax : y3;
-    xmin = (xmin < x3) ? xmin : x3;
-    ymin = (ymin < y3) ? ymin : y3;
-
-    sge_UpdateRect(dest, xmin, ymin, xmax - xmin + 1, ymax - ymin + 1);
 }
 
 void sge_AATrigonAlpha(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Sint16 x3, Sint16 y3, Uint8 R, Uint8 G, Uint8 B,
@@ -832,19 +775,6 @@ void sge_FilledTrigon(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint16
             xc += m3;
         }
     }
-
-    if(!_sge_update)
-    {
-        return;
-    }
-
-    Sint16 xmax = x1, xmin = x1;
-    xmax = (xmax > x2) ? xmax : x2;
-    xmin = (xmin < x2) ? xmin : x2;
-    xmax = (xmax > x3) ? xmax : x3;
-    xmin = (xmin < x3) ? xmin : x3;
-
-    sge_UpdateRect(dest, xmin, y1, numeric_cast<Uint16>(xmax - xmin + 1), numeric_cast<Uint16>(y3 - y1 + 1));
 }
 
 void sge_FilledTrigon(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Sint16 x3, Sint16 y3, Uint8 R, Uint8 G, Uint8 B)
@@ -923,19 +853,6 @@ void sge_FilledTrigonAlpha(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, S
 
     if(_sge_lock && SDL_MUSTLOCK(dest))
         SDL_UnlockSurface(dest);
-
-    if(!_sge_update)
-    {
-        return;
-    }
-
-    Sint16 xmax = x1, xmin = x1;
-    xmax = (xmax > x2) ? xmax : x2;
-    xmin = (xmin < x2) ? xmin : x2;
-    xmax = (xmax > x3) ? xmax : x3;
-    xmin = (xmin < x3) ? xmin : x3;
-
-    sge_UpdateRect(dest, xmin, y1, numeric_cast<Uint16>(xmax - xmin + 1), numeric_cast<Uint16>(y3 - y1 + 1));
 }
 
 void sge_FilledTrigonAlpha(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Sint16 x3, Sint16 y3, Uint8 R, Uint8 G, Uint8 B,
@@ -1085,19 +1002,6 @@ void sge_FadedTrigon(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint16
 
     if(_sge_lock && SDL_MUSTLOCK(dest))
         SDL_UnlockSurface(dest);
-
-    if(!_sge_update)
-    {
-        return;
-    }
-
-    Sint16 xmax = x1, xmin = x1;
-    xmax = (xmax > x2) ? xmax : x2;
-    xmin = (xmin < x2) ? xmin : x2;
-    xmax = (xmax > x3) ? xmax : x3;
-    xmin = (xmin < x3) ? xmin : x3;
-
-    sge_UpdateRect(dest, xmin, y1, xmax - xmin + 1, y3 - y1 + 1);
 }
 
 //==================================================================================
@@ -1234,19 +1138,6 @@ static void _TexturedTrigon(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2,
         SDL_UnlockSurface(dest);
     if(_sge_lock && SDL_MUSTLOCK(source))
         SDL_UnlockSurface(source);
-
-    if(!_sge_update)
-    {
-        return;
-    }
-
-    Sint16 xmax = x1, xmin = x1;
-    xmax = (xmax > x2) ? xmax : x2;
-    xmin = (xmin < x2) ? xmin : x2;
-    xmax = (xmax > x3) ? xmax : x3;
-    xmin = (xmin < x3) ? xmin : x3;
-
-    sge_UpdateRect(dest, xmin, y1, numeric_cast<Uint16>(xmax - xmin + 1), numeric_cast<Uint16>(y3 - y1 + 1));
 }
 
 void sge_TexturedTrigon(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Sint16 x3, Sint16 y3, SDL_Surface* source,
@@ -1436,19 +1327,6 @@ static void _FadedTexturedTrigonColorKeys(SDL_Surface* dest, Sint16 x1, Sint16 y
         SDL_UnlockSurface(dest);
     if(_sge_lock && SDL_MUSTLOCK(source))
         SDL_UnlockSurface(source);
-
-    if(!_sge_update)
-    {
-        return;
-    }
-
-    Sint16 xmax = x1, xmin = x1;
-    xmax = (xmax > x2) ? xmax : x2;
-    xmin = (xmin < x2) ? xmin : x2;
-    xmax = (xmax > x3) ? xmax : x3;
-    xmin = (xmin < x3) ? xmin : x3;
-
-    sge_UpdateRect(dest, xmin, y1, numeric_cast<Uint16>(xmax - xmin + 1), numeric_cast<Uint16>(y3 - y1 + 1));
 }
 
 void sge_FadedTexturedTrigonColorKeys(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Sint16 x3, Sint16 y3,
@@ -1663,21 +1541,6 @@ static void _TexturedRect(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Si
 
     if(_sge_lock && SDL_MUSTLOCK(dest))
         SDL_UnlockSurface(dest);
-
-    if(!_sge_update)
-    {
-        return;
-    }
-
-    Sint16 xmax = x1, xmin = x1;
-    xmax = (xmax > x2) ? xmax : x2;
-    xmin = (xmin < x2) ? xmin : x2;
-    xmax = (xmax > x3) ? xmax : x3;
-    xmin = (xmin < x3) ? xmin : x3;
-    xmax = (xmax > x4) ? xmax : x4;
-    xmin = (xmin < x4) ? xmin : x4;
-
-    sge_UpdateRect(dest, xmin, y1, xmax - xmin + 1, y4 - y1 + 1);
 }
 
 void sge_TexturedRect(SDL_Surface* dest, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Sint16 x3, Sint16 y3, Sint16 x4, Sint16 y4,
@@ -1971,13 +1834,6 @@ int sge_FilledPolygonAlpha(SDL_Surface* dest, Uint16 n, const Sint16* x, const S
     delete[] line;
     delete[] plist;
 
-    if(!_sge_update)
-    {
-        return 0;
-    }
-
-    sge_UpdateRect(dest, xmin, ymin, xmax - xmin + 1, ymax - ymin + 1);
-
     return 0;
 }
 
@@ -2133,13 +1989,6 @@ int sge_AAFilledPolygon(SDL_Surface* dest, Uint16 n, const Sint16* x, const Sint
     delete[] line;
     delete[] plist;
 
-    if(!_sge_update)
-    {
-        return 0;
-    }
-
-    sge_UpdateRect(dest, xmin, ymin, xmax - xmin + 1, ymax - ymin + 1);
-
     return 0;
 }
 
@@ -2365,13 +2214,6 @@ int sge_FadedPolygonAlpha(SDL_Surface* dest, Uint16 n, const Sint16* x, const Si
     delete[] line;
     delete[] plist;
 
-    if(!_sge_update)
-    {
-        return 0;
-    }
-
-    sge_UpdateRect(dest, xmin, ymin, xmax - xmin + 1, ymax - ymin + 1);
-
     return 0;
 }
 
@@ -2559,12 +2401,5 @@ int sge_AAFadedPolygon(SDL_Surface* dest, Uint16 n, const Sint16* x, const Sint1
     delete[] line;
     delete[] plist;
 
-    if(!_sge_update)
-    {
-        return 0;
-    }
-
-    sge_UpdateRect(dest, xmin, ymin, xmax - xmin + 1, ymax - ymin + 1);
-
     return 0;
 }
diff --git a/external/s25edit/SGE/sge_bm_text.cpp b/external/s25edit/SGE/sge_bm_text.cpp
deleted file mode 100644
index 46b7d8a..0000000
--- a/external/s25edit/SGE/sge_bm_text.cpp
+++ /dev/null
@@ -1,515 +0,0 @@
-/*
- *	SDL Graphics Extension
- *	Text/Bitmap font functions
- *
- *	Started 990815
- *
- *	License: LGPL v2+ (see the file LICENSE)
- *	(c)1999-2003 Anders LindstrÃ¶m
- */
-
-/*********************************************************************
- *  This library is free software; you can redistribute it and/or    *
- *  modify it under the terms of the GNU Library General Public      *
- *  License as published by the Free Software Foundation; either     *
- *  version 2 of the License, or (at your option) any later version. *
- *********************************************************************/
-
-/*
- *  Some of this is taken from SDL_DrawText by Garrett Banuk (mongoose@wpi.edu)
- *  http://www.wpi.edu/~mongoose/SDL_Console
- *  Thanks to Karl Bartel for the SFont format!
- */
-
-#include "sge_bm_text.h"
-#include "sge_surface.h"
-#include "sge_textpp.h"
-#include <array>
-#include <cstdarg>
-#include <cstring>
-#include <new>
-
-#ifdef _SGE_HAVE_IMG
-#include <SDL_image.h>
-#endif
-
-using namespace std;
-
-/* Globals used for sge_Update/sge_Lock (defined in sge_surface) */
-extern Uint8 _sge_update;
-extern Uint8 _sge_lock;
-
-//==================================================================================
-// Creates a new font from a surface
-//==================================================================================
-sge_bmpFont* sge_BF_CreateFont(SDL_Surface* surface, Uint8 flags)
-{
-    sge_bmpFont* font;
-
-    font = new(nothrow) sge_bmpFont;
-    if(!font)
-    {
-        SDL_SetError("SGE - Out of memory");
-        return nullptr;
-    }
-
-    if(!(flags & SGE_BFNOCONVERT) && !(flags & SGE_BFSFONT))
-    { /* Get a converted copy */
-        font->FontSurface = SDL_DisplayFormat(surface);
-        if(!font->FontSurface)
-        {
-            SDL_SetError("SGE - Out of memory");
-            delete font;
-            return nullptr;
-        }
-
-        if(flags & SGE_BFPALETTE)
-        { // We want an 8bit surface
-            SDL_Surface* tmp;
-            tmp = SDL_AllocSurface(SDL_SWSURFACE, surface->w, surface->h, 8, 0, 0, 0, 0);
-            if(!tmp)
-            {
-                SDL_SetError("SGE - Out of memory");
-                SDL_FreeSurface(font->FontSurface);
-                delete font;
-                return nullptr;
-            }
-
-            // Set the palette
-            std::array<SDL_Color, 2> c;
-            c[0].r = 0;
-            c[1].r = 255;
-            c[0].g = 0;
-            c[1].g = 255;
-            c[0].b = 0;
-            c[1].b = 255;
-            SDL_SetColors(tmp, c.data(), 0, c.size());
-
-            if(SDL_MUSTLOCK(font->FontSurface) && _sge_lock)
-                if(SDL_LockSurface(font->FontSurface) < 0)
-                {
-                    SDL_SetError("SGE - Locking error");
-                    SDL_FreeSurface(font->FontSurface);
-                    SDL_FreeSurface(tmp);
-                    delete font;
-                    return nullptr;
-                }
-
-            // Copy the font to the 8bit surface
-            Sint16 x, y;
-            Uint32 bc = sge_GetPixel(font->FontSurface, 0, surface->h - 1);
-            for(y = 0; y < font->FontSurface->h; y++)
-            {
-                for(x = 0; x < font->FontSurface->w; x++)
-                {
-                    if(sge_GetPixel(font->FontSurface, x, y) == bc)
-                        *((Uint8*)tmp->pixels + y * tmp->pitch + x) = 0;
-                    else
-                        *((Uint8*)tmp->pixels + y * tmp->pitch + x) = 1;
-                }
-            }
-
-            if(SDL_MUSTLOCK(font->FontSurface) && _sge_lock)
-            {
-                SDL_UnlockSurface(font->FontSurface);
-            }
-
-            // sge_Blit(surface, tmp, 0,0,0,0,surface->w, surface->h);
-            SDL_FreeSurface(font->FontSurface);
-            font->FontSurface = tmp;
-        }
-
-        if((flags & SGE_FLAG8))
-            SDL_FreeSurface(surface);
-    } else if(flags & SGE_FLAG8) /* Use the source */
-        font->FontSurface = surface;
-    else /* Get a copy */
-        font->FontSurface = sge_copy_surface(surface);
-
-    if(!font->FontSurface)
-    {
-        SDL_SetError("SGE - Out of memory");
-        delete font;
-        return nullptr;
-    }
-
-    SDL_Surface* fnt = font->FontSurface; // Shorthand
-    font->Chars = 0;
-
-    if(!(flags & SGE_BFSFONT))
-    { /* Fixed width font */
-        font->CharWidth = font->FontSurface->w / 256;
-        font->CharHeight = font->FontSurface->h;
-        font->CharPos = nullptr;
-        font->yoffs = 0;
-        font->Chars = 256;
-    } else
-    { /* Karl Bartel's sfont */
-        Sint16 x = 0;
-        int i = 0;
-
-        font->CharPos = new(nothrow) Sint16[256];
-        if(!font->CharPos)
-        {
-            SDL_SetError("SGE - Out of memory");
-            sge_BF_CloseFont(font);
-            return nullptr;
-        }
-
-        Uint32 color = sge_GetPixel(fnt, 0, 0); // get data color
-
-        while(x < fnt->w && font->Chars < 256)
-        {
-            if(sge_GetPixel(fnt, x, 0) == color)
-            {
-                font->CharPos[i++] = x;
-
-                while(x < fnt->w - 1 && sge_GetPixel(fnt, x, 0) == color)
-                    x++;
-
-                font->CharPos[i++] = x;
-                font->Chars++;
-            }
-            x++;
-        }
-
-        font->CharHeight = font->FontSurface->h - 1;
-        font->CharWidth = 0;
-        font->yoffs = 1;
-    }
-
-    /* Set font as transparent if the flag is set */
-    if(SDL_MUSTLOCK(font->FontSurface) && _sge_lock)
-        if(SDL_LockSurface(font->FontSurface) < 0)
-        {
-            return font;
-        }
-    font->bcolor = sge_GetPixel(font->FontSurface, 0, font->FontSurface->h - 1);
-    if(SDL_MUSTLOCK(font->FontSurface) && _sge_lock)
-    {
-        SDL_UnlockSurface(font->FontSurface);
-    }
-    if(flags & SGE_BFTRANSP || flags & SGE_BFSFONT)
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) >= SDL_VERSIONNUM(1, 1, 4)
-        SDL_SetColorKey(font->FontSurface, SDL_SRCCOLORKEY, font->bcolor); // Some versions of SDL have a bug with SDL_RLEACCEL
-#else
-        SDL_SetColorKey(font->FontSurface, SDL_SRCCOLORKEY | SDL_RLEACCEL, font->bcolor);
-#endif
-
-    return font;
-}
-
-//==================================================================================
-// Loads the font into a new struct
-//==================================================================================
-sge_bmpFont* sge_BF_OpenFont(const char* file, Uint8 flags)
-{
-    sge_bmpFont* font;
-    SDL_Surface* Temp;
-
-/* load the font bitmap */
-#ifdef _SGE_HAVE_IMG
-    if(nullptr == (Temp = IMG_Load(file))) // We have SDL_Img lib!
-#else
-    if(nullptr == (Temp = SDL_LoadBMP(file))) // We can only load bmp files...
-#endif
-    {
-        sge_SetError("SGE - Couldn't load font file: %s", file);
-        return nullptr;
-    }
-
-    font = sge_BF_CreateFont(Temp, flags | SGE_FLAG8); // SGE_FLAG8 - no need to make a copy of the surface
-
-    return font;
-}
-
-//==================================================================================
-// Draws string to surface with the selected font
-// Returns pos. and size of the drawn text
-//==================================================================================
-SDL_Rect sge_BF_textout(SDL_Surface* surface, sge_bmpFont* font, const char* string, Sint16 x, Sint16 y)
-{
-    SDL_Rect ret;
-    ret.x = 0;
-    ret.y = 0;
-    ret.w = 0;
-    ret.h = 0;
-
-    if(!font)
-    {
-        return ret;
-    }
-
-    int characters;
-    Sint16 xsrc, xdest, ofs, adv = font->CharWidth;
-    float diff = 0;
-
-    /* Valid coords ? */
-    if(surface)
-        if(x > surface->w || y > surface->h)
-            return ret;
-
-    characters = static_cast<int>(strlen(string));
-
-    xdest = x;
-
-    /* Now draw it */
-    for(int i = 0; i < characters; i++)
-    {
-        if(!font->CharPos) /* Fixed width */
-            xsrc = string[i] * font->CharWidth;
-        else
-        { /* Variable width */
-            if(string[i] == ' ' || (string[i] - 33) > font->Chars || string[i] < 33)
-            {
-                xdest += font->CharPos[2] - font->CharPos[1];
-                continue;
-            }
-            ofs = (string[i] - 33) * 2 + 1;
-            xsrc = (font->CharPos[ofs] + font->CharPos[ofs - 1]) / 2;
-            // font->CharWidth = (font->CharPos[ofs+2]+font->CharPos[ofs+1])/2-(font->CharPos[ofs]+font->CharPos[ofs-1])/2-1;
-            font->CharWidth = (font->CharPos[ofs + 2] + font->CharPos[ofs + 1]) / 2 - (font->CharPos[ofs] + font->CharPos[ofs - 1]) / 2;
-            adv = font->CharPos[ofs + 1] - font->CharPos[ofs];
-            diff = float((font->CharPos[ofs] - font->CharPos[ofs - 1]) / 2.0);
-        }
-
-        if(surface)
-            sge_Blit(font->FontSurface, surface, xsrc, font->yoffs, int(xdest - diff), y, font->CharWidth, font->CharHeight);
-
-        xdest += adv;
-    }
-
-    ret.x = x;
-    ret.y = y;
-    ret.w = static_cast<Uint16>(xdest - x) + font->CharWidth;
-    ret.h = font->CharHeight;
-
-    if(surface)
-        sge_UpdateRect(surface, x, y, ret.w, ret.h);
-
-    return ret;
-}
-
-//==================================================================================
-// Returns the size (w and h) of the string (if rendered with font)
-//==================================================================================
-SDL_Rect sge_BF_TextSize(sge_bmpFont* font, const char* string)
-{
-    return sge_BF_textout(nullptr, font, string, 0, 0);
-}
-
-//==================================================================================
-// Draws formated text to surface with the selected font
-// Returns pos. and size of the drawn text
-// * just like printf(char *format, ...) *
-//==================================================================================
-SDL_Rect sge_BF_textoutf(SDL_Surface* surface, sge_bmpFont* font, Sint16 x, Sint16 y, const char* format, ...)
-{
-    std::array<char, 256> buf;
-
-    va_list ap;
-
-    va_start(ap, format);
-
-    vsprintf(buf.data(), format, ap);
-    va_end(ap);
-
-    return sge_BF_textout(surface, font, buf.data(), x, y);
-}
-
-//==================================================================================
-// Returns the height of the font
-// Returns 0 if the struct was invalid
-//==================================================================================
-Sint16 sge_BF_GetHeight(sge_bmpFont* font)
-{
-    if(font)
-        return font->CharHeight;
-    else
-        return 0;
-}
-
-//==================================================================================
-// Returns the width of the font (only fixed width fonts)
-// Returns 0 if the struct was invalid
-//==================================================================================
-Sint16 sge_BF_GetWidth(sge_bmpFont* font)
-{
-    if(font)
-        return font->CharWidth;
-    else
-        return 0;
-}
-
-//==================================================================================
-// Removes font from memory
-//==================================================================================
-void sge_BF_CloseFont(sge_bmpFont* font)
-{
-    if(font)
-    {
-        SDL_FreeSurface(font->FontSurface);
-
-        delete[] font->CharPos;
-        delete font;
-        font = nullptr;
-    }
-}
-
-//==================================================================================
-// Change the font color
-// Will not work on 'color' fonts!
-// Doesn't like 24bpp
-//==================================================================================
-void sge_BF_SetColor(sge_bmpFont* font, Uint8 R, Uint8 G, Uint8 B)
-{
-    if(!font)
-    {
-        return;
-    }
-
-    if(!font->FontSurface->format->palette)
-    { // Slow truecolor version
-        Sint16 x, y;
-        Sint16 ypnt;
-        SDL_Surface* surface = font->FontSurface;
-        Uint32 c_keep = font->bcolor;
-
-        Uint32 color = SDL_MapRGB(font->FontSurface->format, R, G, B);
-
-        switch(surface->format->BytesPerPixel)
-        {
-            case 1:
-            { /* Assuming 8-bpp */
-                Uint8* pnt;
-                for(y = 0; y < surface->h; y++)
-                {
-                    ypnt = y * surface->pitch;
-                    for(x = 0; x < surface->w; x++)
-                    {
-                        pnt = ((Uint8*)surface->pixels + x + ypnt);
-                        if(*pnt != c_keep)
-                        {
-                            *pnt = (Uint8)color;
-                        }
-                    }
-                }
-            }
-            break;
-
-            case 2:
-            { /* Probably 15-bpp or 16-bpp */
-                Uint16* pnt;
-                for(y = 0; y < surface->h; y++)
-                {
-                    ypnt = y * surface->pitch / 2;
-                    for(x = 0; x < surface->w; x++)
-                    {
-                        pnt = ((Uint16*)surface->pixels + x + ypnt);
-                        if(*pnt != c_keep)
-                        {
-                            *pnt = (Uint16)color;
-                        }
-                    }
-                }
-            }
-            break;
-
-            case 3:
-            { /* Slow 24-bpp mode, usually not used */
-            }
-            break;
-
-            case 4:
-            { /* Probably 32-bpp */
-                Uint32* pnt;
-                for(y = 0; y < surface->h; y++)
-                {
-                    ypnt = y * surface->pitch / 4;
-                    for(x = 0; x < surface->w; x++)
-                    {
-                        pnt = ((Uint32*)surface->pixels + x + ypnt);
-                        if(*pnt != c_keep)
-                        {
-                            *pnt = (Uint32)color;
-                        }
-                    }
-                }
-            }
-            break;
-        }
-    } else
-    { // Fast palette version
-        std::array<SDL_Color, 2> c;
-        c[0].r = 0;
-        c[1].r = R;
-        c[0].g = 0;
-        c[1].g = G;
-        c[0].b = 0;
-        c[1].b = B;
-        SDL_SetColors(font->FontSurface, c.data(), 0, c.size());
-    }
-}
-
-//==================================================================================
-// Sets an alpha value for the font (don't work with sfonts with an alpha channel)
-//==================================================================================
-void sge_BF_SetAlpha(sge_bmpFont* font, Uint8 alpha)
-{
-    SDL_SetAlpha(font->FontSurface, SDL_SRCALPHA | SDL_RLEACCEL, alpha);
-}
-
-//==================================================================================
-// BitmapText input
-//==================================================================================
-int sge_BF_inputAlpha(SDL_Surface* screen, sge_bmpFont* font, char* string, Uint8 flags, int pos, unsigned len, Sint16 x, Sint16 y,
-                      int Alpha)
-{
-    if(pos == 0 && len > 0)
-        string[0] = '\0';
-
-    sge_TextSurface text(screen, string, x, y);
-    text.set_bmFont(font);
-    text.show_cursor(true);
-    text.set_alpha(Alpha);
-    text.max_chars(len - 1);
-
-    int ret = sge_text_input(&text, flags);
-
-    strncpy(string, text.get_string(false).c_str(), sizeof(char) * len);
-    return ret;
-}
-
-int sge_BF_inputAlpha_UNI(SDL_Surface* screen, sge_bmpFont* font, Uint16* string, Uint8 flags, int pos, unsigned len, Sint16 x, Sint16 y,
-                          int Alpha)
-{
-    sge_TextSurface text(screen, "", x, y);
-
-    if(pos != 0)
-        text.change_uctext(string);
-
-    text.set_bmFont(font);
-    text.show_cursor(true);
-    text.set_alpha(Alpha);
-    text.max_chars(len - 1);
-
-    int ret = sge_text_input(&text, flags);
-
-    Uint16* tmp = text.get_ucstring(false);
-
-    strncpy((char*)string, (char*)tmp, sizeof(Uint16) * len);
-
-    delete[] tmp;
-
-    return ret;
-}
-
-int sge_BF_input(SDL_Surface* screen, sge_bmpFont* font, char* string, Uint8 flags, int pos, unsigned len, Sint16 x, Sint16 y)
-{
-    return sge_BF_inputAlpha(screen, font, string, flags, pos, len, x, y, SDL_ALPHA_OPAQUE);
-}
-
-int sge_BF_input_UNI(SDL_Surface* screen, sge_bmpFont* font, Uint16* string, Uint8 flags, int pos, unsigned len, Sint16 x, Sint16 y)
-{
-    return sge_BF_inputAlpha_UNI(screen, font, string, flags, pos, len, x, y, SDL_ALPHA_OPAQUE);
-}
diff --git a/external/s25edit/SGE/sge_collision.cpp b/external/s25edit/SGE/sge_collision.cpp
index bbc524d..37a19de 100644
--- a/external/s25edit/SGE/sge_collision.cpp
+++ b/external/s25edit/SGE/sge_collision.cpp
@@ -40,6 +40,12 @@ sge_cdata* sge_make_cmap(SDL_Surface* img)
     Sint16 x, y;
     int i;
 
+    Uint32 colorkey;
+    if(SDL_GetColorKey(img, &colorkey) != 0)
+    {
+        SDL_SetError("SGE - No colorkey set");
+        return nullptr;
+    }
     cdata = new(nothrow) sge_cdata;
     if(!cdata)
     {
@@ -59,7 +65,6 @@ sge_cdata* sge_make_cmap(SDL_Surface* img)
     memset(cdata->map, 0x00, offs + 2);
 
     map = cdata->map;
-
     i = 0;
     for(y = 0; y < img->h; y++)
     {
@@ -70,7 +75,7 @@ sge_cdata* sge_make_cmap(SDL_Surface* img)
                 i = 0;
                 map++;
             }
-            if(sge_GetPixel(img, Sint16(x), Sint16(y)) != img->format->colorkey)
+            if(sge_GetPixel(img, Sint16(x), Sint16(y)) != colorkey)
             {
                 *map = *map | sge_mask[i];
             }
diff --git a/external/s25edit/SGE/sge_primitives.cpp b/external/s25edit/SGE/sge_primitives.cpp
index 6898eba..5c3ab34 100644
--- a/external/s25edit/SGE/sge_primitives.cpp
+++ b/external/s25edit/SGE/sge_primitives.cpp
@@ -27,8 +27,7 @@
 #include <cstdlib>
 #include <utility>
 
-/* Globals used for sge_Update/sge_Lock (defined in sge_surface) */
-extern Uint8 _sge_update;
+/* Globals used for sge_Lock (defined in sge_surface) */
 extern Uint8 _sge_lock;
 
 using std::swap;
@@ -49,16 +48,6 @@ void _HLine(SDL_Surface* Surface, Sint16 x1, Sint16 x2, Sint16 y, Uint32 Color)
         x2 = tmp;
     }
 
-// Do the clipping
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) < SDL_VERSIONNUM(1, 1, 5)
-    if(y < Surface->clip_miny || y > Surface->clip_maxy || x1 > Surface->clip_maxx || x2 < Surface->clip_minx)
-        return;
-    if(x1 < Surface->clip_minx)
-        x1 = Surface->clip_minx;
-    if(x2 > Surface->clip_maxx)
-        x2 = Surface->clip_maxx;
-#endif
-
     SDL_Rect l;
     l.x = x1;
     l.y = y;
@@ -80,16 +69,6 @@ void sge_HLine(SDL_Surface* Surface, Sint16 x1, Sint16 x2, Sint16 y, Uint32 Colo
         x2 = tmp;
     }
 
-// Do the clipping
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) < SDL_VERSIONNUM(1, 1, 5)
-    if(y < Surface->clip_miny || y > Surface->clip_maxy || x1 > Surface->clip_maxx || x2 < Surface->clip_minx)
-        return;
-    if(x1 < Surface->clip_minx)
-        x1 = Surface->clip_minx;
-    if(x2 > Surface->clip_maxx)
-        x2 = Surface->clip_maxx;
-#endif
-
     SDL_Rect l;
     l.x = x1;
     l.y = y;
@@ -97,8 +76,6 @@ void sge_HLine(SDL_Surface* Surface, Sint16 x1, Sint16 x2, Sint16 y, Uint32 Colo
     l.h = 1;
 
     SDL_FillRect(Surface, &l, Color);
-
-    sge_UpdateRect(Surface, x1, y, l.w, 1);
 }
 
 //==================================================================================
@@ -114,12 +91,9 @@ void sge_HLine(SDL_Surface* Surface, Sint16 x1, Sint16 x2, Sint16 y, Uint8 R, Ui
 //==================================================================================
 void _HLineAlpha(SDL_Surface* Surface, Sint16 x1, Sint16 x2, Sint16 y, Uint32 Color, Uint8 alpha)
 {
-    Uint8 update = _sge_update;
     Uint8 lock = _sge_lock;
-    _sge_update = 0;
     _sge_lock = 0;
     sge_FilledRectAlpha(Surface, x1, y, x2, y, Color, alpha);
-    _sge_update = update;
     _sge_lock = lock;
 }
 
@@ -151,16 +125,6 @@ static void _VLine(SDL_Surface* Surface, Sint16 x, Sint16 y1, Sint16 y2, Uint32
         y2 = tmp;
     }
 
-// Do the clipping
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) < SDL_VERSIONNUM(1, 1, 5)
-    if(x < Surface->clip_minx || x > Surface->clip_maxx || y1 > Surface->clip_maxy || y2 < Surface->clip_miny)
-        return;
-    if(y1 < Surface->clip_miny)
-        y1 = Surface->clip_miny;
-    if(y2 > Surface->clip_maxy)
-        y2 = Surface->clip_maxy;
-#endif
-
     SDL_Rect l;
     l.x = x;
     l.y = y1;
@@ -182,16 +146,6 @@ void sge_VLine(SDL_Surface* Surface, Sint16 x, Sint16 y1, Sint16 y2, Uint32 Colo
         y2 = tmp;
     }
 
-// Do the clipping
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) < SDL_VERSIONNUM(1, 1, 5)
-    if(x < Surface->clip_minx || x > Surface->clip_maxx || y1 > Surface->clip_maxy || y2 < Surface->clip_miny)
-        return;
-    if(y1 < Surface->clip_miny)
-        y1 = Surface->clip_miny;
-    if(y2 > Surface->clip_maxy)
-        y2 = Surface->clip_maxy;
-#endif
-
     SDL_Rect l;
     l.x = x;
     l.y = y1;
@@ -199,8 +153,6 @@ void sge_VLine(SDL_Surface* Surface, Sint16 x, Sint16 y1, Sint16 y2, Uint32 Colo
     l.h = (Uint16)(y2 - y1) + 1;
 
     SDL_FillRect(Surface, &l, Color);
-
-    sge_UpdateRect(Surface, x, y1, 1, l.h);
 }
 
 //==================================================================================
@@ -216,12 +168,9 @@ void sge_VLine(SDL_Surface* Surface, Sint16 x, Sint16 y1, Sint16 y2, Uint8 R, Ui
 //==================================================================================
 static void _VLineAlpha(SDL_Surface* Surface, Sint16 x, Sint16 y1, Sint16 y2, Uint32 Color, Uint8 alpha)
 {
-    Uint8 update = _sge_update;
     Uint8 lock = _sge_lock;
-    _sge_update = 0;
     _sge_lock = 0;
     sge_FilledRectAlpha(Surface, x, y1, x, y2, Color, alpha);
-    _sge_update = update;
     _sge_lock = lock;
 }
 
@@ -537,8 +486,6 @@ void sge_Line(SDL_Surface* Surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2,
     {
         SDL_UnlockSurface(Surface);
     }
-
-    sge_UpdateRect(Surface, (x1 < x2) ? x1 : x2, (y1 < y2) ? y1 : y2, absDiff(x1, x2) + 1, absDiff(y1, y2) + 1);
 }
 
 //==================================================================================
@@ -582,8 +529,6 @@ void sge_LineAlpha(SDL_Surface* Surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint16
     {
         SDL_UnlockSurface(Surface);
     }
-
-    sge_UpdateRect(Surface, (x1 < x2) ? x1 : x2, (y1 < y2) ? y1 : y2, absDiff(x1, x2) + 1, absDiff(y1, y2) + 1);
 }
 
 //==================================================================================
@@ -753,8 +698,6 @@ void sge_AALineAlpha(SDL_Surface* dst, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y
     {
         SDL_UnlockSurface(dst);
     }
-
-    sge_UpdateRect(dst, (x1 < x2) ? x1 : x2, (y1 < y2) ? y1 : y2, absDiff(x1, x2) + 1, absDiff(y1, y2) + 1);
 }
 
 void sge_AALineAlpha(SDL_Surface* dst, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Uint8 r, Uint8 g, Uint8 b, Uint8 alpha)
@@ -866,8 +809,6 @@ void sge_mcLine(SDL_Surface* Surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2
     {
         SDL_UnlockSurface(Surface);
     }
-
-    sge_UpdateRect(Surface, (x1 < x2) ? x1 : x2, (y1 < y2) ? y1 : y2, absDiff(x1, x2) + 1, absDiff(y1, y2) + 1);
 }
 
 void sge_mcLineAlpha(SDL_Surface* Surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Uint8 r1, Uint8 g1, Uint8 b1, Uint8 r2, Uint8 g2,
@@ -887,8 +828,6 @@ void sge_mcLineAlpha(SDL_Surface* Surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint
     {
         SDL_UnlockSurface(Surface);
     }
-
-    sge_UpdateRect(Surface, (x1 < x2) ? x1 : x2, (y1 < y2) ? y1 : y2, absDiff(x1, x2) + 1, absDiff(y1, y2) + 1);
 }
 
 //==================================================================================
@@ -1067,8 +1006,6 @@ void sge_AAmcLineAlpha(SDL_Surface* dst, Sint16 x1, Sint16 y1, Sint16 x2, Sint16
 
     if(_sge_lock && SDL_MUSTLOCK(dst))
         SDL_UnlockSurface(dst);
-
-    sge_UpdateRect(dst, (x1 < x2) ? x1 : x2, (y1 < y2) ? y1 : y2, absDiff(x1, x2) + 1, absDiff(y1, y2) + 1);
 }
 
 void sge_AAmcLine(SDL_Surface* Surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Uint8 r1, Uint8 g1, Uint8 b1, Uint8 r2, Uint8 g2,
@@ -1090,11 +1027,6 @@ void sge_Rect(SDL_Surface* Surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2,
     _HLine(Surface, x1, x2, y2, color);
     _VLine(Surface, x1, y1, y2, color);
     _VLine(Surface, x2, y1, y2, color);
-
-    sge_UpdateRect(Surface, x1, y1, static_cast<Uint16>(x2 - x1), 1);
-    sge_UpdateRect(Surface, x1, y2, static_cast<Uint16>(x2 - x1) + 1, 1); /* Hmm? */
-    sge_UpdateRect(Surface, x1, y1, 1, static_cast<Uint16>(y2 - y1));
-    sge_UpdateRect(Surface, x2, y1, 1, static_cast<Uint16>(y2 - y1));
 }
 
 //==================================================================================
@@ -1123,11 +1055,6 @@ void sge_RectAlpha(SDL_Surface* Surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint16
     {
         SDL_UnlockSurface(Surface);
     }
-
-    sge_UpdateRect(Surface, x1, y1, static_cast<Uint16>(x2 - x1), 1);
-    sge_UpdateRect(Surface, x1, y2, static_cast<Uint16>(x2 - x1) + 1, 1); /* Hmm? */
-    sge_UpdateRect(Surface, x1, y1, 1, static_cast<Uint16>(y2 - y1));
-    sge_UpdateRect(Surface, x2, y1, 1, static_cast<Uint16>(y2 - y1));
 }
 
 //==================================================================================
@@ -1157,19 +1084,6 @@ void sge_FilledRect(SDL_Surface* Surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint1
         y2 = tmp;
     }
 
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) < SDL_VERSIONNUM(1, 1, 5)
-    if(x2 < Surface->clip_minx || x1 > Surface->clip_maxx || y2 < Surface->clip_miny || y1 > Surface->clip_maxy)
-        return;
-    if(x1 < Surface->clip_minx)
-        x1 = Surface->clip_minx;
-    if(x2 > Surface->clip_maxx)
-        x2 = Surface->clip_maxx;
-    if(y1 < Surface->clip_miny)
-        y1 = Surface->clip_miny;
-    if(y2 > Surface->clip_maxy)
-        y2 = Surface->clip_maxy;
-#endif
-
     SDL_Rect area;
     area.x = x1;
     area.y = y1;
@@ -1177,8 +1091,6 @@ void sge_FilledRect(SDL_Surface* Surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint1
     area.h = static_cast<Uint16>(y2 - y1) + 1;
 
     SDL_FillRect(Surface, &area, color);
-
-    sge_UpdateRect(Surface, area);
 }
 
 //==================================================================================
@@ -1359,8 +1271,6 @@ void sge_FilledRectAlpha(SDL_Surface* surface, Sint16 x1, Sint16 y1, Sint16 x2,
     {
         SDL_UnlockSurface(surface);
     }
-
-    sge_UpdateRect(surface, x1, y1, static_cast<Uint16>(x2 - x1) + 1, static_cast<Uint16>(y2 - y1) + 1);
 }
 
 void sge_FilledRectAlpha(SDL_Surface* Surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Uint8 R, Uint8 G, Uint8 B, Uint8 alpha)
@@ -1510,8 +1420,6 @@ void sge_Ellipse(SDL_Surface* Surface, Sint16 x, Sint16 y, Uint16 rx, Uint16 ry,
     {
         SDL_UnlockSurface(Surface);
     }
-
-    sge_UpdateRect(Surface, x - rx, y - ry, 2 * rx + 1, 2 * ry + 1);
 }
 
 //==================================================================================
@@ -1538,8 +1446,6 @@ void sge_EllipseAlpha(SDL_Surface* Surface, Sint16 x, Sint16 y, Uint16 rx, Uint1
     {
         SDL_UnlockSurface(Surface);
     }
-
-    sge_UpdateRect(Surface, x - rx, y - ry, 2 * rx + 1, 2 * ry + 1);
 }
 
 //==================================================================================
@@ -1644,8 +1550,6 @@ void sge_FilledEllipse(SDL_Surface* Surface, Sint16 x, Sint16 y, Uint16 rx, Uint
 
         } while(i > h);
     }
-
-    sge_UpdateRect(Surface, x - rx, y - ry, 2 * rx + 1, 2 * ry + 1);
 }
 
 //==================================================================================
@@ -1759,8 +1663,6 @@ void sge_FilledEllipseAlpha(SDL_Surface* Surface, Sint16 x, Sint16 y, Uint16 rx,
     {
         SDL_UnlockSurface(Surface);
     }
-
-    sge_UpdateRect(Surface, x - rx, y - ry, 2 * rx + 1, 2 * ry + 1);
 }
 
 //==================================================================================
@@ -1948,9 +1850,6 @@ void sge_AAFilledEllipse(SDL_Surface* surface, Sint16 xc, Sint16 yc, Uint16 rx,
         _HLine(surface, x + 1, 2 * xc - x - 1, 2 * yc - y, color);
         _HLine(surface, xs + 1, 2 * xc - xs - 1, 2 * yc - y, color);
     }
-
-    /* Update surface if needed */
-    sge_UpdateRect(surface, xc - rx, yc - ry, 2 * rx + 1, 2 * ry + 1);
 }
 
 //==================================================================================
@@ -2028,8 +1927,6 @@ void sge_Circle(SDL_Surface* Surface, Sint16 x, Sint16 y, Uint16 r, Uint32 color
     {
         SDL_UnlockSurface(Surface);
     }
-
-    sge_UpdateRect(Surface, x - r, y - r, 2 * r + 1, 2 * r + 1);
 }
 
 //==================================================================================
@@ -2056,8 +1953,6 @@ void sge_CircleAlpha(SDL_Surface* Surface, Sint16 x, Sint16 y, Uint16 r, Uint32
     {
         SDL_UnlockSurface(Surface);
     }
-
-    sge_UpdateRect(Surface, x - r, y - r, 2 * r + 1, 2 * r + 1);
 }
 
 //==================================================================================
@@ -2113,8 +2008,6 @@ void sge_FilledCircle(SDL_Surface* Surface, Sint16 x, Sint16 y, Uint16 r, Uint32
         }
         cx++;
     } while(cx <= cy);
-
-    sge_UpdateRect(Surface, x - r, y - r, 2 * r + 1, 2 * r + 1);
 }
 
 //==================================================================================
@@ -2179,8 +2072,6 @@ void sge_FilledCircleAlpha(SDL_Surface* Surface, Sint16 x, Sint16 y, Uint16 r, U
     {
         SDL_UnlockSurface(Surface);
     }
-
-    sge_UpdateRect(Surface, x - r, y - r, 2 * r + 1, 2 * r + 1);
 }
 
 //==================================================================================
@@ -2222,7 +2113,6 @@ void sge_AAFilledCircle(SDL_Surface* surface, Sint16 xc, Sint16 yc, Uint16 r, Ui
     float dx, d2x, d3x;                                                                                            \
     float dy, d2y, d3y;                                                                                            \
     float a, b, c;                                                                                                 \
-    Sint16 xmax = x1, ymax = y1, xmin = x1, ymin = y1;                                                             \
                                                                                                                    \
     /* compute number of iterations */                                                                             \
     if(level < 1)                                                                                                  \
@@ -2269,17 +2159,6 @@ void sge_AAFilledCircle(SDL_Surface* surface, Sint16 xc, Sint16 yc, Uint16 r, Ui
         if(Sint16(xp) != Sint16(x) || Sint16(yp) != Sint16(y))                                                     \
         {                                                                                                          \
             function;                                                                                              \
-            if(_sge_update == 1)                                                                                   \
-            {                                                                                                      \
-                xmax = (xmax > Sint16(xp)) ? xmax : Sint16(xp);                                                    \
-                ymax = (ymax > Sint16(yp)) ? ymax : Sint16(yp);                                                    \
-                xmin = (xmin < Sint16(xp)) ? xmin : Sint16(xp);                                                    \
-                ymin = (ymin < Sint16(yp)) ? ymin : Sint16(yp);                                                    \
-                xmax = (xmax > Sint16(x)) ? xmax : Sint16(x);                                                      \
-                ymax = (ymax > Sint16(y)) ? ymax : Sint16(y);                                                      \
-                xmin = (xmin < Sint16(x)) ? xmin : Sint16(x);                                                      \
-                ymin = (ymin < Sint16(y)) ? ymin : Sint16(y);                                                      \
-            }                                                                                                      \
         }                                                                                                          \
         xp = x;                                                                                                    \
         yp = y;                                                                                                    \
@@ -2289,10 +2168,7 @@ void sge_AAFilledCircle(SDL_Surface* surface, Sint16 xc, Sint16 yc, Uint16 r, Ui
     if(_sge_lock && SDL_MUSTLOCK(surface))                                                                         \
     {                                                                                                              \
         SDL_UnlockSurface(surface);                                                                                \
-    }                                                                                                              \
-                                                                                                                   \
-    /* Update the area */                                                                                          \
-    sge_UpdateRect(surface, xmin, ymin, xmax - xmin + 1, ymax - ymin + 1);
+    }
 
 //==================================================================================
 // Draws a bezier line
@@ -2338,9 +2214,7 @@ void sge_BezierAlpha(SDL_Surface* surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint
 void sge_AABezierAlpha(SDL_Surface* surface, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, Sint16 x3, Sint16 y3, Sint16 x4, Sint16 y4,
                        int level, Uint32 color, Uint8 alpha)
 {
-    Uint8 update = _sge_update;
     Uint8 lock = _sge_lock;
-    _sge_update = 0;
     _sge_lock = 0;
 
     if(SDL_MUSTLOCK(surface) && lock)
@@ -2354,10 +2228,7 @@ void sge_AABezierAlpha(SDL_Surface* surface, Sint16 x1, Sint16 y1, Sint16 x2, Si
         SDL_UnlockSurface(surface);
     }
 
-    _sge_update = update;
     _sge_lock = lock;
-
-    sge_UpdateRect(surface, xmin, ymin, (Uint16)(xmax - xmin) + 1, (Uint16)(ymax - ymin) + 1);
 }
 
 //==================================================================================
diff --git a/external/s25edit/SGE/sge_rotation.cpp b/external/s25edit/SGE/sge_rotation.cpp
index b3d86a4..e726616 100644
--- a/external/s25edit/SGE/sge_rotation.cpp
+++ b/external/s25edit/SGE/sge_rotation.cpp
@@ -15,13 +15,13 @@
  *  version 2 of the License, or (at your option) any later version. *
  *********************************************************************/
 #define _USE_MATH_DEFINES
+#define HAVE_M_PI 1
 #include "sge_rotation.h"
 #include "sge_blib.h"
 #include "sge_surface.h"
 #include <array>
 #include <cmath>
 
-extern Uint8 _sge_update; // Declared in sge_draw.cpp
 extern Uint8 _sge_lock;
 
 SDL_Rect sge_transform_tmap(SDL_Surface* src, SDL_Surface* dst, float angle, float xscale, float yscale, Uint16 qx, Uint16 qy);
@@ -164,8 +164,8 @@ static void _calcRect(SDL_Surface* src, SDL_Surface* dst, float theta, float xsc
             /* Make sure the source pixel is actually in the source image. */        \
             if((rx >= sxmin) && (rx <= sxmax) && (ry >= symin) && (ry <= symax))     \
             {                                                                        \
-                sge_GetRGBA(sge_GetPixel(src, rx, ry), src->format, &R, &G, &B, &A); \
-                _PutPixelX(dst, x, y, sge_MapRGBA(dst->format, R, G, B, A));         \
+                SDL_GetRGBA(sge_GetPixel(src, rx, ry), src->format, &R, &G, &B, &A); \
+                _PutPixelX(dst, x, y, SDL_MapRGBA(dst->format, R, G, B, A));         \
             }                                                                        \
             sx += ctx; /* Incremental transformations */                             \
             sy -= sty;                                                               \
@@ -293,10 +293,10 @@ static void _calcRect(SDL_Surface* src, SDL_Surface* dst, float theta, float xsc
                 p2 = wx + one - wy;                                                                   \
                 p1 = two - wx - wy;                                                                   \
                                                                                                       \
-                sge_GetRGBA(sge_GetPixel(src, rx, ry), src->format, &R1, &G1, &B1, &A1);              \
-                sge_GetRGBA(sge_GetPixel(src, rx + 1, ry), src->format, &R2, &G2, &B2, &A2);          \
-                sge_GetRGBA(sge_GetPixel(src, rx, ry + 1), src->format, &R3, &G3, &B3, &A3);          \
-                sge_GetRGBA(sge_GetPixel(src, rx + 1, ry + 1), src->format, &R4, &G4, &B4, &A4);      \
+                SDL_GetRGBA(sge_GetPixel(src, rx, ry), src->format, &R1, &G1, &B1, &A1);              \
+                SDL_GetRGBA(sge_GetPixel(src, rx + 1, ry), src->format, &R2, &G2, &B2, &A2);          \
+                SDL_GetRGBA(sge_GetPixel(src, rx, ry + 1), src->format, &R3, &G3, &B3, &A3);          \
+                SDL_GetRGBA(sge_GetPixel(src, rx + 1, ry + 1), src->format, &R4, &G4, &B4, &A4);      \
                                                                                                       \
                 /* Calculate the average */                                                           \
                 R = (p1 * R1 + p2 * R2 + p3 * R3 + p4 * R4) >> 13;                                    \
@@ -304,7 +304,7 @@ static void _calcRect(SDL_Surface* src, SDL_Surface* dst, float theta, float xsc
                 B = (p1 * B1 + p2 * B2 + p3 * B3 + p4 * B4) >> 13;                                    \
                 A = (p1 * A1 + p2 * A2 + p3 * A3 + p4 * A4) >> 13;                                    \
                                                                                                       \
-                _PutPixelX(dst, x, y, sge_MapRGBA(dst->format, R, G, B, A));                          \
+                _PutPixelX(dst, x, y, SDL_MapRGBA(dst->format, R, G, B, A));                          \
             }                                                                                         \
             sx += ctx; /* Incremental transformations */                                              \
             sy -= sty;                                                                                \
diff --git a/external/s25edit/SGE/sge_shape.cpp b/external/s25edit/SGE/sge_shape.cpp
index 74aa4b9..309b69c 100644
--- a/external/s25edit/SGE/sge_shape.cpp
+++ b/external/s25edit/SGE/sge_shape.cpp
@@ -23,140 +23,6 @@
 
 using namespace std;
 
-sge_screen* the_screen = nullptr; // The pointer to the active screen class (or nullptr)
-
-//==================================================================================
-// sge_screen
-//==================================================================================
-sge_screen::sge_screen(SDL_Surface* screen)
-{
-    sge_screen::screen = screen; // Our screen pointer
-
-    /* Test some flags */
-    HW = (((screen->flags) & SDL_HWSURFACE) != 0);
-    DB = (((screen->flags) & SDL_DOUBLEBUF) != 0);
-    FS = (((screen->flags) & SDL_FULLSCREEN) != 0);
-
-    /* Test the resolution of SDL_Delay() */
-    // sge_CalibrateDelay();
-
-    /* Register us as the screen class */
-    the_screen = this;
-
-#ifdef sge_debug
-    if(HW)
-        printf("Screen surface is in video memory (");
-    else
-        printf("Screen surface is in system memory (");
-    if(DB)
-        printf("double-buffered ");
-    else
-        printf("single-buffered ");
-    if(FS)
-        printf("fullscreen mode).\n");
-    else
-        printf("window mode).\n");
-
-// printf("The resolution of SDL_Delay() is %d ms.\n",sge_DelayRes());
-#endif
-}
-
-void sge_screen::add_rect(SDL_Rect rect)
-{
-    if(!(HW || DB))
-    {
-        /* Corrects the coords */
-        if(rect.x >= screen->w || rect.y >= screen->h)
-        {
-            return;
-        }
-        Sint16 a = rect.w, b = rect.h;
-        if(rect.x < 0)
-        {
-            rect.x = 0;
-        }
-        if(rect.y < 0)
-        {
-            rect.y = 0;
-        }
-        if(a + rect.x > screen->w)
-            a = screen->w - rect.x;
-        if(b + rect.y > screen->h)
-            b = screen->h - rect.y;
-
-        rect.w = a;
-        rect.h = b;
-
-        /* Put the rectangle last in the list */
-        rects.push_back(rect);
-    }
-}
-
-void sge_screen::add_rect(Sint16 x, Sint16 y, Uint32 w, Uint32 h)
-{
-    if(!(HW || DB))
-    {
-        SDL_Rect rect;
-        rect.x = x;
-        rect.y = y;
-        rect.w = w;
-        rect.h = h;
-        add_rect(rect);
-    }
-}
-
-void sge_screen::add_shape(sge_shape* shape)
-{
-    shapes.push_back(shape);
-}
-
-void sge_screen::add_shape_p(sge_shape* shape)
-{
-    shapes_p.push_back(shape);
-}
-
-void sge_screen::remove_shape_p(sge_shape* shape)
-{
-    shapes_p.remove(shape);
-}
-
-void sge_screen::clear_all()
-{
-    shapes.clear();
-    shapes_p.clear();
-    rects.clear();
-}
-
-void sge_screen::update()
-{
-    SI i;
-
-    // Draw shapes in list
-    for(auto* shape : shapes)
-    {
-        shape->draw();
-        shape->UpdateRects(); // Adds rectangles with add_rect() automaticly
-    }
-    shapes.clear();
-
-    // Draw permanent shapes in list
-    for(auto* shape : shapes_p)
-    {
-        shape->draw();
-        shape->UpdateRects(); // Adds rectangles with add_rect() automaticly
-    }
-
-    // Updates the list of rectangles on screen
-    if(!(HW || DB))
-    {
-        if(!rects.empty())
-            SDL_UpdateRects(screen, static_cast<int>(rects.size()), &rects[0]); // Let SDL update the rectangles
-
-        rects.clear(); // Empty the list
-    } else if(DB)      // double-buffered
-        SDL_Flip(screen);
-}
-
 //==================================================================================
 // sge_surface (derived from sge_shape)
 // A class for moving/blitting surfaces
@@ -299,41 +165,6 @@ void sge_surface::warp_draw()
         sge_Blit(surface, dest, 0, 0, current_pos.x, current_pos.y, surface->w, surface->h);
 }
 
-void sge_surface::warp_update(SDL_Rect rec)
-{
-    SDL_Rect r1, r2, r3, r4;
-    int rects = get_warp(rec, r1, r2, r3, r4);
-
-    if(rects > 0)
-    {
-        if(the_screen)
-        { // Use the screen class?
-            the_screen->add_rect(r1.x, r1.y, r1.w, r1.h);
-            the_screen->add_rect(r2.x, r2.y, r2.w, r2.h);
-            if(rects > 2)
-            {
-                the_screen->add_rect(r3.x, r3.y, r3.w, r3.h);
-                the_screen->add_rect(r4.x, r4.y, r4.w, r4.h);
-            }
-        } else
-        {
-            sge_UpdateRect(dest, r1.x, r1.y, r1.w, r1.h);
-            sge_UpdateRect(dest, r2.x, r2.y, r2.w, r2.h);
-            if(rects > 2)
-            {
-                sge_UpdateRect(dest, r3.x, r3.y, r3.w, r3.h);
-                sge_UpdateRect(dest, r4.x, r4.y, r4.w, r4.h);
-            }
-        }
-    } else
-    {
-        if(the_screen)
-            the_screen->add_rect(rec.x, rec.y, rec.w, rec.h);
-        else
-            sge_UpdateRect(dest, rec.x, rec.y, rec.w, rec.h);
-    }
-}
-
 void sge_surface::warp_clear(Uint32 color)
 {
     SDL_Rect r1, r2, r3, r4;
@@ -388,67 +219,6 @@ void sge_surface::draw()
     last_pos = current_pos;
 }
 
-void sge_surface::UpdateRects()
-{
-    Sint16 xoffs = last_pos.x - prev_pos.x, yoffs = last_pos.y - prev_pos.y;
-
-    // if the prev and last area to update is very near
-    // it's better to update both with one sge_UpdateRect call
-
-    if(xoffs < 0)
-        xoffs = ~xoffs + 1; // abs(xoffs)
-    if(yoffs < 0)
-        yoffs = ~yoffs + 1;
-
-    if(xoffs <= prev_pos.w / 2 && yoffs <= prev_pos.h / 2)
-    {
-        Sint16 minx, miny, maxx, maxy, w = prev_pos.w + xoffs, h = prev_pos.h + yoffs;
-
-        minx = (prev_pos.x < last_pos.x) ? prev_pos.x : last_pos.x;
-        miny = (prev_pos.y < last_pos.y) ? prev_pos.y : last_pos.y;
-
-        if(prev_pos.w != last_pos.w)
-        {
-            maxx = (prev_pos.x + prev_pos.w > last_pos.x + last_pos.w) ? prev_pos.x + prev_pos.w : last_pos.x + last_pos.w;
-            w = maxx - minx;
-        }
-        if(prev_pos.h != last_pos.h)
-        {
-            maxy = (prev_pos.y + prev_pos.h > last_pos.y + last_pos.h) ? prev_pos.y + prev_pos.h : last_pos.y + last_pos.h;
-            h = maxy - miny;
-        }
-
-        if(warp_border)
-        {
-            SDL_Rect r;
-            r.x = minx;
-            r.y = miny;
-            r.w = w;
-            r.h = h;
-            warp_update(r);
-        } else if(the_screen) // Use the screen class?
-            the_screen->add_rect(minx, miny, w, h);
-        else
-            sge_UpdateRect(dest, minx, miny, w, h);
-
-    } else
-    {
-        if(warp_border)
-        {
-            warp_update(prev_pos);
-            warp_update(last_pos);
-        } else if(the_screen)
-        {
-            the_screen->add_rect(prev_pos.x, prev_pos.y, prev_pos.w, prev_pos.h);
-            the_screen->add_rect(last_pos.x, last_pos.y, last_pos.w, last_pos.h);
-        } else
-        {
-            sge_UpdateRect(dest, prev_pos.x, prev_pos.y, prev_pos.w, prev_pos.h);
-            sge_UpdateRect(dest, last_pos.x, last_pos.y, last_pos.w, last_pos.h);
-        }
-    }
-}
-
 void sge_surface::clear(Uint32 color)
 {
     if(warp_border)
diff --git a/external/s25edit/SGE/sge_surface.cpp b/external/s25edit/SGE/sge_surface.cpp
index dcd7e28..85dcf8e 100644
--- a/external/s25edit/SGE/sge_surface.cpp
+++ b/external/s25edit/SGE/sge_surface.cpp
@@ -25,30 +25,13 @@
 #include <cstdarg>
 #include <cstring>
 
-/* Globals used for sge_Update/sge_Lock */
-Uint8 _sge_update = 1;
+/* Globals used for sge_Lock */
 Uint8 _sge_lock = 1;
 
 /**********************************************************************************/
 /**                            Misc. functions                                   **/
 /**********************************************************************************/
 
-//==================================================================================
-// Turns off automatic update (to avoid tearing).
-//==================================================================================
-void sge_Update_OFF()
-{
-    _sge_update = 0;
-}
-
-//==================================================================================
-// Turns on automatic update (default)
-//==================================================================================
-void sge_Update_ON()
-{
-    _sge_update = 1;
-}
-
 //==================================================================================
 // Turns off automatic locking of surfaces
 //==================================================================================
@@ -66,64 +49,13 @@ void sge_Lock_ON()
 }
 
 //==================================================================================
-// Returns update&locking mode (1-on and 0-off)
+// Returns locking mode (1-on and 0-off)
 //==================================================================================
-Uint8 sge_getUpdate()
-{
-    return _sge_update;
-}
 Uint8 sge_getLock()
 {
     return _sge_lock;
 }
 
-//==================================================================================
-// SDL_UpdateRect does nothing if any part of the rectangle is outside the surface
-// --- This version always work
-//==================================================================================
-void sge_UpdateRect(SDL_Surface* screen, Sint16 x, Sint16 y, Uint16 w, Uint16 h)
-{
-    if(_sge_update != 1 || screen != SDL_GetVideoSurface())
-    {
-        return;
-    }
-
-    if(x >= screen->w || y >= screen->h)
-    {
-        return;
-    }
-
-    Sint16 a, b;
-
-    a = w;
-    b = h;
-
-    if(x < 0)
-    {
-        x = 0;
-    }
-    if(y < 0)
-    {
-        y = 0;
-    }
-
-    if(a + x > screen->w)
-    {
-        a = screen->w - x;
-    }
-    if(b + y > screen->h)
-    {
-        b = screen->h - y;
-    }
-
-    SDL_UpdateRect(screen, x, y, a, b);
-}
-
-void sge_UpdateRect(SDL_Surface* screen, const SDL_Rect& area)
-{
-    sge_UpdateRect(screen, area.x, area.y, area.w, area.h);
-}
-
 //==================================================================================
 // Creates a 32bit (8/8/8/8) alpha surface
 // Map colors with sge_MapAlpha() and then use the Uint32 color versions of
@@ -149,25 +81,6 @@ Uint32 sge_MapAlpha(Uint8 R, Uint8 G, Uint8 B, Uint8 A)
     return color;
 }
 
-//==================================================================================
-// Sets an SDL error string
-// Accepts formated argument - like printf()
-// SDL_SetError() also does this, but it does not use standard syntax (why?)
-//==================================================================================
-void sge_SetError(const char* format, ...)
-{
-    std::array<char, 256> buf;
-
-    va_list ap;
-
-    va_start(ap, format);
-
-    vsprintf(buf.data(), format, ap);
-    va_end(ap);
-
-    SDL_SetError(buf.data());
-}
-
 /**********************************************************************************/
 /**                            Pixel functions                                   **/
 /**********************************************************************************/
@@ -277,12 +190,6 @@ void sge_PutPixel(SDL_Surface* surface, Sint16 x, Sint16 y, Uint32 color)
     {
         SDL_UnlockSurface(surface);
     }
-
-    if(!_sge_update)
-    {
-        return;
-    }
-    sge_UpdateRect(surface, x, y, 1, 1);
 }
 
 //==================================================================================
@@ -545,12 +452,6 @@ void sge_PutPixelAlpha(SDL_Surface* surface, Sint16 x, Sint16 y, Uint32 color, U
     {
         SDL_UnlockSurface(surface);
     }
-
-    if(!_sge_update)
-    {
-        return;
-    }
-    sge_UpdateRect(surface, x, y, 1, 1);
 }
 
 void _PutPixelAlpha(SDL_Surface* surface, Sint16 x, Sint16 y, Uint8 R, Uint8 G, Uint8 B, Uint8 alpha)
@@ -612,12 +513,6 @@ void sge_read_block32(SDL_Surface* Surface, Uint32* block, Sint16 y)
 void sge_ClearSurface(SDL_Surface* Surface, Uint32 color)
 {
     SDL_FillRect(Surface, nullptr, color);
-
-    if(!_sge_update)
-    {
-        return;
-    }
-    SDL_UpdateRect(Surface, 0, 0, 0, 0);
 }
 
 //==================================================================================
@@ -638,41 +533,6 @@ int sge_BlitTransparent(SDL_Surface* Src, SDL_Surface* Dest, Sint16 SrcX, Sint16
     SDL_Rect src, dest;
     int ret;
 
-/* Dest clipping */
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) < SDL_VERSIONNUM(1, 1, 5)
-    int flag = 0;
-    if(DestX < Dest->clip_minx)
-    {
-        SrcX += Dest->clip_minx - DestX;
-        W -= Dest->clip_minx - DestX - 1;
-        DestX = Dest->clip_minx;
-    }
-    if(DestY < Dest->clip_miny)
-    {
-        SrcY += Dest->clip_miny - DestY;
-        H -= Dest->clip_miny - DestY - 1;
-        DestY = Dest->clip_miny;
-    }
-    if((DestX + W) > Dest->clip_maxx)
-    {
-        W = W - ((DestX + W) - Dest->clip_maxx) + 1;
-        if(W <= 0)
-        {
-            SDL_SetError("SGE - Blit error");
-            return -1;
-        }
-    }
-    if((DestY + H) > Dest->clip_maxy)
-    {
-        H = H - ((DestY + H) - Dest->clip_maxy) + 1;
-        if(H <= 0)
-        {
-            SDL_SetError("SGE - Blit error");
-            return -1;
-        }
-    }
-#endif
-
     /* Initialize our rectangles */
     src.x = SrcX;
     src.y = SrcY;
@@ -684,35 +544,20 @@ int sge_BlitTransparent(SDL_Surface* Src, SDL_Surface* Dest, Sint16 SrcX, Sint16
     dest.w = W;
     dest.h = H;
 
-/* We don't care about src clipping, only dest! */
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) < SDL_VERSIONNUM(1, 1, 5)
-    if((Src->flags & SDL_SRCCLIPPING) == SDL_SRCCLIPPING)
-    {
-        Src->flags &= ~SDL_SRCCLIPPING;
-        flag = 1;
-    }
-#endif
-
     /* Set the color to be transparent */
-    SDL_SetColorKey(Src, SDL_SRCCOLORKEY, Clear);
+    SDL_SetColorKey(Src, SDL_TRUE, Clear);
 
     /* Set the alpha value */
-    SDL_SetAlpha(Src, SDL_SRCALPHA, Alpha);
+    Uint8 oldAlpha;
+    SDL_GetSurfaceAlphaMod(Src, &oldAlpha);
+    SDL_SetSurfaceAlphaMod(Src, Alpha);
 
     /* Blit */
     ret = SDL_BlitSurface(Src, &src, Dest, &dest);
 
-/* Set the correct flag */
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) < SDL_VERSIONNUM(1, 1, 5)
-    if(flag == 1)
-    {
-        Src->flags |= SDL_SRCCLIPPING;
-    }
-#endif
-
     /* Set normal levels */
-    SDL_SetAlpha(Src, 0, 0);
-    SDL_SetColorKey(Src, 0, 0);
+    SDL_SetSurfaceAlphaMod(Src, oldAlpha);
+    SDL_SetColorKey(Src, SDL_FALSE, 0);
 
     return ret;
 }
@@ -726,41 +571,6 @@ int sge_Blit(SDL_Surface* Src, SDL_Surface* Dest, Sint16 SrcX, Sint16 SrcY, Sint
     SDL_Rect src, dest;
     int ret;
 
-/* Dest clipping */
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) < SDL_VERSIONNUM(1, 1, 5)
-    int flag = 0;
-    if(DestX < Dest->clip_minx)
-    {
-        SrcX += Dest->clip_minx - DestX;
-        W -= Dest->clip_minx - DestX - 1;
-        DestX = Dest->clip_minx;
-    }
-    if(DestY < Dest->clip_miny)
-    {
-        SrcY += Dest->clip_miny - DestY;
-        H -= Dest->clip_miny - DestY - 1;
-        DestY = Dest->clip_miny;
-    }
-    if((DestX + W) > Dest->clip_maxx)
-    {
-        W = W - ((DestX + W) - Dest->clip_maxx) + 1;
-        if(W <= 0)
-        {
-            SDL_SetError("SGE - Blit error");
-            return -1;
-        }
-    }
-    if((DestY + H) > Dest->clip_maxy)
-    {
-        H = H - ((DestY + H) - Dest->clip_maxy) + 1;
-        if(H <= 0)
-        {
-            SDL_SetError("SGE - Blit error");
-            return -1;
-        }
-    }
-#endif
-
     /* Initialize our rectangles */
     src.x = SrcX;
     src.y = SrcY;
@@ -772,26 +582,9 @@ int sge_Blit(SDL_Surface* Src, SDL_Surface* Dest, Sint16 SrcX, Sint16 SrcY, Sint
     dest.w = W;
     dest.h = H;
 
-/* We don't care about src clipping, only dest! */
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) < SDL_VERSIONNUM(1, 1, 5)
-    if((Src->flags & SDL_SRCCLIPPING) == SDL_SRCCLIPPING)
-    {
-        Src->flags &= ~SDL_SRCCLIPPING;
-        flag = 1;
-    }
-#endif
-
     /* Blit */
     ret = SDL_BlitSurface(Src, &src, Dest, &dest);
 
-/* Set the correct flag */
-#if SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL) < SDL_VERSIONNUM(1, 1, 5)
-    if(flag == 1)
-    {
-        Src->flags |= SDL_SRCCLIPPING;
-    }
-#endif
-
     return ret;
 }
 
@@ -816,7 +609,7 @@ SDL_Color sge_FillPaletteEntry(Uint8 R, Uint8 G, Uint8 B)
     color.r = R;
     color.g = G;
     color.b = B;
-    color.unused = 0;
+    color.a = 0;
 
     return color;
 }
diff --git a/external/s25edit/SGE/sge_textpp.cpp b/external/s25edit/SGE/sge_textpp.cpp
deleted file mode 100644
index fbdabcb..0000000
--- a/external/s25edit/SGE/sge_textpp.cpp
+++ /dev/null
@@ -1,803 +0,0 @@
-/*
- *	SDL Graphics Extension
- *	Text/TrueType classes
- *
- *	Started 990826 / 010207 (new version)
- *
- *	License: LGPL v2+ (see the file LICENSE)
- *	(c)1999-2003 Anders LindstrÃ¶m
- *
- *	Uses the excellent FreeType 2 library, available at:
- *	http://www.freetype.org/
- */
-
-/*********************************************************************
- *  This library is free software; you can redistribute it and/or    *
- *  modify it under the terms of the GNU Library General Public      *
- *  License as published by the Free Software Foundation; either     *
- *  version 2 of the License, or (at your option) any later version. *
- *********************************************************************/
-
-#include "sge_textpp.h"
-#include "sge_bm_text.h"
-#include "sge_surface.h"
-#include <array>
-#include <cstdarg>
-
-#ifndef _SGE_NO_CLASSES
-
-using namespace std;
-
-//==================================================================================
-// sge_TextEditor
-//==================================================================================
-sge_TextEditor::node* sge_TextEditor::new_node(node* p, node* n, Uint16 c)
-{
-    auto* tmp = new node;
-
-    tmp->prev = p;
-    tmp->next = n;
-    tmp->c = c;
-
-    text_changed = true;
-    return tmp;
-}
-
-bool sge_TextEditor::nswap(node* one, node* two)
-{
-    if(!one || !two || one == two)
-        return false;
-
-    // Check if the two nodes are connected
-    if(one->prev == two)
-    {
-        one->prev = two->prev;
-        two->next = one->next;
-        one->next = two;
-        two->prev = one;
-    } else if(one->next == two)
-    {
-        one->next = two->next;
-        two->prev = one->prev;
-        one->prev = two;
-        two->next = one;
-    } else
-    {
-        node* p = one->prev;
-        node* n = one->next;
-
-        one->prev = two->prev;
-        one->next = two->next;
-
-        two->prev = p;
-        two->next = n;
-    }
-
-    // Update connected nodes and list metadata
-    if(!one->prev)
-        start = one;
-    else
-        one->prev->next = one;
-
-    if(!one->next)
-        end = one;
-    else
-        one->next->prev = one;
-
-    if(!two->prev)
-        start = two;
-    else
-        two->prev->next = two;
-
-    if(!two->next)
-        end = two;
-    else
-        two->next->prev = two;
-
-    text_changed = true;
-    return true;
-}
-
-sge_TextEditor::sge_TextEditor()
-{
-    chars = 0;
-    mChars = 0;
-    cursor_char = 124; // The charactar for the cursor - '|'
-    cursor = end = start = new_node(nullptr, nullptr, cursor_char);
-    text_changed = false;
-}
-
-sge_TextEditor::~sge_TextEditor()
-{
-    node* tmp;
-
-    for(node* i = start; i;)
-    {
-        tmp = i->next;
-        delete i;
-        i = tmp;
-    }
-}
-
-bool sge_TextEditor::insert(Uint16 c)
-{
-    if(mChars && chars >= mChars)
-        return false;
-
-    if(cursor->prev)
-    {
-        cursor->prev->next = new_node(cursor->prev, cursor, c);
-        cursor->prev = cursor->prev->next;
-    } else
-    {
-        // New first node - update list metadata
-        cursor->prev = start = new_node(nullptr, cursor, c);
-    }
-
-    chars++;
-    return true;
-}
-
-bool sge_TextEditor::remove_left()
-{
-    if(cursor->prev)
-    {
-        node* tmp = cursor->prev->prev;
-        delete cursor->prev;
-        cursor->prev = tmp;
-
-        if(!cursor->prev)
-            start = cursor;
-        else
-            tmp->next = cursor;
-
-        chars--;
-        text_changed = true;
-        return true;
-    }
-    return false;
-}
-
-bool sge_TextEditor::remove_right()
-{
-    if(cursor->next)
-    {
-        node* tmp = cursor->next->next;
-        delete cursor->next;
-        cursor->next = tmp;
-
-        if(!cursor->next)
-            end = cursor;
-        else
-            tmp->prev = cursor;
-
-        chars--;
-        text_changed = true;
-        return true;
-    }
-    return false;
-}
-
-bool sge_TextEditor::move_left()
-{
-    return nswap(cursor, cursor->prev);
-}
-
-bool sge_TextEditor::move_right()
-{
-    return nswap(cursor, cursor->next);
-}
-
-bool sge_TextEditor::move_start()
-{
-    if(cursor->prev)
-    {
-        cursor->prev->next = cursor->next;
-        if(cursor->next)
-            cursor->next->prev = cursor->prev;
-        else
-            end = cursor->prev;
-
-        cursor->prev = nullptr;
-        cursor->next = start;
-        start->prev = cursor;
-        start = cursor;
-
-        text_changed = true;
-        return true;
-    }
-
-    return false;
-}
-
-bool sge_TextEditor::move_end()
-{
-    if(cursor->next)
-    {
-        cursor->next->prev = cursor->prev;
-        if(cursor->prev)
-            cursor->prev->next = cursor->next;
-        else
-            start = cursor->next;
-
-        cursor->next = nullptr;
-        cursor->prev = end;
-        end->next = cursor;
-        end = cursor;
-
-        text_changed = true;
-        return true;
-    }
-
-    return false;
-}
-
-string sge_TextEditor::get_string(bool wCursor)
-{
-    string ret;
-
-    for(node* i = start; i; i = i->next)
-    {
-        if(!wCursor && i == cursor)
-            continue;
-
-        ret += char(i->c);
-    }
-
-    return ret;
-}
-
-/*
-basic_string<Uint16> sge_TextEditor::get_ustring(bool wCursor)
-{
-    basic_string<Uint16> ret;
-
-    for(node* i=start; i; i=i->next){
-        if(!wCursor && i==cursor)
-            continue;
-
-        ret += i->c;
-    }
-
-    return ret;
-}
-*/
-
-Uint16* sge_TextEditor::get_ucstring(bool wCursor)
-{
-    Uint16* str = nullptr;
-
-    if(wCursor)
-        str = new Uint16[chars + 2];
-    else
-        str = new Uint16[chars + 1];
-
-    int k = 0;
-
-    for(node* i = start; i; i = i->next)
-    {
-        if(!wCursor && i == cursor)
-            continue;
-
-        str[k++] = i->c;
-    }
-
-    str[k] = 0;
-
-    return str;
-}
-
-bool sge_TextEditor::check(SDL_Event* event)
-{
-    if(event->type != SDL_KEYDOWN)
-        return false;
-
-    if(event->key.keysym.sym == SDLK_BACKSPACE)
-        return remove_left();
-    else if(event->key.keysym.sym == SDLK_DELETE)
-        return remove_right();
-    else if(event->key.keysym.sym == SDLK_LEFT)
-        return move_left();
-    else if(event->key.keysym.sym == SDLK_RIGHT)
-        return move_right();
-    else if(event->key.keysym.sym == SDLK_RETURN || event->key.keysym.sym == SDLK_KP_ENTER)
-        return false;
-    else if(event->key.keysym.sym == SDLK_HOME)
-        return move_start();
-    else if(event->key.keysym.sym == SDLK_END)
-        return move_end();
-    else if(event->key.keysym.unicode != 0)
-        return insert(event->key.keysym.unicode);
-
-    return false;
-}
-
-void sge_TextEditor::clear_text()
-{
-    if(!chars)
-        return;
-
-    node* tmp;
-
-    for(node* i = start; i;)
-    {
-        tmp = i->next;
-        delete i;
-        i = tmp;
-    }
-
-    cursor = end = start = new_node(nullptr, nullptr, cursor_char);
-
-    chars = 0;
-    text_changed = true;
-}
-
-void sge_TextEditor::change_text(const std::string& s)
-{
-    clear_text();
-
-    for(char i : s)
-        insert(char(i));
-}
-
-/*
-void sge_TextEditor::change_utext(const std::basic_string<Uint16> s)
-{
-    clear_text();
-
-    for(unsigned int i=0; i<s.size(); i++)
-        insert(s[i]);
-}
-*/
-
-void sge_TextEditor::change_uctext(Uint16* text)
-{
-    Uint16* ch;
-
-    clear_text();
-
-    for(ch = text; *ch; ch++)
-        insert(*ch);
-}
-
-void sge_TextEditor::change_textf(const char* text, ...)
-{
-    std::array<char, 256> buf;
-
-    va_list ap;
-
-    va_start(ap, text);
-
-    vsprintf(buf.data(), text, ap);
-    va_end(ap);
-
-    change_text(buf.data());
-}
-
-//==================================================================================
-// sge_text
-//==================================================================================
-SDL_Surface* sge_text::get_textSurface(bool copy)
-{
-    if(copy)
-        return sge_copy_surface(text_surface);
-    else
-        return text_surface;
-}
-
-bool sge_text::update_textSurface(bool force)
-{
-    if(text_changed || force)
-    {
-#ifndef _SGE_NOTTF
-        if(use_tt && tt_font)
-        {
-            if(text_surface)
-                SDL_FreeSurface(text_surface);
-
-            Uint16* text = get_ucstring(sCursor);
-            text_surface = sge_TTF_Render(tt_font, text, color, background, alpha_level);
-
-            delete[] text;
-            if(!text_surface)
-                return false;
-
-            SDL_SetColorKey(text_surface, SDL_SRCCOLORKEY, SDL_MapRGB(text_surface->format, background.r, background.g, background.b));
-
-            if(alpha_level != SDL_ALPHA_OPAQUE)
-                SDL_SetAlpha(text_surface, SDL_SRCALPHA, alpha_level);
-
-            set_textSurface(text_surface);
-        } else
-#endif
-          if(bm_font)
-        {
-            if(bm_font->CharPos && bm_font->FontSurface->format->Amask)
-            {
-                set_textSurface(nullptr);
-                return true; /* These fonts can't be buffered (SFonts) */
-            }
-
-            if(text_surface)
-                SDL_FreeSurface(text_surface);
-
-            string text = get_string(sCursor);
-            SDL_Rect size = sge_BF_TextSize(bm_font, text.c_str());
-
-            text_surface = SDL_CreateRGBSurface(SDL_SWSURFACE, size.w, size.h, bm_font->FontSurface->format->BitsPerPixel,
-                                                bm_font->FontSurface->format->Rmask, bm_font->FontSurface->format->Gmask,
-                                                bm_font->FontSurface->format->Bmask, 0);
-
-            if(!text_surface)
-                return false;
-
-            Uint32 bcol;
-
-            if(bm_font->FontSurface->format->palette)
-            {
-                // Set the palette
-                std::array<SDL_Color, 2> c;
-                c[0].r = bm_font->FontSurface->format->palette->colors[1].r + 100; /* Whatever */
-                c[0].g = bm_font->FontSurface->format->palette->colors[1].g + 100;
-                c[0].b = bm_font->FontSurface->format->palette->colors[1].b + 100;
-
-                c[1].r = bm_font->FontSurface->format->palette->colors[1].r;
-                c[1].g = bm_font->FontSurface->format->palette->colors[1].g;
-                c[1].b = bm_font->FontSurface->format->palette->colors[1].b;
-                SDL_SetColors(text_surface, c.data(), 0, c.size());
-                bcol = 0;
-            } else
-            {
-                // Use the same background color as the font surface
-                Uint8 r, g, b;
-                SDL_GetRGB(bm_font->bcolor, bm_font->FontSurface->format, &r, &g, &b);
-                bcol = SDL_MapRGB(text_surface->format, r, g, b);
-                sge_ClearSurface(text_surface, bcol);
-            }
-
-            sge_BF_textout(text_surface, bm_font, text.c_str(), 0, 0);
-
-            SDL_SetColorKey(text_surface, SDL_SRCCOLORKEY, bcol);
-
-            if(alpha_level != SDL_ALPHA_OPAQUE)
-                SDL_SetAlpha(text_surface, SDL_SRCALPHA, alpha_level);
-
-            set_textSurface(text_surface);
-        } else
-            return false;
-
-        text_changed = false;
-        return true;
-    }
-
-    return false;
-}
-
-#ifndef _SGE_NOTTF
-void sge_text::set_ttFont(sge_TTFont* font, Uint8 r, Uint8 g, Uint8 b, Uint8 br, Uint8 bg, Uint8 bb)
-{
-    color.r = r;
-    color.g = g;
-    color.b = b;
-    background.r = br;
-    background.g = bg;
-    background.b = bb;
-
-    tt_font = font;
-
-    use_tt = true;
-    update_textSurface(true);
-}
-#endif
-
-void sge_text::set_bmFont(sge_bmpFont* font)
-{
-    bm_font = font;
-
-    use_tt = false;
-    update_textSurface(true);
-}
-
-SDL_Rect sge_text::render_text(SDL_Surface* surface, Sint16 x, Sint16 y)
-{
-#ifndef _SGE_NOTTF
-    if(use_tt && tt_font)
-    {
-        SDL_Rect ret;
-        ret.x = ret.y = ret.w = ret.h = 0;
-
-        SDL_Surface* tmp;
-        Uint16* text = get_ucstring(sCursor);
-        tmp = sge_TTF_Render(tt_font, text, color, background, alpha_level);
-        delete[] text;
-        if(!tmp)
-            return ret;
-
-        SDL_SetColorKey(tmp, SDL_SRCCOLORKEY, SDL_MapRGB(tmp->format, background.r, background.g, background.b));
-        if(alpha_level != SDL_ALPHA_OPAQUE)
-            SDL_SetAlpha(tmp, SDL_SRCALPHA, alpha_level);
-
-        sge_Blit(tmp, surface, 0, 0, x, y, tmp->w, tmp->h);
-        ret.x = x;
-        ret.y = y;
-        ret.w = tmp->w;
-        ret.h = tmp->h;
-
-        SDL_FreeSurface(tmp);
-        return ret;
-    } else
-#endif
-      if(bm_font)
-    {
-        string text = get_string(sCursor);
-
-        if(alpha_level != SDL_ALPHA_OPAQUE && !bm_font->FontSurface->format->Amask)
-            SDL_SetAlpha(bm_font->FontSurface, SDL_SRCALPHA, alpha_level);
-
-        return sge_BF_textout(surface, bm_font, text.c_str(), x, y);
-    } else
-    {
-        SDL_Rect ret;
-        ret.x = ret.y = ret.w = ret.h = 0;
-        return ret;
-    }
-}
-
-//==================================================================================
-// sge_TextSurface
-//==================================================================================
-void sge_TextSurface::set_textSurface(SDL_Surface* new_surf)
-{
-    if(bm_font)
-    {
-        if(bm_font->CharPos && bm_font->FontSurface->format->Amask)
-        {
-            SDL_Rect size = sge_BF_TextSize(bm_font, get_string(sCursor).c_str());
-            current_pos.w = size.w;
-            current_pos.h = size.h;
-
-            return;
-        }
-    }
-
-    surface = new_surf;
-    current_pos.w = surface->w;
-    current_pos.h = surface->h;
-}
-
-void sge_TextSurface::draw()
-{
-    if(bm_font)
-    {
-        if(bm_font->CharPos && bm_font->FontSurface->format->Amask)
-        { /* These fonts can't be buffered and must be rendered */
-            SDL_Rect size = render_text(dest, current_pos.x, current_pos.y);
-
-            current_pos.w = size.w;
-            current_pos.h = size.h;
-
-            prev_pos = last_pos;
-            last_pos = current_pos;
-
-            return;
-        }
-    }
-
-    update_textSurface();
-    if(text_surface)
-        sge_surface::draw();
-}
-
-//==================================================================================
-// sge_TextSsprite
-//==================================================================================
-void sge_TextSsprite::set_textSurface(SDL_Surface* new_surf)
-{
-    if(bm_font)
-    {
-        if(bm_font->CharPos && bm_font->FontSurface->format->Amask)
-        {
-            SDL_Rect size = sge_BF_TextSize(bm_font, get_string(sCursor).c_str());
-            current_pos.w = size.w;
-            current_pos.h = size.h;
-
-            return;
-        }
-    }
-
-    // Update the first frame
-    sge_frame* tmp = frames.front();
-    if(tmp->img == surface)
-    {
-        surface = new_surf;
-        current_pos.w = surface->w;
-        current_pos.h = surface->h;
-    }
-    tmp->img = new_surf;
-}
-
-void sge_TextSsprite::draw()
-{
-    if(bm_font)
-    {
-        if(bm_font->CharPos && bm_font->FontSurface->format->Amask)
-        { /* These fonts can't be buffered and must be rendered */
-            SDL_Rect size = render_text(dest, current_pos.x, current_pos.y);
-
-            current_pos.w = size.w;
-            current_pos.h = size.h;
-
-            prev_pos = last_pos;
-            last_pos = current_pos;
-
-            return;
-        }
-    }
-
-    update_textSurface();
-    if(text_surface)
-    {
-        sge_surface::draw();
-    }
-}
-
-//==================================================================================
-// sge_TextSprite
-//==================================================================================
-void sge_TextSprite::set_textSurface(SDL_Surface* new_surf)
-{
-    if(bm_font)
-    {
-        if(bm_font->CharPos && bm_font->FontSurface->format->Amask)
-        {
-            SDL_Rect size = sge_BF_TextSize(bm_font, get_string(sCursor).c_str());
-            current_pos.w = size.w;
-            current_pos.h = size.h;
-
-            return;
-        }
-    }
-
-    // Update the first frame
-    sge_frame* tmp = frames.front();
-    if(tmp->img == surface)
-    {
-        surface = new_surf;
-        current_pos.w = surface->w;
-        current_pos.h = surface->h;
-    }
-    tmp->img = new_surf;
-}
-
-void sge_TextSprite::draw()
-{
-    if(bm_font)
-    {
-        if(bm_font->CharPos && bm_font->FontSurface->format->Amask)
-        { /* These fonts can't be buffered and must be rendered */
-            SDL_Rect size = render_text(dest, current_pos.x, current_pos.y);
-
-            current_pos.w = size.w;
-            current_pos.h = size.h;
-
-            prev_pos = last_pos;
-            last_pos = current_pos;
-
-            return;
-        }
-    }
-
-    update_textSurface();
-    if(text_surface)
-    {
-        sge_surface::draw();
-    }
-}
-
-//==================================================================================
-// A helper function for lazy users: blocking text input for sge_TextSurface
-// objects.
-// Flags is the same as for BM and TTF input (which now uses this function)
-//==================================================================================
-extern Uint8 _sge_update;
-
-int sge_text_input(sge_TextSurface* tc, Uint8 flags)
-{
-    if(!tc)
-        return -4;
-
-    Uint8 update = _sge_update;
-
-    SDL_Surface* screen = tc->get_dest();
-    SDL_Surface* buffer = nullptr;
-
-    SDL_Color bg;
-    bg.r = bg.g = bg.b = 0;
-    bool is_ttf = tc->get_bg(&bg); /* No bc color indicates bitmap font */
-
-    if(flags & SGE_FLAG1 || !is_ttf)
-    { /* Keep background? */
-        buffer = SDL_DisplayFormat(screen);
-        if(!buffer)
-        {
-            SDL_SetError("SGE - Out of memory");
-            return -3;
-        }
-    }
-
-    /* Enable keyrepeat */
-    if(!(flags & SGE_FLAG3))
-        SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL + 50);
-
-    int uflag = SDL_EnableUNICODE(1);
-
-    Sint16 x = tc->get_xpos();
-    Sint16 y = tc->get_ypos();
-
-    /* Draw the text for the first time */
-    tc->draw();
-    tc->UpdateRects();
-
-    /* Main loop */
-    SDL_Event event;
-    int quit = 0;
-    do
-    {
-        SDL_WaitEvent(&event);
-        if(event.type == SDL_QUIT)
-        {
-            quit = -1;
-            break;
-        } else if(event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_ESCAPE)
-        {
-            quit = -2;
-            break;
-        } else if(event.type == SDL_KEYDOWN && (event.key.keysym.sym == SDLK_RETURN || event.key.keysym.sym == SDLK_KP_ENTER))
-        {
-            quit = 0;
-            break;
-        }
-
-        /* Let the text class handle the event*/
-        if(tc->check(&event))
-        {
-            /* The text has changed */
-            if(buffer)
-                tc->clear(buffer, x, y); // Remove the text
-            else
-                tc->clear(SDL_MapRGB(screen->format, bg.r, bg.g, bg.b));
-
-            tc->draw(); // Draw the new text
-            sge_Update_ON();
-            tc->UpdateRects(); // Update screen
-            sge_Update_OFF();
-        }
-    } while(true);
-
-    if(buffer)
-    {
-        tc->clear(buffer, x, y); // Remove the text
-        SDL_FreeSurface(buffer);
-    }
-
-    if(!(flags & SGE_FLAG2))
-    {
-        // Draw text without cursor
-        tc->show_cursor(false);
-        tc->draw();
-    }
-
-    sge_Update_ON();
-    tc->UpdateRects(); // Update screen
-
-    _sge_update = update;
-
-    SDL_EnableUNICODE(uflag); // Restore unicode setting
-
-    if(quit < 0)
-        return quit;
-    else
-        return tc->get_chars();
-}
-
-#endif /* _SGE_NO_CLASSES */
diff --git a/external/s25edit/SGE/sge_tt_text.cpp b/external/s25edit/SGE/sge_tt_text.cpp
deleted file mode 100644
index 81c304b..0000000
--- a/external/s25edit/SGE/sge_tt_text.cpp
+++ /dev/null
@@ -1,1568 +0,0 @@
-/*
- *	SDL Graphics Extension
- *	Text/TrueType font functions
- *
- *	Started 990815
- *
- *	License: LGPL v2+ (see the file LICENSE)
- *	(c)1999-2003 Anders LindstrÃ¶m
- *
- *	Uses the excellent FreeType 2 library, available at:
- *	http://www.freetype.org/
- */
-
-/*********************************************************************
- *  This library is free software; you can redistribute it and/or    *
- *  modify it under the terms of the GNU Library General Public      *
- *  License as published by the Free Software Foundation; either     *
- *  version 2 of the License, or (at your option) any later version. *
- *********************************************************************/
-
-/*
- *  Most of this code is taken from the SDL ttf lib by Sam Lantinga
- *  <slouken@devolution.com>
- */
-
-#include "sge_tt_text.h"
-#include <cstdlib>
-#include <cstring>
-
-#ifndef _SGE_NOTTF
-#include <freetype/freetype.h>
-#include <freetype/ftoutln.h>
-#include <freetype/internal/ftobjs.h>
-#include <freetype/ttnameid.h>
-
-/* The structure used to hold glyph information (cached) */
-struct glyph
-{
-    int stored;
-    FT_UInt index;
-    // FT_Bitmap bitmap;
-    FT_Bitmap pixmap;
-    int minx;
-    int maxx;
-    int miny;
-    int maxy;
-    int yoffset;
-    int advance;
-    Uint16 cached;
-};
-
-/* the truetype font structure */
-struct _sge_TTFont
-{
-    FT_Face face;
-
-    /* Font metrics */
-    int height;
-    int ascent;
-    int descent;
-    int lineskip;
-
-    /* The font style */
-    Uint8 style;
-
-    /* Extra width in glyph bounds for text styles */
-    int glyph_overhang;
-    float glyph_italics;
-
-    /* Information in the font for underlining */
-    int underline_offset;
-    int underline_height;
-
-    /* For now, support Latin-1 character set caching */
-    glyph* current;
-    std::array<glyph, 256> cache;
-    glyph scratch;
-
-    /* We are responsible for closing the font stream */
-    SDL_RWops* src;
-    int freesrc;
-    FT_Open_Args args;
-
-    /* For non-scalable formats, we must remember which font index size */
-    int font_size_family;
-};
-
-/* FIXME: Right now we assume the gray-scale renderer Freetype is using
-   supports 256 shades of gray, but we should instead key off of num_grays
-   in the result FT_Bitmap after the FT_Render_Glyph() call. */
-#define NUM_GRAYS 256
-
-/* Handy routines for converting from fixed point */
-#define FT_FLOOR(X) (((X) & -64) / 64)
-#define FT_CEIL(X) ((((X) + 63) & -64) / 64)
-
-#define CACHED_METRICS 0x10
-#define CACHED_BITMAP 0x01
-#define CACHED_PIXMAP 0x02
-
-/* Fix a problem with older version of Freetype */
-#ifndef FT_OPEN_STREAM
-#define FT_OPEN_STREAM ft_open_stream
-#endif
-
-/* The FreeType font engine/library */
-static FT_Library _sge_library;
-static int _sge_TTF_initialized = 0;
-static int _sge_TTF_byteswapped = 0;
-
-Uint8 _sge_TTF_AA = 1; // Rendering mode: 0-OFF, 1-AA, 2-Alpha
-
-/**********************************************************************************/
-/**                          Open/misc font functions                            **/
-/**********************************************************************************/
-
-//==================================================================================
-// Turns TTF AntiAliasing On/Off or alpha (nice but slow) (Default: On)
-//==================================================================================
-void sge_TTF_AAOff()
-{
-    _sge_TTF_AA = 0;
-}
-void sge_TTF_AAOn()
-{
-    _sge_TTF_AA = 1;
-}
-void sge_TTF_AA_Alpha()
-{
-    _sge_TTF_AA = 2;
-}
-
-//==================================================================================
-// Control UNICODE byteswapping (default: no => swapped=0)
-//==================================================================================
-/* This function tells the library whether UNICODE text is generally
-   byteswapped.  A UNICODE BOM character at the beginning of a string
-   will override this setting for that string.
- */
-void sge_TTF_ByteSwappedUNICODE(int swapped)
-{
-    _sge_TTF_byteswapped = swapped;
-}
-
-//==================================================================================
-// Closes the ttf engine, done by exit
-//==================================================================================
-void sge_TTF_Quit()
-{
-    if(_sge_TTF_initialized)
-    {
-        FT_Done_FreeType(_sge_library);
-    }
-    _sge_TTF_initialized = 0;
-}
-
-//==================================================================================
-// Starts the ttf engine, must be called first
-//==================================================================================
-int sge_TTF_Init()
-{
-    FT_Error error;
-
-    if(_sge_TTF_initialized)
-        return 0;
-
-    error = FT_Init_FreeType(&_sge_library);
-    if(error)
-    {
-        SDL_SetError("SGE - Couldn't init FreeType engine");
-        return (-1);
-    } else
-    {
-        _sge_TTF_initialized = 1;
-    }
-    atexit(sge_TTF_Quit); // dont't trust the user...
-    return 0;
-}
-
-//==================================================================================
-// Some helper functions
-//==================================================================================
-void Flush_Glyph(glyph* glyph)
-{
-    glyph->stored = 0;
-    glyph->index = 0;
-    // if( glyph->bitmap.buffer ) {
-    //	free( glyph->bitmap.buffer );
-    //	glyph->bitmap.buffer = 0;
-    //}
-    if(glyph->pixmap.buffer)
-    {
-        free(glyph->pixmap.buffer);
-        glyph->pixmap.buffer = 0;
-    }
-    glyph->cached = 0;
-}
-
-void Flush_Cache(sge_TTFont* font)
-{
-    int i;
-    int size = sizeof(font->cache) / sizeof(font->cache[0]);
-
-    for(i = 0; i < size; ++i)
-    {
-        if(font->cache[i].cached)
-        {
-            Flush_Glyph(&font->cache[i]);
-        }
-    }
-    if(font->scratch.cached)
-    {
-        Flush_Glyph(&font->scratch);
-    }
-}
-
-//==================================================================================
-// Remove font from memory
-//==================================================================================
-void sge_TTF_CloseFont(sge_TTFont* font)
-{
-    Flush_Cache(font);
-
-    if(font->face)
-        FT_Done_Face(font->face);
-    if(font->args.stream)
-        free(font->args.stream);
-    if(font->freesrc)
-        SDL_RWclose(font->src);
-
-    free(font);
-}
-
-//==================================================================================
-// Seek and read stream (internal)
-//==================================================================================
-unsigned long RWread(FT_Stream stream, unsigned long offset, unsigned char* buffer, unsigned long count)
-{
-    SDL_RWops* src;
-
-    src = (SDL_RWops*)stream->descriptor.pointer;
-    SDL_RWseek(src, (int)offset, SEEK_SET);
-    return SDL_RWread(src, buffer, 1, (int)count);
-}
-
-//==================================================================================
-// Open the TT font sream and returns the font
-//==================================================================================
-sge_TTFont* sge_TTF_OpenFontIndexRW(SDL_RWops* src, int freesrc, int ptsize, long index, int xdpi, int ydpi)
-{
-    sge_TTFont* font;
-    FT_Error error;
-    FT_Face face;
-    FT_Fixed scale;
-    FT_Stream stream;
-    int position;
-
-    if(!_sge_TTF_initialized)
-    {
-        SDL_SetError("SGE - Freetype not initialized");
-        return nullptr;
-    }
-
-    /* Check to make sure we can seek in this stream */
-    position = SDL_RWtell(src);
-    if(position < 0)
-    {
-        SDL_SetError("SGE - Can't seek in font stream");
-        return nullptr;
-    }
-
-    font = (sge_TTFont*)malloc(sizeof(*font));
-    if(!font)
-    {
-        SDL_SetError("SGE - Out of memory");
-        return (nullptr);
-    }
-    memset(font, 0, sizeof(*font));
-
-    font->src = src;
-    font->freesrc = freesrc;
-
-    stream = (FT_Stream)malloc(sizeof(*stream));
-    if(!stream)
-    {
-        SDL_SetError("SGE - Out of memory");
-        sge_TTF_CloseFont(font);
-        return nullptr;
-    }
-    memset(stream, 0, sizeof(*stream));
-
-    stream->memory = _sge_library->memory;
-    stream->read = RWread;
-    stream->descriptor.pointer = src;
-    stream->pos = (unsigned long)position;
-    SDL_RWseek(src, 0, SEEK_END);
-    stream->size = (unsigned long)(SDL_RWtell(src) - position);
-    SDL_RWseek(src, position, SEEK_SET);
-
-    font->args.flags = FT_OPEN_STREAM;
-    font->args.stream = stream;
-
-    /* Open the font stream and create ancillary data */
-    error = FT_Open_Face(_sge_library, &font->args, index, &font->face);
-    if(error)
-    {
-        SDL_SetError("SGE - Couldn't open font face");
-        sge_TTF_CloseFont(font);
-        return nullptr;
-    }
-    face = font->face;
-
-    /* Handle scalable font face (global metrics) */
-    if(FT_IS_SCALABLE(face))
-    {
-        /* Set the character size and use DPI in arguments */
-        error = FT_Set_Char_Size(font->face, 0, ptsize * 64, xdpi, ydpi);
-        if(error)
-        {
-            SDL_SetError("SGE - Couldn't set font size");
-            sge_TTF_CloseFont(font);
-            return nullptr;
-        }
-
-        /* Get the scalable font metrics for this font */
-        scale = face->size->metrics.y_scale;
-        font->ascent = FT_CEIL(FT_MulFix(face->bbox.yMax, scale));
-        font->descent = FT_CEIL(FT_MulFix(face->bbox.yMin, scale));
-        font->height = font->ascent - font->descent + /* baseline */ 1;
-        font->lineskip = FT_CEIL(FT_MulFix(face->height, scale));
-        font->underline_offset = FT_FLOOR(FT_MulFix(face->underline_position, scale));
-        font->underline_height = FT_FLOOR(FT_MulFix(face->underline_thickness, scale));
-    } else
-    {
-        /* Non-scalable font face.  ptsize determines which family
-         * or series of fonts to grab from the non-scalable format.
-         * It is not the point size of the font.
-         * */
-        if(ptsize >= font->face->num_fixed_sizes)
-            ptsize = font->face->num_fixed_sizes - 1;
-
-        font->font_size_family = ptsize;
-        error = FT_Set_Pixel_Sizes(face, face->available_sizes[ptsize].height, face->available_sizes[ptsize].width);
-
-        /* With non-scalale fonts, Freetype2 likes to fill many of the
-         * font metrics with the value of 0.  The size of the
-         * non-scalable fonts must be determined differently
-         * or sometimes cannot be determined.
-         * */
-        font->ascent = face->available_sizes[ptsize].height;
-        font->descent = 0;
-        font->height = face->available_sizes[ptsize].height;
-        font->lineskip = FT_CEIL(font->ascent);
-        font->underline_offset = FT_FLOOR(face->underline_position);
-        font->underline_height = FT_FLOOR(face->underline_thickness);
-    }
-
-    if(font->underline_height < 1)
-        font->underline_height = 1;
-
-    /* Set the default font style */
-    font->style = SGE_TTF_NORMAL;
-    font->glyph_overhang = face->size->metrics.y_ppem / 10;
-    /* x offset = cos(((90.0-12)/360)*2*M_PI), or 12 degree angle */
-    font->glyph_italics = 0.207f;
-    font->glyph_italics *= font->height;
-
-    return font;
-}
-
-sge_TTFont* sge_TTF_OpenFontRW(SDL_RWops* src, int freesrc, int ptsize, int xdpi, int ydpi)
-{
-    return sge_TTF_OpenFontIndexRW(src, freesrc, ptsize, 0, xdpi, ydpi);
-}
-
-sge_TTFont* sge_TTF_OpenFontIndex(const char* file, int ptsize, long index, int xdpi, int ydpi)
-{
-    return sge_TTF_OpenFontIndexRW(SDL_RWFromFile(file, "rb"), 1, ptsize, index, xdpi, ydpi);
-}
-
-sge_TTFont* sge_TTF_OpenFont(const char* file, int ptsize)
-{
-    return sge_TTF_OpenFontIndex(file, ptsize, 0, 96, 96);
-}
-
-//==================================================================================
-// Load a glyph
-//==================================================================================
-FT_Error Load_Glyph(sge_TTFont* font, Uint16 ch, glyph* cached, int want)
-{
-    FT_Face face;
-    FT_Error error;
-    FT_GlyphSlot glyph;
-    FT_Glyph_Metrics* metrics;
-    FT_Outline* outline;
-
-    if(!font || !font->face)
-    {
-        return FT_Err_Invalid_Handle;
-    }
-
-    face = font->face;
-
-    /* Load the glyph */
-    if(!cached->index)
-    {
-        cached->index = FT_Get_Char_Index(face, ch);
-    }
-    error = FT_Load_Glyph(face, cached->index, FT_LOAD_DEFAULT);
-    if(error)
-    {
-        return error;
-    }
-
-    /* Get our glyph shortcuts */
-    glyph = face->glyph;
-    metrics = &glyph->metrics;
-    outline = &glyph->outline;
-
-    /* Get the glyph metrics if desired */
-    if((want & CACHED_METRICS) && !(cached->stored & CACHED_METRICS))
-    {
-        if(FT_IS_SCALABLE(face))
-        {
-            /* Get the bounding box */
-            cached->minx = FT_FLOOR(metrics->horiBearingX);
-            cached->maxx = cached->minx + FT_CEIL(metrics->width);
-            cached->maxy = FT_FLOOR(metrics->horiBearingY);
-            cached->miny = cached->maxy - FT_CEIL(metrics->height);
-            cached->yoffset = font->ascent - cached->maxy;
-            cached->advance = FT_CEIL(metrics->horiAdvance);
-        } else
-        {
-            /* Get the bounding box for non-scalable format.
-             * Again, freetype2 fills in many of the font metrics
-             * with the value of 0, so some of the values we
-             * need must be calculated differently with certain
-             * assumptions about non-scalable formats.
-             * */
-            cached->minx = FT_FLOOR(metrics->horiBearingX);
-            cached->maxx = cached->minx + FT_CEIL(metrics->horiAdvance);
-            cached->maxy = FT_FLOOR(metrics->horiBearingY);
-            cached->miny = cached->maxy - FT_CEIL(face->available_sizes[font->font_size_family].height);
-            cached->yoffset = 0;
-            cached->advance = FT_CEIL(metrics->horiAdvance);
-        }
-
-        /* Adjust for bold and italic text */
-        if(font->style & SGE_TTF_BOLD)
-        {
-            cached->maxx += font->glyph_overhang;
-        }
-        if(font->style & SGE_TTF_ITALIC)
-        {
-            cached->maxx += (int)ceil(font->glyph_italics);
-        }
-        cached->stored |= CACHED_METRICS;
-    }
-
-    if(((want & CACHED_BITMAP) && !(cached->stored & CACHED_BITMAP)) || ((want & CACHED_PIXMAP) && !(cached->stored & CACHED_PIXMAP)))
-    {
-        // int mono = (want & CACHED_BITMAP);
-        int i;
-        FT_Bitmap* src;
-        FT_Bitmap* dst;
-
-        /* Handle the italic style */
-        if(font->style & SGE_TTF_ITALIC)
-        {
-            FT_Matrix shear;
-
-            shear.xx = 1 << 16;
-            shear.xy = (int)(font->glyph_italics * (1 << 16)) / font->height;
-            shear.yx = 0;
-            shear.yy = 1 << 16;
-
-            FT_Outline_Transform(outline, &shear);
-        }
-
-        /* Render the glyph */
-        // if ( mono ) {
-        //	error = FT_Render_Glyph( glyph, ft_render_mode_mono );
-        //} else {
-        error = FT_Render_Glyph(glyph, ft_render_mode_normal);
-        //}
-        if(error)
-        {
-            return error;
-        }
-
-        /* Copy over information to cache */
-        src = &glyph->bitmap;
-        // if ( mono ) {
-        //	dst = &cached->bitmap;
-        //} else {
-        dst = &cached->pixmap;
-        //}
-        memcpy(dst, src, sizeof(*dst));
-
-        /* FT_Render_Glyph() and .fon fonts always generate a
-         * two-color (black and white) glyphslot surface, even
-         * when rendered in ft_render_mode_normal.  This is probably
-         * a freetype2 bug because it is inconsistent with the
-         * freetype2 documentation under FT_Render_Mode section.
-         * */
-        if(!FT_IS_SCALABLE(face))
-        {
-            dst->pitch *= 8;
-        }
-
-        /* Adjust for bold and italic text */
-        if(font->style & SGE_TTF_BOLD)
-        {
-            int bump = font->glyph_overhang;
-            dst->pitch += bump;
-            dst->width += bump;
-        }
-        if(font->style & SGE_TTF_ITALIC)
-        {
-            int bump = (int)ceil(font->glyph_italics);
-            dst->pitch += bump;
-            dst->width += bump;
-        }
-
-        if(dst->rows != 0)
-        {
-            dst->buffer = (unsigned char*)malloc(dst->pitch * dst->rows);
-            if(!dst->buffer)
-            {
-                return FT_Err_Out_Of_Memory;
-            }
-            memset(dst->buffer, 0, dst->pitch * dst->rows);
-
-            for(i = 0; i < src->rows; i++)
-            {
-                int soffset = i * src->pitch;
-                int doffset = i * dst->pitch;
-                /*if ( mono ) {
-                    unsigned char *srcp = src->buffer + soffset;
-                    unsigned char *dstp = dst->buffer + doffset;
-                    int j;
-                    for ( j = 0; j < src->width; j += 8 ) {
-                        unsigned char ch = *srcp++;
-                        *dstp++ = (ch&0x80) >> 7;
-                        ch <<= 1;
-                        *dstp++ = (ch&0x80) >> 7;
-                        ch <<= 1;
-                        *dstp++ = (ch&0x80) >> 7;
-                        ch <<= 1;
-                        *dstp++ = (ch&0x80) >> 7;
-                        ch <<= 1;
-                        *dstp++ = (ch&0x80) >> 7;
-                        ch <<= 1;
-                        *dstp++ = (ch&0x80) >> 7;
-                        ch <<= 1;
-                        *dstp++ = (ch&0x80) >> 7;
-                        ch <<= 1;
-                        *dstp++ = (ch&0x80) >> 7;
-                    }
-                } else */
-                if(!FT_IS_SCALABLE(face))
-                {
-                    /* This special case wouldn't
-                     * be here if the FT_Render_Glyph()
-                     * function wasn't buggy when it tried
-                     * to render a .fon font with 256
-                     * shades of gray.  Instead, it
-                     * returns a black and white surface
-                     * and we have to translate it back
-                     * to a 256 gray shaded surface.
-                     * */
-                    unsigned char* srcp = src->buffer + soffset;
-                    unsigned char* dstp = dst->buffer + doffset;
-                    unsigned char ch;
-                    int j, k;
-                    for(j = 0; j < src->width; j += 8)
-                    {
-                        ch = *srcp++;
-                        for(k = 0; k < 8; ++k)
-                        {
-                            if((ch & 0x80) >> 7)
-                            {
-                                *dstp++ = NUM_GRAYS - 1;
-                            } else
-                            {
-                                *dstp++ = 0x00;
-                            }
-                            ch <<= 1;
-                        }
-                    }
-                } else
-                {
-                    memcpy(dst->buffer + doffset, src->buffer + soffset, src->pitch);
-                }
-            }
-        }
-
-        /* Handle the bold style */
-        if(font->style & SGE_TTF_BOLD)
-        {
-            int row;
-            int col;
-            int offset;
-            int pixel;
-            Uint8* pixmap;
-
-            /* The pixmap is a little hard, we have to add and clamp */
-            for(row = dst->rows - 1; row >= 0; --row)
-            {
-                pixmap = (Uint8*)dst->buffer + row * dst->pitch;
-                for(offset = 1; offset <= font->glyph_overhang; ++offset)
-                {
-                    for(col = dst->width - 1; col > 0; --col)
-                    {
-                        pixel = (pixmap[col] + pixmap[col - 1]);
-                        if(pixel > NUM_GRAYS - 1)
-                        {
-                            pixel = NUM_GRAYS - 1;
-                        }
-                        pixmap[col] = (Uint8)pixel;
-                    }
-                }
-            }
-        }
-
-        /* Mark that we rendered this format */
-        // if ( mono ) {
-        //	cached->stored |= CACHED_BITMAP;
-        //} else {
-        cached->stored |= CACHED_PIXMAP;
-        //}
-    }
-
-    /* We're done, mark this glyph cached */
-    cached->cached = ch;
-
-    return 0;
-}
-
-//==================================================================================
-// Find glyph
-//==================================================================================
-FT_Error Find_Glyph(sge_TTFont* font, Uint16 ch, int want)
-{
-    int retval = 0;
-
-    if(ch < 256)
-    {
-        font->current = &font->cache[ch];
-    } else
-    {
-        if(font->scratch.cached != ch)
-        {
-            Flush_Glyph(&font->scratch);
-        }
-        font->current = &font->scratch;
-    }
-    if((font->current->stored & want) != want)
-    {
-        retval = Load_Glyph(font, ch, font->current, want);
-    }
-    return retval;
-}
-
-//==================================================================================
-// Change the size of font
-//==================================================================================
-int sge_TTF_SetFontSizeDPI(sge_TTFont* font, int ptsize, int xdpi, int ydpi)
-{
-    FT_Error error;
-    FT_Fixed scale;
-    FT_Face face;
-
-    face = font->face;
-    Flush_Cache(font);
-
-    if(FT_IS_SCALABLE(face))
-    {
-        /* Set the character size */
-        error = FT_Set_Char_Size(font->face, 0, ptsize * 64, xdpi, ydpi);
-        if(error)
-        {
-            sge_SetError("SGE - Couldn't set font size");
-            sge_TTF_CloseFont(font);
-            return -1;
-        }
-
-        /* Get the scalable font metrics for this font */
-        scale = face->size->metrics.y_scale;
-        font->ascent = FT_CEIL(FT_MulFix(face->bbox.yMax, scale));
-        font->descent = FT_CEIL(FT_MulFix(face->bbox.yMin, scale));
-        font->height = font->ascent - font->descent + /* baseline */ 1;
-        font->lineskip = FT_CEIL(FT_MulFix(face->height, scale));
-        font->underline_offset = FT_FLOOR(FT_MulFix(face->underline_position, scale));
-        font->underline_height = FT_FLOOR(FT_MulFix(face->underline_thickness, scale));
-
-    } else
-    {
-        /* Non-scalable font case.  ptsize determines which family
-         * or series of fonts to grab from the non-scalable format.
-         * It is not the point size of the font.
-         * */
-        if(ptsize >= font->face->num_fixed_sizes)
-            ptsize = font->face->num_fixed_sizes - 1;
-
-        font->font_size_family = ptsize;
-        error = FT_Set_Pixel_Sizes(face, face->available_sizes[ptsize].height, face->available_sizes[ptsize].width);
-
-        /* With non-scalale fonts, Freetype2 likes to fill many of the
-         * font metrics with the value of 0.  The size of the
-         * non-scalable fonts must be determined differently
-         * or sometimes cannot be determined.
-         * */
-        font->ascent = face->available_sizes[ptsize].height;
-        font->descent = 0;
-        font->height = face->available_sizes[ptsize].height;
-        font->lineskip = FT_CEIL(font->ascent);
-        font->underline_offset = FT_FLOOR(face->underline_position);
-        font->underline_height = FT_FLOOR(face->underline_thickness);
-    }
-
-    if(font->underline_height < 1)
-    {
-        font->underline_height = 1;
-    }
-
-    /* Set the default font style */
-    // font->style = SGE_TTF_NORMAL;
-    font->glyph_overhang = face->size->metrics.y_ppem / 10;
-    /* x offset = cos(((90.0-12)/360)*2*M_PI), or 12 degree angle */
-    font->glyph_italics = 0.207f;
-    font->glyph_italics *= font->height;
-
-    return 0;
-}
-
-int sge_TTF_SetFontSize(sge_TTFont* font, int ptsize)
-{
-    return sge_TTF_SetFontSizeDPI(font, ptsize, 96, 96);
-}
-
-//==================================================================================
-// Get font geometrics
-//==================================================================================
-int sge_TTF_FontHeight(sge_TTFont* font)
-{
-    return (font->height);
-}
-int sge_TTF_FontAscent(sge_TTFont* font)
-{
-    return (font->ascent);
-}
-int sge_TTF_FontDescent(sge_TTFont* font)
-{
-    return (font->descent);
-}
-int sge_TTF_FontLineSkip(sge_TTFont* font)
-{
-    return (font->lineskip);
-}
-long sge_TTF_FontFaces(sge_TTFont* font)
-{
-    return (font->face->num_faces);
-}
-int sge_TTF_FontFaceIsFixedWidth(sge_TTFont* font)
-{
-    return (FT_IS_FIXED_WIDTH(font->face));
-}
-char* sge_TTF_FontFaceFamilyName(sge_TTFont* font)
-{
-    return (font->face->family_name);
-}
-char* sge_TTF_FontFaceStyleName(sge_TTFont* font)
-{
-    return (font->face->style_name);
-}
-int sge_TTF_GlyphMetrics(sge_TTFont* font, Uint16 ch, int* minx, int* maxx, int* miny, int* maxy, int* advance)
-{
-    FT_Error error;
-
-    error = Find_Glyph(font, ch, CACHED_METRICS);
-
-    if(error)
-    {
-        return -1;
-    }
-
-    if(minx)
-    {
-        *minx = font->current->minx;
-    }
-    if(maxx)
-    {
-        *maxx = font->current->maxx;
-    }
-    if(miny)
-    {
-        *miny = font->current->miny;
-    }
-    if(maxy)
-    {
-        *maxy = font->current->maxy;
-    }
-    if(advance)
-    {
-        *advance = font->current->advance;
-    }
-    return 0;
-}
-
-//==================================================================================
-// Set font style
-//==================================================================================
-void sge_TTF_SetFontStyle(sge_TTFont* font, Uint8 style)
-{
-    font->style = style;
-    Flush_Cache(font);
-}
-
-//==================================================================================
-// Get font style
-//==================================================================================
-Uint8 sge_TTF_GetFontStyle(sge_TTFont* font)
-{
-    return (font->style);
-}
-#endif /* _SGE_NOTTF */
-
-Uint16* sge_Latin1_Uni(const char* text)
-{
-    Uint16* unicode_text;
-    int i, unicode_len;
-
-    /* Copy the Latin-1 text to a UNICODE text buffer */
-    unicode_len = static_cast<int>(strlen(text));
-    unicode_text = (Uint16*)malloc((unicode_len + 1) * (sizeof *unicode_text));
-    if(!unicode_text)
-    {
-        SDL_SetError("SGE - Out of memory");
-        return (nullptr);
-    }
-    for(i = 0; i < unicode_len; ++i)
-    {
-        unicode_text[i] = ((const unsigned char*)text)[i];
-    }
-    unicode_text[i] = 0;
-
-    return (unicode_text);
-}
-
-#ifndef _SGE_NOTTF
-
-//==================================================================================
-// Convert the Latin-1 text to UNICODE
-//==================================================================================
-static Uint16* ASCII_to_UNICODE(Uint16* unicode, const char* text, int len)
-{
-    int i;
-
-    for(i = 0; i < len; ++i)
-    {
-        unicode[i] = ((const unsigned char*)text)[i];
-    }
-    unicode[i] = 0;
-
-    return unicode;
-}
-
-//==================================================================================
-// Convert the UTF-8 text to UNICODE
-//==================================================================================
-static Uint16* UTF8_to_UNICODE(Uint16* unicode, const char* utf8, int len)
-{
-    int i, j;
-    Uint16 ch;
-
-    for(i = 0, j = 0; i < len; ++i, ++j)
-    {
-        ch = ((const unsigned char*)utf8)[i];
-        if(ch >= 0xF0)
-        {
-            ch = (Uint16)(utf8[i] & 0x07) << 18;
-            ch |= (Uint16)(utf8[++i] & 0x3F) << 12;
-            ch |= (Uint16)(utf8[++i] & 0x3F) << 6;
-            ch |= (Uint16)(utf8[++i] & 0x3F);
-        } else if(ch >= 0xE0)
-        {
-            ch = (Uint16)(utf8[i] & 0x3F) << 12;
-            ch |= (Uint16)(utf8[++i] & 0x3F) << 6;
-            ch |= (Uint16)(utf8[++i] & 0x3F);
-        } else if(ch >= 0xC0)
-        {
-            ch = (Uint16)(utf8[i] & 0x3F) << 6;
-            ch |= (Uint16)(utf8[++i] & 0x3F);
-        }
-        unicode[j] = ch;
-    }
-    unicode[j] = 0;
-
-    return unicode;
-}
-
-static Uint16* sge_UTF8_Uni(const char* text)
-{
-    Uint16* unicode_text;
-    int unicode_len;
-
-    /* Copy the UTF-8 text to a UNICODE text buffer */
-    unicode_len = static_cast<int>(strlen(text));
-    unicode_text = (Uint16*)malloc((unicode_len + 1) * (sizeof *unicode_text));
-    if(!unicode_text)
-    {
-        SDL_SetError("SGE - Out of memory");
-        return (nullptr);
-    }
-
-    return UTF8_to_UNICODE(unicode_text, text, unicode_len);
-}
-
-//==================================================================================
-// Get the width of the text with the given font
-//==================================================================================
-SDL_Rect sge_TTF_TextSizeUNI(sge_TTFont* font, const Uint16* text)
-{
-    SDL_Rect ret;
-    ret.x = 0;
-    ret.y = 0, ret.w = 0, ret.h = 0;
-    const Uint16* ch;
-    int swapped;
-    int x, z;
-    int minx, maxx;
-    int miny, maxy;
-    glyph* glyph;
-    FT_Error error;
-
-    /* Initialize everything to 0 */
-    if(!_sge_TTF_initialized)
-    {
-        return ret;
-    }
-
-    minx = miny = 0;
-    maxx = maxy = 0;
-    swapped = _sge_TTF_byteswapped;
-
-    /* Load each character and sum it's bounding box */
-    x = 0;
-    for(ch = text; *ch; ++ch)
-    {
-        Uint16 c = *ch;
-        if(c == UNICODE_BOM_NATIVE)
-        {
-            swapped = 0;
-            if(text == ch)
-            {
-                ++text;
-            }
-            continue;
-        }
-        if(c == UNICODE_BOM_SWAPPED)
-        {
-            swapped = 1;
-            if(text == ch)
-            {
-                ++text;
-            }
-            continue;
-        }
-        if(swapped)
-        {
-            c = SDL_Swap16(c);
-        }
-
-        error = Find_Glyph(font, c, CACHED_METRICS);
-        if(error)
-        {
-            return ret;
-        }
-        glyph = font->current;
-
-        if((ch == text) && (glyph->minx < 0))
-        {
-            /* Fixes the texture wrapping bug when the first letter
-             * has a negative minx value or horibearing value.  The entire
-             * bounding box must be adjusted to be bigger so the entire
-             * letter can fit without any texture corruption or wrapping.
-             *
-             * Effects: First enlarges bounding box.
-             * Second, xstart has to start ahead of its normal spot in the
-             * negative direction of the negative minx value.
-             * (pushes everything to the right).
-             *
-             * This will make the memory copy of the glyph bitmap data
-             * work out correctly.
-             * */
-            z -= glyph->minx;
-        }
-
-        z = x + glyph->minx;
-        if(minx > z)
-        {
-            minx = z;
-        }
-        if(font->style & SGE_TTF_BOLD)
-        {
-            x += font->glyph_overhang;
-        }
-        if(glyph->advance > glyph->maxx)
-        {
-            z = x + glyph->advance;
-        } else
-        {
-            z = x + glyph->maxx;
-        }
-        if(maxx < z)
-        {
-            maxx = z;
-        }
-        x += glyph->advance;
-
-        if(glyph->miny < miny)
-        {
-            miny = glyph->miny;
-        }
-        if(glyph->maxy > maxy)
-        {
-            maxy = glyph->maxy;
-        }
-    }
-
-    /* Fill the bounds rectangle */
-    ret.w = (maxx - minx);
-    // ret.h = (maxy - miny); /* This is correct, but breaks many applications */
-    ret.h = font->height;
-
-    return ret;
-}
-
-SDL_Rect sge_TTF_TextSize(sge_TTFont* font, char* text)
-{
-    SDL_Rect ret;
-    ret.x = ret.y = ret.w = ret.y = 0;
-    Uint16* unicode_text;
-    int unicode_len;
-
-    /* Copy the Latin-1 text to a UNICODE text buffer */
-    unicode_len = strlen(text);
-    unicode_text = (Uint16*)malloc((unicode_len + 1) * (sizeof *unicode_text));
-    if(!unicode_text)
-    {
-        SDL_SetError("SGE - Out of memory");
-        return ret;
-    }
-    ASCII_to_UNICODE(unicode_text, text, unicode_len);
-
-    /* Render the new text */
-    ret = sge_TTF_TextSizeUNI(font, unicode_text);
-
-    /* Free the text buffer and return */
-    free(unicode_text);
-
-    return ret;
-}
-
-/**********************************************************************************/
-/**                           TTF output functions                               **/
-/**********************************************************************************/
-
-//==================================================================================
-// TT Render (unicode)
-// Returns an 8bit or 32bit(8/8/8/8-alpha) surface with TT text
-//==================================================================================
-SDL_Surface* sge_TTF_Render(sge_TTFont* font, const Uint16* text, SDL_Color fg, SDL_Color bg, int alpha_level)
-{
-    int xstart, width;
-    int w, h;
-    SDL_Surface* textbuf;
-    SDL_Palette* palette;
-    int index;
-    int rdiff, gdiff, bdiff;
-    int swapped;
-    const Uint16* ch;
-    Uint8 *src, *dst;
-    Uint32* dst32;
-    Uint32 alpha = 0;
-    Uint32 pixel = 0;
-    Uint32 Rmask = 0, Gmask = 0, Bmask = 0, Amask = 0;
-    int row, col;
-    FT_Error error;
-
-    /* Get the dimensions of the text surface */
-    SDL_Rect ret = sge_TTF_TextSizeUNI(font, text);
-    w = ret.w;
-    h = ret.h;
-    if(!w)
-    {
-        SDL_SetError("SGE - Text has zero width");
-        return (nullptr);
-    }
-
-    /* Create the target surface */
-    width = w;
-    if(_sge_TTF_AA != 2) /* Allocate an 8-bit pixmap */
-        textbuf = SDL_AllocSurface(SDL_SWSURFACE, w, h, 8, 0, 0, 0, 0);
-    else
-    { /* Allocate an 32-bit alpha pixmap */
-        if(SDL_BYTEORDER == SDL_LIL_ENDIAN)
-        {
-            Rmask = 0x000000FF;
-            Gmask = 0x0000FF00;
-            Bmask = 0x00FF0000;
-            Amask = 0xFF000000;
-        } else
-        {
-            Rmask = 0xFF000000;
-            Gmask = 0x00FF0000;
-            Bmask = 0x0000FF00;
-            Amask = 0x000000FF;
-        }
-        textbuf = SDL_AllocSurface(SDL_SWSURFACE, w, h, 32, Rmask, Gmask, Bmask, Amask);
-    }
-
-    if(!textbuf)
-    {
-        SDL_SetError("SGE - Out of memory");
-        return (nullptr);
-    }
-
-    /* Setup our colors */
-    switch(_sge_TTF_AA)
-    {
-        case 0:
-        { /* No fancy antialiasing or alpha component */
-            palette = textbuf->format->palette;
-
-            palette->colors[0].r = bg.r;
-            palette->colors[0].g = bg.g;
-            palette->colors[0].b = bg.b;
-            palette->colors[1].r = fg.r;
-            palette->colors[1].g = fg.g;
-            palette->colors[1].b = fg.b;
-        }
-        break;
-
-        case 1:
-        { /* Fill the palette with NUM_GRAYS levels of shading from bg to fg */
-            palette = textbuf->format->palette;
-
-            rdiff = fg.r - bg.r;
-            gdiff = fg.g - bg.g;
-            bdiff = fg.b - bg.b;
-            for(index = 0; index < NUM_GRAYS; ++index)
-            {
-                palette->colors[index].r = bg.r + (index * rdiff) / (NUM_GRAYS - 1);
-                palette->colors[index].g = bg.g + (index * gdiff) / (NUM_GRAYS - 1);
-                palette->colors[index].b = bg.b + (index * bdiff) / (NUM_GRAYS - 1);
-            }
-        }
-        break;
-
-        case 2:
-        { /* Alpha component magic */
-            sge_ClearSurface(textbuf, SDL_MapRGBA(textbuf->format, bg.r, bg.g, bg.b, SDL_ALPHA_TRANSPARENT));
-            // pixel = (fg.r<<16)|(fg.g<<8)|fg.b;
-            pixel = (fg.b << 16) | (fg.g << 8) | fg.r;
-        }
-        break;
-    }
-
-    /* Load and render each character */
-    xstart = 0;
-    swapped = _sge_TTF_byteswapped;
-    for(ch = text; *ch; ++ch)
-    {
-        Uint16 c = *ch;
-        if(c == UNICODE_BOM_NATIVE)
-        {
-            swapped = 0;
-            if(text == ch)
-            {
-                ++text;
-            }
-            continue;
-        }
-        if(c == UNICODE_BOM_SWAPPED)
-        {
-            swapped = 1;
-            if(text == ch)
-            {
-                ++text;
-            }
-            continue;
-        }
-        if(swapped)
-        {
-            c = SDL_Swap16(c);
-        }
-
-        error = Find_Glyph(font, c, CACHED_METRICS | CACHED_PIXMAP);
-
-        if(!error)
-        {
-            /* Compensate for wrap around bug with negative minx's */
-            if((ch == text) && (font->current->minx < 0))
-            {
-                xstart -= font->current->minx;
-            }
-
-            w = font->current->pixmap.width;
-            for(row = 0; row < font->current->pixmap.rows; ++row)
-            {
-                /* Make sure we don't go over the limit */
-                if(row + font->current->yoffset >= textbuf->h)
-                    continue;
-
-                dst = (Uint8*)textbuf->pixels + (row + font->current->yoffset) * textbuf->pitch + xstart + font->current->minx;
-
-                switch(_sge_TTF_AA)
-                {
-                    case 0:
-                    { /* Normal */
-                        src = font->current->pixmap.buffer + row * font->current->pixmap.pitch;
-                        for(col = w; col > 0; --col)
-                        {
-                            *dst++ |= (*src++ < NUM_GRAYS / 2) ? 0 : 1;
-                        }
-                    }
-                    break;
-                    case 1:
-                    { /* Antialiasing */
-                        src = font->current->pixmap.buffer + row * font->current->pixmap.pitch;
-                        for(col = w; col > 0; --col)
-                        {
-                            *dst++ |= *src++;
-                        }
-                    }
-                    break;
-
-                    case 2:
-                    { /* Alpha */
-                        src = (Uint8*)(font->current->pixmap.buffer + font->current->pixmap.pitch * row);
-                        dst32 =
-                          (Uint32*)textbuf->pixels + (row + font->current->yoffset) * textbuf->pitch / 4 + xstart + font->current->minx;
-                        if(alpha_level == SDL_ALPHA_OPAQUE)
-                        {
-                            for(col = w; col > 0; --col)
-                            {
-                                alpha = *src++;
-                                *dst32++ |= pixel | (alpha << 24);
-                            }
-                        } else
-                        {
-                            // We need to scale the alpha value
-                            // Thanks mabi!
-                            for(col = w; col > 0; --col)
-                            {
-                                alpha = (*src++) * alpha_level / 255;
-                                *dst32++ |= pixel | (alpha << 24);
-                            }
-                        }
-                    }
-                    break;
-                }
-            }
-
-            xstart += font->current->advance;
-            if(font->style & SGE_TTF_BOLD)
-            {
-                xstart += font->glyph_overhang;
-            }
-        }
-    }
-
-    /* Handle the underline style */
-    if(font->style & SGE_TTF_UNDERLINE)
-    {
-        int row_offset;
-
-        row_offset = font->ascent - font->underline_offset - 1;
-        if(row_offset > textbuf->h)
-        {
-            row_offset = (textbuf->h - 1) - font->underline_height;
-        }
-
-        if(_sge_TTF_AA == 0)
-        {
-            dst = (Uint8*)textbuf->pixels + row_offset * textbuf->pitch;
-            for(row = font->underline_height; row > 0; --row)
-            {
-                memset(dst, 1, textbuf->w);
-                dst += textbuf->pitch;
-            }
-        } else if(_sge_TTF_AA == 1)
-        {
-            dst = (Uint8*)textbuf->pixels + row_offset * textbuf->pitch;
-            for(row = font->underline_height; row > 0; --row)
-            {
-                memset(dst, NUM_GRAYS - 1, textbuf->w);
-                dst += textbuf->pitch;
-            }
-        } else
-        {
-            // pixel |= Amask;
-            pixel |= (alpha_level << 24);
-            dst32 = (Uint32*)textbuf->pixels + row_offset * textbuf->pitch / 4;
-            for(row = font->underline_height; row > 0; --row)
-            {
-                for(col = 0; col < textbuf->w; ++col)
-                {
-                    dst32[col] = pixel;
-                }
-                dst32 += textbuf->pitch / 4;
-            }
-        }
-    }
-    return (textbuf);
-}
-
-SDL_Surface* sge_TTF_RenderUNICODE(sge_TTFont* font, const Uint16* text, SDL_Color fg, SDL_Color bg)
-{
-    return sge_TTF_Render(font, text, fg, bg, SDL_ALPHA_OPAQUE);
-}
-
-//==================================================================================
-// Renders the Unicode string to TrueType on surface, with the color fcolor.
-// bcolor is the target color for the antialiasing.
-// Alpha sets the transparency of the text (255-solid, 0-max).
-//==================================================================================
-SDL_Rect sge_tt_textout_UNI(SDL_Surface* Surface, sge_TTFont* font, const Uint16* uni, Sint16 x, Sint16 y, Uint32 fcolor, Uint32 bcolor,
-                            int Alpha)
-{
-    SDL_Rect ret;
-    ret.x = 0;
-    ret.y = 0;
-    ret.w = 0;
-    ret.h = 0;
-
-    SDL_Color temp;
-    SDL_Surface* text;
-
-    text = sge_TTF_Render(font, uni, sge_GetRGB(Surface, fcolor), sge_GetRGB(Surface, bcolor), Alpha);
-    if(!text)
-    {
-        return ret;
-    }
-
-    /* Align the surface text to the baseline */
-    Uint16 ascent = font->ascent;
-
-    temp = sge_GetRGB(Surface, bcolor);
-    sge_BlitTransparent(text, Surface, 0, 0, x, y - ascent, text->w, text->h, SDL_MapRGB(text->format, temp.r, temp.g, temp.b), Alpha);
-    sge_UpdateRect(Surface, x, y - ascent, text->w, text->h);
-
-    ret.x = x;
-    ret.y = y - ascent;
-    ret.w = text->w;
-    ret.h = text->h;
-
-    SDL_FreeSurface(text);
-    return ret;
-}
-
-//==================================================================================
-// Renders the Unicode string to TrueType on surface, with the color fcolor.
-// bcolor is the target color for the antialiasing.
-// Alpha sets the transparency of the text (0-solid, 255-max). (RGB)
-//==================================================================================
-SDL_Rect sge_tt_textout_UNI(SDL_Surface* Surface, sge_TTFont* font, const Uint16* uni, Sint16 x, Sint16 y, Uint8 fR, Uint8 fG, Uint8 fB,
-                            Uint8 bR, Uint8 bG, Uint8 bB, int Alpha)
-{
-    SDL_Rect ret;
-    ret.x = 0;
-    ret.y = 0;
-    ret.w = 0;
-    ret.h = 0;
-    SDL_Surface* text;
-
-    text = sge_TTF_Render(font, uni, sge_FillPaletteEntry(fR, fG, fB), sge_FillPaletteEntry(bR, bG, bB), Alpha);
-    if(!text)
-    {
-        return ret;
-    }
-
-    /* Align the surface text to the baseline */
-    Uint16 ascent = font->ascent;
-
-    sge_BlitTransparent(text, Surface, 0, 0, x, y - ascent, text->w, text->h, SDL_MapRGB(text->format, bR, bG, bB), Alpha);
-
-    sge_UpdateRect(Surface, x, y - ascent, text->w, text->h);
-
-    ret.x = x;
-    ret.y = y - ascent;
-    ret.w = text->w;
-    ret.h = text->h;
-
-    SDL_FreeSurface(text);
-    return ret;
-}
-
-//==================================================================================
-// Renders the Latin-1 string to TrueType on surface, with the color fcolor.
-// bcolor is the target color for the antialiasing.
-// Alpha sets the transparency of the text (0-solid, 255-max).
-//==================================================================================
-SDL_Rect sge_tt_textout(SDL_Surface* Surface, sge_TTFont* font, const char* string, Sint16 x, Sint16 y, Uint32 fcolor, Uint32 bcolor,
-                        int Alpha)
-{
-    SDL_Rect ret;
-    Uint16* uni;
-
-    uni = sge_Latin1_Uni(string);
-
-    ret = sge_tt_textout_UNI(Surface, font, uni, x, y, fcolor, bcolor, Alpha);
-    free(uni);
-
-    return ret;
-}
-
-//==================================================================================
-// Renders the Latin-1 string to TrueType on surface, with the color fcolor.
-// bcolor is the target color for the antialiasing.
-// Alpha sets the transparency of the text (0-solid, 255-max). (RGB)
-//==================================================================================
-SDL_Rect sge_tt_textout(SDL_Surface* Surface, sge_TTFont* font, const char* string, Sint16 x, Sint16 y, Uint8 fR, Uint8 fG, Uint8 fB,
-                        Uint8 bR, Uint8 bG, Uint8 bB, int Alpha)
-{
-    SDL_Rect ret;
-    Uint16* uni;
-
-    uni = sge_Latin1_Uni(string);
-
-    ret = sge_tt_textout_UNI(Surface, font, uni, x, y, fR, fG, fB, bR, bG, bB, Alpha);
-    free(uni);
-
-    return ret;
-}
-
-//==================================================================================
-// Renders the UTF-8 string to TrueType on surface, with the color fcolor.
-// bcolor is the target color for the antialiasing.
-// Alpha sets the transparency of the text (0-solid, 255-max).
-//==================================================================================
-SDL_Rect sge_tt_textout_UTF8(SDL_Surface* Surface, sge_TTFont* font, const char* string, Sint16 x, Sint16 y, Uint32 fcolor, Uint32 bcolor,
-                             int Alpha)
-{
-    SDL_Rect ret;
-    Uint16* uni;
-
-    uni = sge_UTF8_Uni(string);
-
-    ret = sge_tt_textout_UNI(Surface, font, uni, x, y, fcolor, bcolor, Alpha);
-    free(uni);
-
-    return ret;
-}
-
-//==================================================================================
-// Renders the UTF-8 string to TrueType on surface, with the color fcolor.
-// bcolor is the target color for the antialiasing.
-// Alpha sets the transparency of the text (0-solid, 255-max). (RGB)
-//==================================================================================
-SDL_Rect sge_tt_textout_UTF8(SDL_Surface* Surface, sge_TTFont* font, const char* string, Sint16 x, Sint16 y, Uint8 fR, Uint8 fG, Uint8 fB,
-                             Uint8 bR, Uint8 bG, Uint8 bB, int Alpha)
-{
-    SDL_Rect ret;
-    Uint16* uni;
-
-    uni = sge_UTF8_Uni(string);
-
-    ret = sge_tt_textout_UNI(Surface, font, uni, x, y, fR, fG, fB, bR, bG, bB, Alpha);
-    free(uni);
-
-    return ret;
-}
-
-//==================================================================================
-// Renders the formatet Latin-1 string to TrueType on surface, with the color fcolor.
-// bcolor is the target color for the antialiasing.
-// Alpha sets the transparency of the text (0-solid, 255-max). (RGB ONLY)
-// * just like printf(char *format,...) *
-//==================================================================================
-SDL_Rect sge_tt_textoutf(SDL_Surface* Surface, sge_TTFont* font, Sint16 x, Sint16 y, Uint8 fR, Uint8 fG, Uint8 fB, Uint8 bR, Uint8 bG,
-                         Uint8 bB, int Alpha, char* format, ...)
-{
-    std::array<char, 256> buf;
-
-    va_list ap;
-
-    va_start(ap, format);
-
-    vsprintf(buf, format, ap);
-    va_end(ap);
-
-    return sge_tt_textout(Surface, font, buf, x, y, fR, fG, fB, bR, bG, bB, Alpha);
-}
-
-/**********************************************************************************/
-/**                          TTF 'input' functions                               **/
-/**********************************************************************************/
-
-// The old code that once lurked here has been replaced by shiny new code that uses
-// the text classes.
-
-int sge_tt_input(SDL_Surface* screen, sge_TTFont* font, char* string, Uint8 flags, int pos, int len, Sint16 x, Sint16 y, Uint8 fR, Uint8 fG,
-                 Uint8 fB, Uint8 bR, Uint8 bG, Uint8 bB, int Alpha)
-{
-    if(pos == 0 && len > 0)
-        string[0] = '\0';
-
-    sge_TextSurface text(screen, string, x, y - sge_TTF_FontAscent(font));
-    text.set_ttFont(font, fR, fG, fB, bR, bG, bB);
-    text.show_cursor(true);
-    text.set_alpha(Alpha);
-    text.max_chars(len - 1);
-
-    int ret = sge_text_input(&text, flags);
-
-    strncpy(string, text.get_string(false).c_str(), sizeof(char) * len);
-    return ret;
-}
-
-int sge_tt_input_UNI(SDL_Surface* screen, sge_TTFont* font, Uint16* string, Uint8 flags, int pos, int len, Sint16 x, Sint16 y, Uint8 fR,
-                     Uint8 fG, Uint8 fB, Uint8 bR, Uint8 bG, Uint8 bB, int Alpha)
-{
-    sge_TextSurface text(screen, "", x, y - sge_TTF_FontAscent(font));
-
-    if(pos != 0)
-        text.change_uctext(string);
-
-    text.set_ttFont(font, fR, fG, fB, bR, bG, bB);
-    text.show_cursor(true);
-    text.set_alpha(Alpha);
-    text.max_chars(len - 1);
-
-    int ret = sge_text_input(&text, flags);
-
-    Uint16* tmp = text.get_ucstring(false);
-
-    strncpy((char*)string, (char*)tmp, sizeof(Uint16) * len);
-
-    delete[] tmp;
-
-    return ret;
-}
-
-int sge_tt_input_UNI(SDL_Surface* screen, sge_TTFont* font, Uint16* string, Uint8 flags, int pos, int len, Sint16 x, Sint16 y, Uint32 fcol,
-                     Uint32 bcol, int Alpha)
-{
-    Uint8 fr, fg, fb, br, bg, bb;
-
-    SDL_GetRGB(fcol, screen->format, &fr, &fg, &fb);
-    SDL_GetRGB(bcol, screen->format, &br, &bg, &bb);
-
-    return sge_tt_input_UNI(screen, font, string, flags, pos, len, x, y, fr, fg, fb, br, bg, bb, Alpha);
-}
-
-int sge_tt_input(SDL_Surface* screen, sge_TTFont* font, char* string, Uint8 flags, int pos, int len, Sint16 x, Sint16 y, Uint32 fcol,
-                 Uint32 bcol, int Alpha)
-{
-    Uint8 fr, fg, fb, br, bg, bb;
-
-    SDL_GetRGB(fcol, screen->format, &fr, &fg, &fb);
-    SDL_GetRGB(bcol, screen->format, &br, &bg, &bb);
-
-    return sge_tt_input(screen, font, string, flags, pos, len, x, y, fr, fg, fb, br, bg, bb, Alpha);
-}
-
-#endif /* _SGE_NOTTF */
diff --git a/external/s25edit/callbacks.cpp b/external/s25edit/callbacks.cpp
index 8a473c9..ecccc39 100644
--- a/external/s25edit/callbacks.cpp
+++ b/external/s25edit/callbacks.cpp
@@ -47,7 +47,7 @@ void callback::PleaseWait(int Param)
             // is done and we don't need the "Please wait"-window anymore)
             CSurface::Draw(global::s2->getDisplaySurface(), WNDWait->getSurface(), global::s2->getDisplaySurface()->w / 2 - 106,
                            global::s2->getDisplaySurface()->h / 2 - 35);
-            SDL_Flip(global::s2->getDisplaySurface());
+            global::s2->RenderPresent();
             break;
 
         case CALL_FROM_GAMELOOP: // This window gives a "Please Wait"-string, so it is shown while there is an intensive operation
@@ -175,7 +175,6 @@ void callback::submenuOptions(int Param)
     static CMenu* SubMenu = nullptr;
     static CFont* TextResolution = nullptr;
     static CButton* ButtonFullscreen = nullptr;
-    static CButton* ButtonOpenGL = nullptr;
     std::array<char, 80> puffer;
     static CSelectBox* SelectBoxRes = nullptr;
 
@@ -183,7 +182,6 @@ void callback::submenuOptions(int Param)
     {
         MAINMENU = 1,
         FULLSCREEN,
-        OPENGL,
         GRAPHICS_CHANGE,
         SELECTBOX_800_600,
         SELECTBOX_832_624,
@@ -247,10 +245,6 @@ void callback::submenuOptions(int Param)
                 SubMenu->delButton(ButtonFullscreen);
             ButtonFullscreen = SubMenu->addButton(submenuOptions, FULLSCREEN, (int)(global::s2->GameResolution.x / 2 - 100), 190, 200, 20,
                                                   BUTTON_RED1, (global::s2->fullscreen ? "WINDOW" : "FULLSCREEN"));
-            if(ButtonOpenGL)
-                SubMenu->delButton(ButtonOpenGL);
-            // ButtonOpenGL = SubMenu->addButton(submenuOptions, OPENGL, (int)(global::s2->GameResolution.x/2-100), 210, 200, 20,
-            // BUTTON_RED1, (CSurface::useOpenGL ? "Software-Rendering" : "OpenGL"));  add selectbox for resolutions
             SelectBoxRes = SubMenu->addSelectBox((int)(global::s2->GameResolution.x / 2 - 100), 70, 200, 110, 11, FONT_YELLOW, BUTTON_GREY);
             SelectBoxRes->setOption("800 x 600 (SVGA)", submenuOptions, SELECTBOX_800_600);
             SelectBoxRes->setOption("832 x 624 (Half Megapixel)", submenuOptions, SELECTBOX_832_624);
@@ -301,7 +295,6 @@ void callback::submenuOptions(int Param)
             SubMenu->setWaste();
             TextResolution = nullptr;
             ButtonFullscreen = nullptr;
-            ButtonOpenGL = nullptr;
             SelectBoxRes = nullptr;
             SubMenu = nullptr;
             mainmenu(INITIALIZING_CALL);
@@ -316,18 +309,11 @@ void callback::submenuOptions(int Param)
             submenuOptions(GRAPHICS_CHANGE);
             break;
 
-        case OPENGL:
-            CSurface::useOpenGL = !CSurface::useOpenGL;
-
-            submenuOptions(GRAPHICS_CHANGE);
-            break;
-
         case GRAPHICS_CHANGE:
             assert(SubMenu);
             SubMenu->setWaste();
             TextResolution = nullptr;
             ButtonFullscreen = nullptr;
-            ButtonOpenGL = nullptr;
             SelectBoxRes = nullptr;
             SubMenu = nullptr;
             submenuOptions(INITIALIZING_CALL);
diff --git a/external/s25edit/include/SdlSurface.h b/external/s25edit/include/SdlSurface.h
index ba47432..d18f7af 100644
--- a/external/s25edit/include/SdlSurface.h
+++ b/external/s25edit/include/SdlSurface.h
@@ -3,16 +3,45 @@
 
 #include <SDL.h>
 #include <memory>
+#include <array>
 
 struct SdlSurfaceDeleter
 {
     void operator()(SDL_Surface* p) { SDL_FreeSurface(p); }
 };
+struct SdlTextureDeleter
+{
+    void operator()(SDL_Texture* p) { SDL_DestroyTexture(p); }
+};
+struct SDLWindowDestroyer
+{
+    void operator()(SDL_Window* p) const { SDL_DestroyWindow(p); }
+};
+struct SDLRendererDestroyer
+{
+    void operator()(SDL_Renderer* p) const { SDL_DestroyRenderer(p); }
+};
 
+using SdlRenderer = std::unique_ptr<SDL_Renderer, SDLRendererDestroyer>;
+using SdlWindow = std::unique_ptr<SDL_Window, SDLWindowDestroyer>;
 using SdlSurface = std::unique_ptr<SDL_Surface, SdlSurfaceDeleter>;
-inline auto makeSdlSurface(Uint32 flags, int width, int height, int depth, bool withAlpha = false)
+using SdlTexture = std::unique_ptr<SDL_Texture, SdlTextureDeleter>;
+
+inline SdlSurface makeRGBSurface(int width, int height, bool withAlpha = false)
+{
+    return SdlSurface(SDL_CreateRGBSurface(0, width, height, 32, 0xFF0000, 0xFF00, 0xFF, withAlpha ? 0xFF000000 : 0));
+}
+inline SdlSurface makePalSurface(int width, int height, const std::array<SDL_Color, 256>& palette)
+{
+    auto surf = SdlSurface(SDL_CreateRGBSurface(0, width, height, 8, 0,0,0,0));
+    if(surf)
+        SDL_SetPaletteColors(surf->format->palette, palette.data(), 0, palette.size());
+    return surf;
+}
+
+inline SdlTexture makeSdlTexture(const SdlRenderer& renderer, Uint32 format, int access, int w, int h)
 {
-    return SdlSurface(SDL_CreateRGBSurface(flags, width, height, depth, 0xFF0000, 0xFF00, 0xFF, withAlpha ? 0xFF000000:0));
+    return SdlTexture(SDL_CreateTexture(renderer.get(), format, access, w, h));
 }
 
 #endif // SdlSurface_h__
